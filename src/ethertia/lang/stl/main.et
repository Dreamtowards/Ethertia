


int i = using {
        Gui* g = GuiButton::new();
        return g;
    }

namespace eth::block {

    std::array_list<Block*> REGISTRY;

    class Block {

        void getVertexData(this, VertexBuffer* vbuf, World* world, vec3 chunkpos, vec3 rpos);
    }

    struct BlockStone : Block {



    }
}

namespace eth::entity {

    struct Entity {
        vec3 position;

    }

    struct EntitySheep : Entity {

        u32 age;



    }

}

namespace std::rtti {

    class Decl {
        std::string qualifiedName;
        std::string simpleName;
        int modifier;

        class Func : Decl {
            std::array_list<DeclVar> parameters;
            Type* returnType;

        }
        class Var : Decl {
            Type* type;
        }
        class Type : Decl {
            Type*[] patches;
            Decl*[] declarations;

        }
    }

    struct TypeInfo {
        void*[] funcptrs;
    }

}


int operator +=() {

}



using std::istream;

using InputStream = std::istream;

using IntList = std::vector<int>;




template<T>
class string : basic_stream {



    void main(string* this, int abc) {

    }


}

void main() {

    int i = 10;

}

Tuple<(void* ptr, u32 len) abc> memblock;


template<typename... Args>
void log(StringStream out, Args a) {
    (out.append(a.toStr();)...


}

log(out, 1f, 2d, 3u8, 4u16);


template< (typename T, identifier I)... T>
struct Tuple {

    T(public: T I )...

    void codeBuilder(Lexer in, StringStream out) {

        while (in.eof()) {
            out += in.typename() + " " + in.identifier() + ";\n";

        }

    }

}