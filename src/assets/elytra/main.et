
// operator i32 _(string lhs, string rhs) { }


//using GLFW::*;
//using GL::*;
//using std::mth::vec3;

//using ethertia::util::Timer;



namespace ethertia::client;

class Window {

    f32 width;
    f32 height;
    f32 mouseX;
    f32 mouseY;
    f32 mouseDX;
    f32 mouseDY;
    f32 scrollDX;
    f32 scrollDY;

    f32 getDScroll(Window* this) {
        // return this->scrollDX + this->scrollDY;
        return 0;
    }

}

class Ethertia {

    static bool running = false;

    //RenderEngine renderEngine;
    //AudioEngine audioEngine;

    //Camera camera;
    Window window;
    //Timer timer;
    //Scheduler scheduler;  // or Executor? executor feels not intuitive.

    //World world;
    //GuiRoot rootGUI;

    void init() {

        running = false;
        //window.initWindow();
        //renderEngine.init();

        //Init::init();

    }

    void runTick() {

    }

    void renderGUI() {

    }

    void runMainLoop() {

        // timer.update(Ethertia::getPreciseTime());

        // scheduler.processTasks();

        // while (timer.tickpoll())
        // {
        //     runTick();
        // }

        // handle();
        // {
        //     renderEngine.renderWorld(&world);

        //     renderGUI();
        // }

        // window.updateWindow();
    }

    void destroy() {



    }

    void run()
    {
        init();

        while (running)
        {
            runMainLoop();
        }

        destroy();
    }

}










/*
@deprecated("some", some: 100, args: 100)
void main<T, u8 N>() {

    vec3(z: 100);
    var int i;
    i = 3 + 1;
}

template<T>
void log(string* patt) {

}

template<typename T, int N>
class vec {
    T[N] v;
}

class vec<T, int N> {
    T[N] v;
}





[[deprecated("some")]]

class iterable<E> {

    iterator iterator();

}
class iterator<E> {

    E get<T=>(instance);

    void next();

    bool has();

}

class array_list<E> : iterable {

    class iterator : std::iterator {

        E get(this) {

        }

    }
}

*/