

//    // http://www.cse.yorku.ca/~amana/research/grid.pdf
//    // Impl of Grid Voxel Raycast.
//    bool raycast(glm::vec3 rpos, glm::vec3 rdir, glm::vec3& _pos, u8& _face) {
//        using glm::vec3;
//
//        vec3 step = glm::sign(rdir);
//
//        vec3 tMax = glm::abs( (glm::fract(rpos)) - glm::max(step, 0.0f)) / glm::abs(rdir);
//
//        vec3 tDelta = 1.0f / glm::abs(rdir);
//
//        glm::vec3 p = glm::floor(rpos);
//
//        int itr = 0;
//        while (++itr < 100) {
//            int face;
//            if (tMax.x < tMax.y && tMax.x < tMax.z) {
//                p.x += step.x;
//                tMax.x += tDelta.x;
//                face = step.x > 0 ? 0 : 1;
//            } else if (tMax.y < tMax.z) {
//                p.y += step.y;
//                tMax.y += tDelta.y;
//                face = step.y > 0 ? 2 : 3;
//            } else {
//                p.z += step.z;
//                tMax.z += tDelta.z;
//                face = step.z > 0 ? 4 : 5;
//            }
//
//            MaterialStat& b = getBlock(p);
//            if (b.id) {
//                _pos = p;
//                _face = face;
//                return true;
//            }
//        }
//        return false;
//    }

//    static void collideAABB(const AABB& self, glm::vec3& d, const AABB& coll) {
//
//
//        if (d.y != 0 && AABB::intersectsAxis(self, coll, 0) && AABB::intersectsAxis(self, coll, 2)) {
//            if (d.y < 0 && self.min.y >= coll.max.y) {
//                d.y = absmin(d.y, coll.max.y - self.min.y);
//            } else if (d.y > 0 && self.max.y <= coll.min.y) {
//                d.y = absmin(d.y, coll.min.y - self.max.y);
//            }
//        }
//        if (d.x != 0 && AABB::intersectsAxis(self, coll, 1) && AABB::intersectsAxis(self, coll, 2)) {
//            if (d.x < 0 && self.min.x >= coll.max.x) {
//                d.x = absmin(d.x, coll.max.x - self.min.x);
//            } else if (d.x > 0 && self.max.x <= coll.min.x) {
//                d.x = absmin(d.x, coll.min.x - self.max.x);
//            }
//        }
//        if (d.z != 0 && AABB::intersectsAxis(self, coll, 0) && AABB::intersectsAxis(self, coll, 1)) {
//            if (d.z < 0 && self.min.z >= coll.max.z) {
//                d.z = absmin(d.z, coll.max.z - self.min.z);
//            } else if (d.z > 0 && self.max.z <= coll.min.z) {
//                d.z = absmin(d.z, coll.min.z - self.max.z);
//            }
//        }
//
//    }
//
//    static float absmin(float a, float b) {
//        return Mth::abs(a) < Mth::abs(b) ? a : b;
//    }





//    EntityCar* car = new EntityCar();
//    world->addEntity(car);
//    car->setPosition({10, 10, -10});


//        EntityRaycastCar* raycastCar = new EntityRaycastCar();
//    raycastCar->setPosition({0, 5, -10});
//    world->addEntity(raycastCar);

//        EventBus::EVENT_BUS.listen([&, raycastCar](KeyboardEvent* e) {
//            if (e->isPressed()) {
//                int key = e->getKey();
//                if (key == GLFW_KEY_ESCAPE) {
//                } else if (isIngame()) {
//                    if (key == GLFW_KEY_SLASH) {
//                        getRootGUI()->addGui(GuiScreenChat::INST);
//                    } else if (key == GLFW_KEY_G) {
//                        raycastCar->m_vehicle->applyEngineForce(100, 2);
//                        raycastCar->m_vehicle->applyEngineForce(100, 3);
//
//                        raycastCar->m_vehicle->setBrake(100, 2);
//                        raycastCar->m_vehicle->setBrake(100, 3);
//
//
//                        raycastCar->m_vehicle->setSteeringValue(0, 0);
//                        raycastCar->m_vehicle->setSteeringValue(0, 1);
//
//                        Log::info("Force");
//                    }
//                }
//            }
//        });



//    void addTaskOrExec() {
//        if (m_ThreadId == std::this_thread::get_id()) {  // execute immediately.
//            task();
//        } else {  // delay.
//            addTask();
//        }
//    }


        if (enet_address_set_host(&addr, hostname.c_str()) < 0)
            throw std::runtime_error(Strings::fmt("illegal hostname '{}', expect ip or domain name.", hostname));



#include <httplib/httplib.h>

httplib::Server serv;
serv.Get("/motd", [](const httplib::Request& req, httplib::Response& resp) {

resp.set_content(R"({"server_name": "The Dedicated Server"})", "application/json");
});

serv.listen("0.0.0.0", 8080);