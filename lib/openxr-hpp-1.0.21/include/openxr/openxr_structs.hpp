// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_STRUCTS_HPP_
#define OPENXR_STRUCTS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR structure types.
 * @ingroup structs
 */

/*!
 * @defgroup structs Structures
 * @brief C++ projections of OpenXR structure types, with easier init but identical layout.
 * @ingroup wrappers
 *
 * These are all implicitly convertible to a reference-to-const to their corresponding raw C types,
 * so you can treat them as you otherwise might.
 */
/*!
 * @defgroup typedstructs Typed/chainable structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field.
 * @ingroup structs
 */
/*!
 * @defgroup abstracttypedstructs Abstract typed structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field,
 * but no specific type enum value of their own: these are the "base structs" in OpenXR.
 * @ingroup typedstructs
 */

// for strncpy_s
#ifndef __STDC_WANT_LIB_EXT1__
#define __STDC_WANT_LIB_EXT1__ 1
#endif
#include <string.h>

#include "openxr_enums.hpp"
#include "openxr_flags.hpp"
#include "openxr_version.hpp"
#include "openxr_time.hpp"
#include "openxr_atoms.hpp"
#include "openxr_bool.hpp"
#include "openxr_handles.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

namespace OPENXR_HPP_NAMESPACE {

namespace impl {

  class XR_MAY_ALIAS InputStructBase {
  protected:
    InputStructBase(StructureType type_, const void* next_ = nullptr) : type(type_), next(next_) {}

  public:
    StructureType type;
    const void* next;
  };
  static_assert(sizeof(::XrBaseInStructure) == sizeof(InputStructBase),
                "Original type and wrapper have different size!");

  class XR_MAY_ALIAS OutputStructBase {
  protected:
    OutputStructBase(StructureType type_, void* next_ = nullptr) : type(type_), next(next_) {}

  public:
    StructureType type;
    void* next;
  };
  static_assert(sizeof(::XrBaseOutStructure) == sizeof(OutputStructBase),
                "Original type and wrapper have different size!");
}  // namespace impl

/*!
 * @brief Wrapper for XrEventDataBuffer
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBuffer>
 *
 * @xrentity{XrEventDataBuffer}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataBuffer : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  EventDataBuffer(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_), varying{} {}

public:
  //! Default constructor - use this one.
  EventDataBuffer() : Parent(StructureType::EventDataBuffer), varying{} { (void)varying; }
  //! @brief "Put" function for assigning as null then getting the address of the raw pointer to
  //! pass as function output parameter.
  XrEventDataBuffer* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = {};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataBuffer*>(this);
  }

  //! Gets a pointer to the underlying raw XrEventDataBuffer type.
  XrEventDataBuffer* get() noexcept { return reinterpret_cast<XrEventDataBuffer*>(this); }

  //! Gets a pointer to the underlying raw XrEventDataBuffer type.
  XrEventDataBuffer const* get() const noexcept {
    return reinterpret_cast<XrEventDataBuffer const*>(this);
  }

private:
  uint8_t varying[4000];
};
static_assert(sizeof(::XrEventDataBuffer) == sizeof(EventDataBuffer),
              "Original type and wrapper have different size!");

/*!
 * @brief Free "put" function for clearing and getting the address of the raw XrEventDataBuffer in
 * an EventDataBuffer.
 * @relates EventDataBuffer
 * @ingroup utility_accessors
 */
OPENXR_HPP_INLINE XrEventDataBuffer* put(EventDataBuffer& v, bool clear = true) noexcept {
  return v.put(clear);
}

/*!
 * C++ projection of XrApiLayerProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApiLayerProperties>
 * @xrentity{XrApiLayerProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ApiLayerProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ApiLayerProperties(void* next_ = nullptr)

      : Parent(StructureType::APILayerProperties, next_) {}

  //! Default copy constructor
  ApiLayerProperties(const ApiLayerProperties& rhs) = default;
  //! Default copy assignment
  ApiLayerProperties& operator=(const ApiLayerProperties& rhs) = default;
  //! Copy construct from raw
  ApiLayerProperties(const XrApiLayerProperties& rhs) : ApiLayerProperties() { *put() = rhs; }
  //! Copy assign from raw
  ApiLayerProperties& operator=(const XrApiLayerProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApiLayerProperties&() const {
    return *reinterpret_cast<const XrApiLayerProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApiLayerProperties&() { return *reinterpret_cast<XrApiLayerProperties*>(this); }

  //! Accessor for this as the address of a raw XrApiLayerProperties
  XrApiLayerProperties const* get() const noexcept {
    return reinterpret_cast<XrApiLayerProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApiLayerProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrApiLayerProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ApiLayerProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrApiLayerProperties*>(this);
  }
  char layerName[XR_MAX_API_LAYER_NAME_SIZE];
  Version specVersion;
  uint32_t layerVersion;
  char description[XR_MAX_API_LAYER_DESCRIPTION_SIZE];
};
static_assert(sizeof(XrApiLayerProperties) == sizeof(ApiLayerProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApiLayerProperties pointer to const from a
 * ApiLayerProperties reference to const.
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerProperties const* get(ApiLayerProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ApiLayerProperties as the
 * address of a raw XrApiLayerProperties
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerProperties* put(ApiLayerProperties& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtensionProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtensionProperties>
 * @xrentity{XrExtensionProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ExtensionProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ExtensionProperties(void* next_ = nullptr)

      : Parent(StructureType::ExtensionProperties, next_) {}

  //! Default copy constructor
  ExtensionProperties(const ExtensionProperties& rhs) = default;
  //! Default copy assignment
  ExtensionProperties& operator=(const ExtensionProperties& rhs) = default;
  //! Copy construct from raw
  ExtensionProperties(const XrExtensionProperties& rhs) : ExtensionProperties() { *put() = rhs; }
  //! Copy assign from raw
  ExtensionProperties& operator=(const XrExtensionProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtensionProperties&() const {
    return *reinterpret_cast<const XrExtensionProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtensionProperties&() { return *reinterpret_cast<XrExtensionProperties*>(this); }

  //! Accessor for this as the address of a raw XrExtensionProperties
  XrExtensionProperties const* get() const noexcept {
    return reinterpret_cast<XrExtensionProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtensionProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrExtensionProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ExtensionProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrExtensionProperties*>(this);
  }
  char extensionName[XR_MAX_EXTENSION_NAME_SIZE];
  uint32_t extensionVersion;
};
static_assert(sizeof(XrExtensionProperties) == sizeof(ExtensionProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtensionProperties pointer to const from a
 * ExtensionProperties reference to const.
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtensionProperties const* get(ExtensionProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ExtensionProperties as the
 * address of a raw XrExtensionProperties
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtensionProperties* put(ExtensionProperties& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrApplicationInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApplicationInfo>
 * @xrentity{XrApplicationInfo}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ApplicationInfo {
public:
  //! Constructor initializing all members.
  ApplicationInfo(const char* applicationName_, uint32_t applicationVersion_,
                  const char* engineName_, uint32_t engineVersion_, const Version& apiVersion_)
      : applicationVersion{applicationVersion_},
        engineVersion{engineVersion_},
        apiVersion{apiVersion_} {
    if (nullptr != applicationName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(applicationName, XR_MAX_APPLICATION_NAME_SIZE, applicationName_,
                XR_MAX_APPLICATION_NAME_SIZE);
#else
      strncpy(applicationName, applicationName_, XR_MAX_APPLICATION_NAME_SIZE - 1);
      applicationName[XR_MAX_APPLICATION_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != engineName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(engineName, XR_MAX_ENGINE_NAME_SIZE, engineName_, XR_MAX_ENGINE_NAME_SIZE);
#else
      strncpy(engineName, engineName_, XR_MAX_ENGINE_NAME_SIZE - 1);
      engineName[XR_MAX_ENGINE_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ApplicationInfo()

      : applicationVersion{0}, engineVersion{0}, apiVersion{} {}

  //! Default copy constructor
  ApplicationInfo(const ApplicationInfo& rhs) = default;
  //! Default copy assignment
  ApplicationInfo& operator=(const ApplicationInfo& rhs) = default;
  //! Copy construct from raw
  ApplicationInfo(const XrApplicationInfo& rhs) : ApplicationInfo() { *put() = rhs; }
  //! Copy assign from raw
  ApplicationInfo& operator=(const XrApplicationInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApplicationInfo&() const {
    return *reinterpret_cast<const XrApplicationInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApplicationInfo&() { return *reinterpret_cast<XrApplicationInfo*>(this); }

  //! Accessor for this as the address of a raw XrApplicationInfo
  XrApplicationInfo const* get() const noexcept {
    return reinterpret_cast<XrApplicationInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApplicationInfo.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrApplicationInfo* put(bool clear = true) noexcept {
    if (clear) {
      *this = ApplicationInfo{};
    }
    return reinterpret_cast<XrApplicationInfo*>(this);
  }
  char applicationName[XR_MAX_APPLICATION_NAME_SIZE];
  uint32_t applicationVersion;
  char engineName[XR_MAX_ENGINE_NAME_SIZE];
  uint32_t engineVersion;
  Version apiVersion;
};
static_assert(sizeof(XrApplicationInfo) == sizeof(ApplicationInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApplicationInfo pointer to const from a ApplicationInfo
 * reference to const.
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApplicationInfo const* get(ApplicationInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ApplicationInfo as the
 * address of a raw XrApplicationInfo
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApplicationInfo* put(ApplicationInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInstanceCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfo>
 * @xrentity{XrInstanceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InstanceCreateInfo(const InstanceCreateFlags& createFlags_,
                     const ApplicationInfo& applicationInfo_, uint32_t enabledApiLayerCount_,
                     const char* const* enabledApiLayerNames_, uint32_t enabledExtensionCount_,
                     const char* const* enabledExtensionNames_, const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfo, next_),
        createFlags{createFlags_},
        applicationInfo{applicationInfo_},
        enabledApiLayerCount{enabledApiLayerCount_},
        enabledApiLayerNames{enabledApiLayerNames_},
        enabledExtensionCount{enabledExtensionCount_},
        enabledExtensionNames{enabledExtensionNames_} {}

  //! Default/empty constructor
  InstanceCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::InstanceCreateInfo, next_),
        createFlags{},
        applicationInfo{},
        enabledApiLayerCount{0},
        enabledApiLayerNames{nullptr},
        enabledExtensionCount{0},
        enabledExtensionNames{nullptr} {}

  //! Default copy constructor
  InstanceCreateInfo(const InstanceCreateInfo& rhs) = default;
  //! Default copy assignment
  InstanceCreateInfo& operator=(const InstanceCreateInfo& rhs) = default;
  //! Copy construct from raw
  InstanceCreateInfo(const XrInstanceCreateInfo& rhs) : InstanceCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  InstanceCreateInfo& operator=(const XrInstanceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceCreateInfo&() const {
    return *reinterpret_cast<const XrInstanceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceCreateInfo&() { return *reinterpret_cast<XrInstanceCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrInstanceCreateInfo
  XrInstanceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrInstanceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrInstanceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceCreateInfo*>(this);
  }
  InstanceCreateFlags createFlags;
  ApplicationInfo applicationInfo;
  uint32_t enabledApiLayerCount;
  const char* const* enabledApiLayerNames;
  uint32_t enabledExtensionCount;
  const char* const* enabledExtensionNames;
};
static_assert(sizeof(XrInstanceCreateInfo) == sizeof(InstanceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfo pointer to const from a
 * InstanceCreateInfo reference to const.
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfo const* get(InstanceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfo as the
 * address of a raw XrInstanceCreateInfo
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfo* put(InstanceCreateInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInstanceProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceProperties>
 * @xrentity{XrInstanceProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  InstanceProperties(void* next_ = nullptr)

      : Parent(StructureType::InstanceProperties, next_) {}

  //! Default copy constructor
  InstanceProperties(const InstanceProperties& rhs) = default;
  //! Default copy assignment
  InstanceProperties& operator=(const InstanceProperties& rhs) = default;
  //! Copy construct from raw
  InstanceProperties(const XrInstanceProperties& rhs) : InstanceProperties() { *put() = rhs; }
  //! Copy assign from raw
  InstanceProperties& operator=(const XrInstanceProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceProperties&() const {
    return *reinterpret_cast<const XrInstanceProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceProperties&() { return *reinterpret_cast<XrInstanceProperties*>(this); }

  //! Accessor for this as the address of a raw XrInstanceProperties
  XrInstanceProperties const* get() const noexcept {
    return reinterpret_cast<XrInstanceProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrInstanceProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceProperties*>(this);
  }
  Version runtimeVersion;
  char runtimeName[XR_MAX_RUNTIME_NAME_SIZE];
};
static_assert(sizeof(XrInstanceProperties) == sizeof(InstanceProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceProperties pointer to const from a
 * InstanceProperties reference to const.
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceProperties const* get(InstanceProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceProperties as the
 * address of a raw XrInstanceProperties
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceProperties* put(InstanceProperties& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemGetInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGetInfo>
 * @xrentity{XrSystemGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SystemGetInfo(const FormFactor& formFactor_, const void* next_ = nullptr)
      : Parent(StructureType::SystemGetInfo, next_), formFactor{formFactor_} {}

  //! Default/empty constructor
  SystemGetInfo(const void* next_ = nullptr)

      : Parent(StructureType::SystemGetInfo, next_), formFactor{} {}

  //! Default copy constructor
  SystemGetInfo(const SystemGetInfo& rhs) = default;
  //! Default copy assignment
  SystemGetInfo& operator=(const SystemGetInfo& rhs) = default;
  //! Copy construct from raw
  SystemGetInfo(const XrSystemGetInfo& rhs) : SystemGetInfo() { *put() = rhs; }
  //! Copy assign from raw
  SystemGetInfo& operator=(const XrSystemGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemGetInfo&() const {
    return *reinterpret_cast<const XrSystemGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemGetInfo&() { return *reinterpret_cast<XrSystemGetInfo*>(this); }

  //! Accessor for this as the address of a raw XrSystemGetInfo
  XrSystemGetInfo const* get() const noexcept {
    return reinterpret_cast<XrSystemGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSystemGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemGetInfo*>(this);
  }
  FormFactor formFactor;
};
static_assert(sizeof(XrSystemGetInfo) == sizeof(SystemGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemGetInfo pointer to const from a SystemGetInfo
 * reference to const.
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGetInfo const* get(SystemGetInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGetInfo as the address
 * of a raw XrSystemGetInfo
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGetInfo* put(SystemGetInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemGraphicsProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGraphicsProperties>
 * @xrentity{XrSystemGraphicsProperties}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SystemGraphicsProperties {
public:
  //! Constructor initializing all members.
  SystemGraphicsProperties(uint32_t maxSwapchainImageHeight_, uint32_t maxSwapchainImageWidth_,
                           uint32_t maxLayerCount_)
      : maxSwapchainImageHeight{maxSwapchainImageHeight_},
        maxSwapchainImageWidth{maxSwapchainImageWidth_},
        maxLayerCount{maxLayerCount_} {}

  //! Default/empty constructor
  SystemGraphicsProperties()

      : maxSwapchainImageHeight{0}, maxSwapchainImageWidth{0}, maxLayerCount{0} {}

  //! Default copy constructor
  SystemGraphicsProperties(const SystemGraphicsProperties& rhs) = default;
  //! Default copy assignment
  SystemGraphicsProperties& operator=(const SystemGraphicsProperties& rhs) = default;
  //! Copy construct from raw
  SystemGraphicsProperties(const XrSystemGraphicsProperties& rhs) : SystemGraphicsProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemGraphicsProperties& operator=(const XrSystemGraphicsProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemGraphicsProperties&() const {
    return *reinterpret_cast<const XrSystemGraphicsProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemGraphicsProperties&() {
    return *reinterpret_cast<XrSystemGraphicsProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemGraphicsProperties
  XrSystemGraphicsProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemGraphicsProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemGraphicsProperties.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSystemGraphicsProperties* put(bool clear = true) noexcept {
    if (clear) {
      *this = SystemGraphicsProperties{};
    }
    return reinterpret_cast<XrSystemGraphicsProperties*>(this);
  }
  uint32_t maxSwapchainImageHeight;
  uint32_t maxSwapchainImageWidth;
  uint32_t maxLayerCount;
};
static_assert(sizeof(XrSystemGraphicsProperties) == sizeof(SystemGraphicsProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemGraphicsProperties pointer to const from a
 * SystemGraphicsProperties reference to const.
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGraphicsProperties const* get(SystemGraphicsProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGraphicsProperties as
 * the address of a raw XrSystemGraphicsProperties
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGraphicsProperties* put(SystemGraphicsProperties& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemTrackingProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemTrackingProperties>
 * @xrentity{XrSystemTrackingProperties}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SystemTrackingProperties {
public:
  //! Constructor initializing all members.
  SystemTrackingProperties(const Bool32& orientationTracking_, const Bool32& positionTracking_)
      : orientationTracking{orientationTracking_}, positionTracking{positionTracking_} {}

  //! Default/empty constructor
  SystemTrackingProperties()

      : orientationTracking{false}, positionTracking{false} {}

  //! Default copy constructor
  SystemTrackingProperties(const SystemTrackingProperties& rhs) = default;
  //! Default copy assignment
  SystemTrackingProperties& operator=(const SystemTrackingProperties& rhs) = default;
  //! Copy construct from raw
  SystemTrackingProperties(const XrSystemTrackingProperties& rhs) : SystemTrackingProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemTrackingProperties& operator=(const XrSystemTrackingProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemTrackingProperties&() const {
    return *reinterpret_cast<const XrSystemTrackingProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemTrackingProperties&() {
    return *reinterpret_cast<XrSystemTrackingProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemTrackingProperties
  XrSystemTrackingProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemTrackingProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemTrackingProperties.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSystemTrackingProperties* put(bool clear = true) noexcept {
    if (clear) {
      *this = SystemTrackingProperties{};
    }
    return reinterpret_cast<XrSystemTrackingProperties*>(this);
  }
  Bool32 orientationTracking;
  Bool32 positionTracking;
};
static_assert(sizeof(XrSystemTrackingProperties) == sizeof(SystemTrackingProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemTrackingProperties pointer to const from a
 * SystemTrackingProperties reference to const.
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemTrackingProperties const* get(SystemTrackingProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemTrackingProperties as
 * the address of a raw XrSystemTrackingProperties
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemTrackingProperties* put(SystemTrackingProperties& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemProperties>
 * @xrentity{XrSystemProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemProperties(void* next_ = nullptr)

      : Parent(StructureType::SystemProperties, next_) {}

  //! Default copy constructor
  SystemProperties(const SystemProperties& rhs) = default;
  //! Default copy assignment
  SystemProperties& operator=(const SystemProperties& rhs) = default;
  //! Copy construct from raw
  SystemProperties(const XrSystemProperties& rhs) : SystemProperties() { *put() = rhs; }
  //! Copy assign from raw
  SystemProperties& operator=(const XrSystemProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemProperties&() const {
    return *reinterpret_cast<const XrSystemProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemProperties&() { return *reinterpret_cast<XrSystemProperties*>(this); }

  //! Accessor for this as the address of a raw XrSystemProperties
  XrSystemProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSystemProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemProperties*>(this);
  }
  SystemId systemId;
  uint32_t vendorId;
  char systemName[XR_MAX_SYSTEM_NAME_SIZE];
  SystemGraphicsProperties graphicsProperties;
  SystemTrackingProperties trackingProperties;
};
static_assert(sizeof(XrSystemProperties) == sizeof(SystemProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemProperties pointer to const from a
 * SystemProperties reference to const.
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemProperties const* get(SystemProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemProperties as the
 * address of a raw XrSystemProperties
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemProperties* put(SystemProperties& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfo>
 * @xrentity{XrSessionCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionCreateInfo(const SessionCreateFlags& createFlags_, const SystemId& systemId_,
                    const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfo, next_),
        createFlags{createFlags_},
        systemId{systemId_} {}

  //! Default/empty constructor
  SessionCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::SessionCreateInfo, next_), createFlags{}, systemId{} {}

  //! Default copy constructor
  SessionCreateInfo(const SessionCreateInfo& rhs) = default;
  //! Default copy assignment
  SessionCreateInfo& operator=(const SessionCreateInfo& rhs) = default;
  //! Copy construct from raw
  SessionCreateInfo(const XrSessionCreateInfo& rhs) : SessionCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SessionCreateInfo& operator=(const XrSessionCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionCreateInfo&() const {
    return *reinterpret_cast<const XrSessionCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionCreateInfo&() { return *reinterpret_cast<XrSessionCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSessionCreateInfo
  XrSessionCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSessionCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionCreateInfo*>(this);
  }
  SessionCreateFlags createFlags;
  SystemId systemId;
};
static_assert(sizeof(XrSessionCreateInfo) == sizeof(SessionCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionCreateInfo pointer to const from a
 * SessionCreateInfo reference to const.
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfo const* get(SessionCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfo as the
 * address of a raw XrSessionCreateInfo
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfo* put(SessionCreateInfo& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector3f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector3f>
 * @xrentity{XrVector3f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector3f {
public:
  //! Constructor initializing all members.
  Vector3f(float x_, float y_, float z_) : x{x_}, y{y_}, z{z_} {}

  //! Default/empty constructor
  Vector3f()

      : x{0.0f}, y{0.0f}, z{0.0f} {}

  //! Default copy constructor
  Vector3f(const Vector3f& rhs) = default;
  //! Default copy assignment
  Vector3f& operator=(const Vector3f& rhs) = default;
  //! Copy construct from raw
  Vector3f(const XrVector3f& rhs) : Vector3f() { *put() = rhs; }
  //! Copy assign from raw
  Vector3f& operator=(const XrVector3f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector3f&() const { return *reinterpret_cast<const XrVector3f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector3f&() { return *reinterpret_cast<XrVector3f*>(this); }

  //! Accessor for this as the address of a raw XrVector3f
  XrVector3f const* get() const noexcept { return reinterpret_cast<XrVector3f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector3f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector3f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector3f{};
    }
    return reinterpret_cast<XrVector3f*>(this);
  }
  float x;
  float y;
  float z;
};
static_assert(sizeof(XrVector3f) == sizeof(Vector3f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector3f pointer to const from a Vector3f reference to
 * const.
 * @relates Vector3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector3f const* get(Vector3f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector3f as the address of a
 * raw XrVector3f
 * @relates Vector3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector3f* put(Vector3f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceVelocity
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceVelocity>
 * @xrentity{XrSpaceVelocity}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceVelocity : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceVelocity(void* next_ = nullptr)

      : Parent(StructureType::SpaceVelocity, next_) {}

  //! Default copy constructor
  SpaceVelocity(const SpaceVelocity& rhs) = default;
  //! Default copy assignment
  SpaceVelocity& operator=(const SpaceVelocity& rhs) = default;
  //! Copy construct from raw
  SpaceVelocity(const XrSpaceVelocity& rhs) : SpaceVelocity() { *put() = rhs; }
  //! Copy assign from raw
  SpaceVelocity& operator=(const XrSpaceVelocity& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceVelocity&() const {
    return *reinterpret_cast<const XrSpaceVelocity*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceVelocity&() { return *reinterpret_cast<XrSpaceVelocity*>(this); }

  //! Accessor for this as the address of a raw XrSpaceVelocity
  XrSpaceVelocity const* get() const noexcept {
    return reinterpret_cast<XrSpaceVelocity const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceVelocity.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceVelocity* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceVelocity{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceVelocity*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrSpaceVelocity) == sizeof(SpaceVelocity),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceVelocity pointer to const from a SpaceVelocity
 * reference to const.
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocity const* get(SpaceVelocity const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceVelocity as the address
 * of a raw XrSpaceVelocity
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocity* put(SpaceVelocity& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrQuaternionf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrQuaternionf>
 * @xrentity{XrQuaternionf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Quaternionf {
public:
  //! Constructor initializing all members.
  Quaternionf(float x_, float y_, float z_, float w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Quaternionf()

      : x{0.0f}, y{0.0f}, z{0.0f}, w{1.0f} {}

  //! Default copy constructor
  Quaternionf(const Quaternionf& rhs) = default;
  //! Default copy assignment
  Quaternionf& operator=(const Quaternionf& rhs) = default;
  //! Copy construct from raw
  Quaternionf(const XrQuaternionf& rhs) : Quaternionf() { *put() = rhs; }
  //! Copy assign from raw
  Quaternionf& operator=(const XrQuaternionf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrQuaternionf&() const { return *reinterpret_cast<const XrQuaternionf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrQuaternionf&() { return *reinterpret_cast<XrQuaternionf*>(this); }

  //! Accessor for this as the address of a raw XrQuaternionf
  XrQuaternionf const* get() const noexcept { return reinterpret_cast<XrQuaternionf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrQuaternionf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrQuaternionf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Quaternionf{};
    }
    return reinterpret_cast<XrQuaternionf*>(this);
  }
  float x;
  float y;
  float z;
  float w;
};
static_assert(sizeof(XrQuaternionf) == sizeof(Quaternionf),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrQuaternionf pointer to const from a Quaternionf
 * reference to const.
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQuaternionf const* get(Quaternionf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Quaternionf as the address of
 * a raw XrQuaternionf
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQuaternionf* put(Quaternionf& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrPosef
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPosef>
 * @xrentity{XrPosef}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Posef {
public:
  //! Constructor initializing all members.
  Posef(const Quaternionf& orientation_, const Vector3f& position_)
      : orientation{orientation_}, position{position_} {}

  //! Default/empty constructor
  Posef()

      : orientation{}, position{} {}

  //! Default copy constructor
  Posef(const Posef& rhs) = default;
  //! Default copy assignment
  Posef& operator=(const Posef& rhs) = default;
  //! Copy construct from raw
  Posef(const XrPosef& rhs) : Posef() { *put() = rhs; }
  //! Copy assign from raw
  Posef& operator=(const XrPosef& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPosef&() const { return *reinterpret_cast<const XrPosef*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPosef&() { return *reinterpret_cast<XrPosef*>(this); }

  //! Accessor for this as the address of a raw XrPosef
  XrPosef const* get() const noexcept { return reinterpret_cast<XrPosef const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrPosef.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrPosef* put(bool clear = true) noexcept {
    if (clear) {
      *this = Posef{};
    }
    return reinterpret_cast<XrPosef*>(this);
  }
  Quaternionf orientation;
  Vector3f position;
};
static_assert(sizeof(XrPosef) == sizeof(Posef), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPosef pointer to const from a Posef reference to const.
 * @relates Posef
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPosef const* get(Posef const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Posef as the address of a raw
 * XrPosef
 * @relates Posef
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPosef* put(Posef& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrReferenceSpaceCreateInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceCreateInfo>
 * @xrentity{XrReferenceSpaceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ReferenceSpaceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ReferenceSpaceCreateInfo(const ReferenceSpaceType& referenceSpaceType_,
                           const Posef& poseInReferenceSpace_, const void* next_ = nullptr)
      : Parent(StructureType::ReferenceSpaceCreateInfo, next_),
        referenceSpaceType{referenceSpaceType_},
        poseInReferenceSpace{poseInReferenceSpace_} {}

  //! Default/empty constructor
  ReferenceSpaceCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ReferenceSpaceCreateInfo, next_),
        referenceSpaceType{},
        poseInReferenceSpace{} {}

  //! Default copy constructor
  ReferenceSpaceCreateInfo(const ReferenceSpaceCreateInfo& rhs) = default;
  //! Default copy assignment
  ReferenceSpaceCreateInfo& operator=(const ReferenceSpaceCreateInfo& rhs) = default;
  //! Copy construct from raw
  ReferenceSpaceCreateInfo(const XrReferenceSpaceCreateInfo& rhs) : ReferenceSpaceCreateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ReferenceSpaceCreateInfo& operator=(const XrReferenceSpaceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrReferenceSpaceCreateInfo&() const {
    return *reinterpret_cast<const XrReferenceSpaceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrReferenceSpaceCreateInfo&() {
    return *reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrReferenceSpaceCreateInfo
  XrReferenceSpaceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrReferenceSpaceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrReferenceSpaceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrReferenceSpaceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ReferenceSpaceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
  }
  ReferenceSpaceType referenceSpaceType;
  Posef poseInReferenceSpace;
};
static_assert(sizeof(XrReferenceSpaceCreateInfo) == sizeof(ReferenceSpaceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrReferenceSpaceCreateInfo pointer to const from a
 * ReferenceSpaceCreateInfo reference to const.
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo const* get(ReferenceSpaceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ReferenceSpaceCreateInfo as
 * the address of a raw XrReferenceSpaceCreateInfo
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo* put(ReferenceSpaceCreateInfo& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Df>
 * @xrentity{XrExtent2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent2Df {
public:
  //! Constructor initializing all members.
  Extent2Df(float width_, float height_) : width{width_}, height{height_} {}

  //! Default/empty constructor
  Extent2Df()

      : width{0.0f}, height{0.0f} {}

  //! Default copy constructor
  Extent2Df(const Extent2Df& rhs) = default;
  //! Default copy assignment
  Extent2Df& operator=(const Extent2Df& rhs) = default;
  //! Copy construct from raw
  Extent2Df(const XrExtent2Df& rhs) : Extent2Df() { *put() = rhs; }
  //! Copy assign from raw
  Extent2Df& operator=(const XrExtent2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent2Df&() const { return *reinterpret_cast<const XrExtent2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent2Df&() { return *reinterpret_cast<XrExtent2Df*>(this); }

  //! Accessor for this as the address of a raw XrExtent2Df
  XrExtent2Df const* get() const noexcept { return reinterpret_cast<XrExtent2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent2Df{};
    }
    return reinterpret_cast<XrExtent2Df*>(this);
  }
  float width;
  float height;
};
static_assert(sizeof(XrExtent2Df) == sizeof(Extent2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent2Df pointer to const from a Extent2Df reference to
 * const.
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Df const* get(Extent2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Df as the address of a
 * raw XrExtent2Df
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Df* put(Extent2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionSpaceCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSpaceCreateInfo>
 * @xrentity{XrActionSpaceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionSpaceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionSpaceCreateInfo(const Action& action_, const Path& subactionPath_,
                        const Posef& poseInActionSpace_, const void* next_ = nullptr)
      : Parent(StructureType::ActionSpaceCreateInfo, next_),
        action{action_},
        subactionPath{subactionPath_},
        poseInActionSpace{poseInActionSpace_} {}

  //! Default/empty constructor
  ActionSpaceCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionSpaceCreateInfo, next_),
        action{},
        subactionPath{},
        poseInActionSpace{} {}

  //! Default copy constructor
  ActionSpaceCreateInfo(const ActionSpaceCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionSpaceCreateInfo& operator=(const ActionSpaceCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionSpaceCreateInfo(const XrActionSpaceCreateInfo& rhs) : ActionSpaceCreateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActionSpaceCreateInfo& operator=(const XrActionSpaceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSpaceCreateInfo&() const {
    return *reinterpret_cast<const XrActionSpaceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSpaceCreateInfo&() { return *reinterpret_cast<XrActionSpaceCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionSpaceCreateInfo
  XrActionSpaceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionSpaceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSpaceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionSpaceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionSpaceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionSpaceCreateInfo*>(this);
  }
  Action action;
  Path subactionPath;
  Posef poseInActionSpace;
};
static_assert(sizeof(XrActionSpaceCreateInfo) == sizeof(ActionSpaceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSpaceCreateInfo pointer to const from a
 * ActionSpaceCreateInfo reference to const.
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSpaceCreateInfo const* get(ActionSpaceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSpaceCreateInfo as the
 * address of a raw XrActionSpaceCreateInfo
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSpaceCreateInfo* put(ActionSpaceCreateInfo& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceLocation
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceLocation>
 * @xrentity{XrSpaceLocation}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceLocation : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceLocation(void* next_ = nullptr)

      : Parent(StructureType::SpaceLocation, next_) {}

  //! Default copy constructor
  SpaceLocation(const SpaceLocation& rhs) = default;
  //! Default copy assignment
  SpaceLocation& operator=(const SpaceLocation& rhs) = default;
  //! Copy construct from raw
  SpaceLocation(const XrSpaceLocation& rhs) : SpaceLocation() { *put() = rhs; }
  //! Copy assign from raw
  SpaceLocation& operator=(const XrSpaceLocation& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceLocation&() const {
    return *reinterpret_cast<const XrSpaceLocation*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceLocation&() { return *reinterpret_cast<XrSpaceLocation*>(this); }

  //! Accessor for this as the address of a raw XrSpaceLocation
  XrSpaceLocation const* get() const noexcept {
    return reinterpret_cast<XrSpaceLocation const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceLocation.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceLocation* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceLocation{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceLocation*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrSpaceLocation) == sizeof(SpaceLocation),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceLocation pointer to const from a SpaceLocation
 * reference to const.
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocation const* get(SpaceLocation const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceLocation as the address
 * of a raw XrSpaceLocation
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocation* put(SpaceLocation& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewConfigurationProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationProperties>
 * @xrentity{XrViewConfigurationProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationProperties(void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationProperties, next_) {}

  //! Default copy constructor
  ViewConfigurationProperties(const ViewConfigurationProperties& rhs) = default;
  //! Default copy assignment
  ViewConfigurationProperties& operator=(const ViewConfigurationProperties& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationProperties(const XrViewConfigurationProperties& rhs)
      : ViewConfigurationProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationProperties& operator=(const XrViewConfigurationProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationProperties&() const {
    return *reinterpret_cast<const XrViewConfigurationProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationProperties&() {
    return *reinterpret_cast<XrViewConfigurationProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationProperties
  XrViewConfigurationProperties const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationProperties*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Bool32 fovMutable;
};
static_assert(sizeof(XrViewConfigurationProperties) == sizeof(ViewConfigurationProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationProperties pointer to const from a
 * ViewConfigurationProperties reference to const.
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationProperties const* get(
    ViewConfigurationProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationProperties
 * as the address of a raw XrViewConfigurationProperties
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationProperties* put(ViewConfigurationProperties& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewConfigurationView
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationView>
 * @xrentity{XrViewConfigurationView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationView : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationView(void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationView, next_) {}

  //! Default copy constructor
  ViewConfigurationView(const ViewConfigurationView& rhs) = default;
  //! Default copy assignment
  ViewConfigurationView& operator=(const ViewConfigurationView& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationView(const XrViewConfigurationView& rhs) : ViewConfigurationView() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationView& operator=(const XrViewConfigurationView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationView&() const {
    return *reinterpret_cast<const XrViewConfigurationView*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationView&() { return *reinterpret_cast<XrViewConfigurationView*>(this); }

  //! Accessor for this as the address of a raw XrViewConfigurationView
  XrViewConfigurationView const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationView const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationView{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationView*>(this);
  }
  uint32_t recommendedImageRectWidth;
  uint32_t maxImageRectWidth;
  uint32_t recommendedImageRectHeight;
  uint32_t maxImageRectHeight;
  uint32_t recommendedSwapchainSampleCount;
  uint32_t maxSwapchainSampleCount;
};
static_assert(sizeof(XrViewConfigurationView) == sizeof(ViewConfigurationView),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationView pointer to const from a
 * ViewConfigurationView reference to const.
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationView const* get(ViewConfigurationView const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationView as the
 * address of a raw XrViewConfigurationView
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationView* put(ViewConfigurationView& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfo>
 * @xrentity{XrSwapchainCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainCreateInfo(const SwapchainCreateFlags& createFlags_,
                      const SwapchainUsageFlags& usageFlags_, int64_t format_,
                      uint32_t sampleCount_, uint32_t width_, uint32_t height_, uint32_t faceCount_,
                      uint32_t arraySize_, uint32_t mipCount_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainCreateInfo, next_),
        createFlags{createFlags_},
        usageFlags{usageFlags_},
        format{format_},
        sampleCount{sampleCount_},
        width{width_},
        height{height_},
        faceCount{faceCount_},
        arraySize{arraySize_},
        mipCount{mipCount_} {}

  //! Default/empty constructor
  SwapchainCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainCreateInfo, next_),
        createFlags{},
        usageFlags{},
        format{0},
        sampleCount{0},
        width{0},
        height{0},
        faceCount{0},
        arraySize{0},
        mipCount{0} {}

  //! Default copy constructor
  SwapchainCreateInfo(const SwapchainCreateInfo& rhs) = default;
  //! Default copy assignment
  SwapchainCreateInfo& operator=(const SwapchainCreateInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainCreateInfo(const XrSwapchainCreateInfo& rhs) : SwapchainCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SwapchainCreateInfo& operator=(const XrSwapchainCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainCreateInfo&() const {
    return *reinterpret_cast<const XrSwapchainCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainCreateInfo&() { return *reinterpret_cast<XrSwapchainCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSwapchainCreateInfo
  XrSwapchainCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainCreateInfo*>(this);
  }
  SwapchainCreateFlags createFlags;
  SwapchainUsageFlags usageFlags;
  int64_t format;
  uint32_t sampleCount;
  uint32_t width;
  uint32_t height;
  uint32_t faceCount;
  uint32_t arraySize;
  uint32_t mipCount;
};
static_assert(sizeof(XrSwapchainCreateInfo) == sizeof(SwapchainCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfo pointer to const from a
 * SwapchainCreateInfo reference to const.
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfo const* get(SwapchainCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainCreateInfo as the
 * address of a raw XrSwapchainCreateInfo
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfo* put(SwapchainCreateInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageBaseHeader
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageBaseHeader>
 * @xrentity{XrSwapchainImageBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SwapchainImageBaseHeader : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SwapchainImageBaseHeader(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageBaseHeader&() const {
    return *reinterpret_cast<const XrSwapchainImageBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageBaseHeader&() {
    return *reinterpret_cast<XrSwapchainImageBaseHeader*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageBaseHeader
  XrSwapchainImageBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageBaseHeader) == sizeof(SwapchainImageBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageBaseHeader pointer to const from a
 * SwapchainImageBaseHeader reference to const.
 * @relates SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get(SwapchainImageBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrSwapchainImageAcquireInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageAcquireInfo>
 * @xrentity{XrSwapchainImageAcquireInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageAcquireInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SwapchainImageAcquireInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageAcquireInfo, next_) {}

  //! Default copy constructor
  SwapchainImageAcquireInfo(const SwapchainImageAcquireInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageAcquireInfo& operator=(const SwapchainImageAcquireInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageAcquireInfo(const XrSwapchainImageAcquireInfo& rhs) : SwapchainImageAcquireInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageAcquireInfo& operator=(const XrSwapchainImageAcquireInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageAcquireInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageAcquireInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageAcquireInfo&() {
    return *reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageAcquireInfo
  XrSwapchainImageAcquireInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageAcquireInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageAcquireInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageAcquireInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageAcquireInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageAcquireInfo) == sizeof(SwapchainImageAcquireInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageAcquireInfo pointer to const from a
 * SwapchainImageAcquireInfo reference to const.
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo const* get(
    SwapchainImageAcquireInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageAcquireInfo as
 * the address of a raw XrSwapchainImageAcquireInfo
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo* put(SwapchainImageAcquireInfo& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageWaitInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageWaitInfo>
 * @xrentity{XrSwapchainImageWaitInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageWaitInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainImageWaitInfo(const Duration& timeout_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageWaitInfo, next_), timeout{timeout_} {}

  //! Default/empty constructor
  SwapchainImageWaitInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageWaitInfo, next_), timeout{} {}

  //! Default copy constructor
  SwapchainImageWaitInfo(const SwapchainImageWaitInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageWaitInfo& operator=(const SwapchainImageWaitInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageWaitInfo(const XrSwapchainImageWaitInfo& rhs) : SwapchainImageWaitInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageWaitInfo& operator=(const XrSwapchainImageWaitInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageWaitInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageWaitInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageWaitInfo&() {
    return *reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageWaitInfo
  XrSwapchainImageWaitInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageWaitInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageWaitInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageWaitInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageWaitInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
  }
  Duration timeout;
};
static_assert(sizeof(XrSwapchainImageWaitInfo) == sizeof(SwapchainImageWaitInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageWaitInfo pointer to const from a
 * SwapchainImageWaitInfo reference to const.
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo const* get(SwapchainImageWaitInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageWaitInfo as the
 * address of a raw XrSwapchainImageWaitInfo
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo* put(SwapchainImageWaitInfo& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageReleaseInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageReleaseInfo>
 * @xrentity{XrSwapchainImageReleaseInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageReleaseInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SwapchainImageReleaseInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageReleaseInfo, next_) {}

  //! Default copy constructor
  SwapchainImageReleaseInfo(const SwapchainImageReleaseInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageReleaseInfo& operator=(const SwapchainImageReleaseInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageReleaseInfo(const XrSwapchainImageReleaseInfo& rhs) : SwapchainImageReleaseInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageReleaseInfo& operator=(const XrSwapchainImageReleaseInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageReleaseInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageReleaseInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageReleaseInfo&() {
    return *reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageReleaseInfo
  XrSwapchainImageReleaseInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageReleaseInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageReleaseInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageReleaseInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageReleaseInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageReleaseInfo) == sizeof(SwapchainImageReleaseInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageReleaseInfo pointer to const from a
 * SwapchainImageReleaseInfo reference to const.
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo const* get(
    SwapchainImageReleaseInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageReleaseInfo as
 * the address of a raw XrSwapchainImageReleaseInfo
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo* put(SwapchainImageReleaseInfo& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionBeginInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionBeginInfo>
 * @xrentity{XrSessionBeginInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionBeginInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionBeginInfo(const ViewConfigurationType& primaryViewConfigurationType_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SessionBeginInfo, next_),
        primaryViewConfigurationType{primaryViewConfigurationType_} {}

  //! Default/empty constructor
  SessionBeginInfo(const void* next_ = nullptr)

      : Parent(StructureType::SessionBeginInfo, next_), primaryViewConfigurationType{} {}

  //! Default copy constructor
  SessionBeginInfo(const SessionBeginInfo& rhs) = default;
  //! Default copy assignment
  SessionBeginInfo& operator=(const SessionBeginInfo& rhs) = default;
  //! Copy construct from raw
  SessionBeginInfo(const XrSessionBeginInfo& rhs) : SessionBeginInfo() { *put() = rhs; }
  //! Copy assign from raw
  SessionBeginInfo& operator=(const XrSessionBeginInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionBeginInfo&() const {
    return *reinterpret_cast<const XrSessionBeginInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionBeginInfo&() { return *reinterpret_cast<XrSessionBeginInfo*>(this); }

  //! Accessor for this as the address of a raw XrSessionBeginInfo
  XrSessionBeginInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionBeginInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSessionBeginInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionBeginInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionBeginInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionBeginInfo*>(this);
  }
  ViewConfigurationType primaryViewConfigurationType;
};
static_assert(sizeof(XrSessionBeginInfo) == sizeof(SessionBeginInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionBeginInfo pointer to const from a
 * SessionBeginInfo reference to const.
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionBeginInfo const* get(SessionBeginInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionBeginInfo as the
 * address of a raw XrSessionBeginInfo
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionBeginInfo* put(SessionBeginInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameWaitInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameWaitInfo>
 * @xrentity{XrFrameWaitInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameWaitInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FrameWaitInfo(const void* next_ = nullptr)

      : Parent(StructureType::FrameWaitInfo, next_) {}

  //! Default copy constructor
  FrameWaitInfo(const FrameWaitInfo& rhs) = default;
  //! Default copy assignment
  FrameWaitInfo& operator=(const FrameWaitInfo& rhs) = default;
  //! Copy construct from raw
  FrameWaitInfo(const XrFrameWaitInfo& rhs) : FrameWaitInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameWaitInfo& operator=(const XrFrameWaitInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameWaitInfo&() const {
    return *reinterpret_cast<const XrFrameWaitInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameWaitInfo&() { return *reinterpret_cast<XrFrameWaitInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameWaitInfo
  XrFrameWaitInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameWaitInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameWaitInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameWaitInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameWaitInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameWaitInfo*>(this);
  }
};
static_assert(sizeof(XrFrameWaitInfo) == sizeof(FrameWaitInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameWaitInfo pointer to const from a FrameWaitInfo
 * reference to const.
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameWaitInfo const* get(FrameWaitInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameWaitInfo as the address
 * of a raw XrFrameWaitInfo
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameWaitInfo* put(FrameWaitInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameState>
 * @xrentity{XrFrameState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FrameState(void* next_ = nullptr)

      : Parent(StructureType::FrameState, next_) {}

  //! Default copy constructor
  FrameState(const FrameState& rhs) = default;
  //! Default copy assignment
  FrameState& operator=(const FrameState& rhs) = default;
  //! Copy construct from raw
  FrameState(const XrFrameState& rhs) : FrameState() { *put() = rhs; }
  //! Copy assign from raw
  FrameState& operator=(const XrFrameState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameState&() const { return *reinterpret_cast<const XrFrameState*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameState&() { return *reinterpret_cast<XrFrameState*>(this); }

  //! Accessor for this as the address of a raw XrFrameState
  XrFrameState const* get() const noexcept { return reinterpret_cast<XrFrameState const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameState{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameState*>(this);
  }
  Time predictedDisplayTime;
  Duration predictedDisplayPeriod;
  Bool32 shouldRender;
};
static_assert(sizeof(XrFrameState) == sizeof(FrameState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameState pointer to const from a FrameState reference
 * to const.
 * @relates FrameState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameState const* get(FrameState const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameState as the address of
 * a raw XrFrameState
 * @relates FrameState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameState* put(FrameState& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameBeginInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameBeginInfo>
 * @xrentity{XrFrameBeginInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameBeginInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FrameBeginInfo(const void* next_ = nullptr)

      : Parent(StructureType::FrameBeginInfo, next_) {}

  //! Default copy constructor
  FrameBeginInfo(const FrameBeginInfo& rhs) = default;
  //! Default copy assignment
  FrameBeginInfo& operator=(const FrameBeginInfo& rhs) = default;
  //! Copy construct from raw
  FrameBeginInfo(const XrFrameBeginInfo& rhs) : FrameBeginInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameBeginInfo& operator=(const XrFrameBeginInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameBeginInfo&() const {
    return *reinterpret_cast<const XrFrameBeginInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameBeginInfo&() { return *reinterpret_cast<XrFrameBeginInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameBeginInfo
  XrFrameBeginInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameBeginInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameBeginInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameBeginInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameBeginInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameBeginInfo*>(this);
  }
};
static_assert(sizeof(XrFrameBeginInfo) == sizeof(FrameBeginInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameBeginInfo pointer to const from a FrameBeginInfo
 * reference to const.
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameBeginInfo const* get(FrameBeginInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameBeginInfo as the address
 * of a raw XrFrameBeginInfo
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameBeginInfo* put(FrameBeginInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerBaseHeader
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerBaseHeader>
 * @xrentity{XrCompositionLayerBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS CompositionLayerBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  CompositionLayerBaseHeader(StructureType type_, const CompositionLayerFlags& layerFlags_,
                             const Space& space_, const void* next_ = nullptr)
      : Parent(type_, next_), layerFlags{layerFlags_}, space{space_} {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerBaseHeader&() const {
    return *reinterpret_cast<const XrCompositionLayerBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerBaseHeader&() {
    return *reinterpret_cast<XrCompositionLayerBaseHeader*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerBaseHeader
  XrCompositionLayerBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }

  CompositionLayerFlags layerFlags;
  Space space;
};
static_assert(sizeof(XrCompositionLayerBaseHeader) == sizeof(CompositionLayerBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerBaseHeader pointer to const from a
 * CompositionLayerBaseHeader reference to const.
 * @relates CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get(
    CompositionLayerBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrFrameEndInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameEndInfo>
 * @xrentity{XrFrameEndInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameEndInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FrameEndInfo(const Time& displayTime_, const EnvironmentBlendMode& environmentBlendMode_,
               uint32_t layerCount_, const CompositionLayerBaseHeader* const* layers_,
               const void* next_ = nullptr)
      : Parent(StructureType::FrameEndInfo, next_),
        displayTime{displayTime_},
        environmentBlendMode{environmentBlendMode_},
        layerCount{layerCount_},
        layers{layers_} {}

  //! Default/empty constructor
  FrameEndInfo(const void* next_ = nullptr)

      : Parent(StructureType::FrameEndInfo, next_),
        displayTime{},
        environmentBlendMode{},
        layerCount{0},
        layers{nullptr} {}

  //! Default copy constructor
  FrameEndInfo(const FrameEndInfo& rhs) = default;
  //! Default copy assignment
  FrameEndInfo& operator=(const FrameEndInfo& rhs) = default;
  //! Copy construct from raw
  FrameEndInfo(const XrFrameEndInfo& rhs) : FrameEndInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameEndInfo& operator=(const XrFrameEndInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameEndInfo&() const { return *reinterpret_cast<const XrFrameEndInfo*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameEndInfo&() { return *reinterpret_cast<XrFrameEndInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameEndInfo
  XrFrameEndInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameEndInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameEndInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameEndInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameEndInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameEndInfo*>(this);
  }
  Time displayTime;
  EnvironmentBlendMode environmentBlendMode;
  uint32_t layerCount;
  const CompositionLayerBaseHeader* const* layers;
};
static_assert(sizeof(XrFrameEndInfo) == sizeof(FrameEndInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameEndInfo pointer to const from a FrameEndInfo
 * reference to const.
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfo const* get(FrameEndInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameEndInfo as the address
 * of a raw XrFrameEndInfo
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfo* put(FrameEndInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewLocateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateInfo>
 * @xrentity{XrViewLocateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewLocateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewLocateInfo(const ViewConfigurationType& viewConfigurationType_, const Time& displayTime_,
                 const Space& space_, const void* next_ = nullptr)
      : Parent(StructureType::ViewLocateInfo, next_),
        viewConfigurationType{viewConfigurationType_},
        displayTime{displayTime_},
        space{space_} {}

  //! Default/empty constructor
  ViewLocateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ViewLocateInfo, next_),
        viewConfigurationType{},
        displayTime{},
        space{} {}

  //! Default copy constructor
  ViewLocateInfo(const ViewLocateInfo& rhs) = default;
  //! Default copy assignment
  ViewLocateInfo& operator=(const ViewLocateInfo& rhs) = default;
  //! Copy construct from raw
  ViewLocateInfo(const XrViewLocateInfo& rhs) : ViewLocateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ViewLocateInfo& operator=(const XrViewLocateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewLocateInfo&() const {
    return *reinterpret_cast<const XrViewLocateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewLocateInfo&() { return *reinterpret_cast<XrViewLocateInfo*>(this); }

  //! Accessor for this as the address of a raw XrViewLocateInfo
  XrViewLocateInfo const* get() const noexcept {
    return reinterpret_cast<XrViewLocateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewLocateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewLocateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewLocateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewLocateInfo*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Time displayTime;
  Space space;
};
static_assert(sizeof(XrViewLocateInfo) == sizeof(ViewLocateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewLocateInfo pointer to const from a ViewLocateInfo
 * reference to const.
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateInfo const* get(ViewLocateInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewLocateInfo as the address
 * of a raw XrViewLocateInfo
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateInfo* put(ViewLocateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewState>
 * @xrentity{XrViewState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewState(void* next_ = nullptr)

      : Parent(StructureType::ViewState, next_) {}

  //! Default copy constructor
  ViewState(const ViewState& rhs) = default;
  //! Default copy assignment
  ViewState& operator=(const ViewState& rhs) = default;
  //! Copy construct from raw
  ViewState(const XrViewState& rhs) : ViewState() { *put() = rhs; }
  //! Copy assign from raw
  ViewState& operator=(const XrViewState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewState&() const { return *reinterpret_cast<const XrViewState*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewState&() { return *reinterpret_cast<XrViewState*>(this); }

  //! Accessor for this as the address of a raw XrViewState
  XrViewState const* get() const noexcept { return reinterpret_cast<XrViewState const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewState{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewState*>(this);
  }
  ViewStateFlags viewStateFlags;
};
static_assert(sizeof(XrViewState) == sizeof(ViewState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewState pointer to const from a ViewState reference to
 * const.
 * @relates ViewState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewState const* get(ViewState const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewState as the address of a
 * raw XrViewState
 * @relates ViewState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewState* put(ViewState& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFovf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFovf>
 * @xrentity{XrFovf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Fovf {
public:
  //! Constructor initializing all members.
  Fovf(float angleLeft_, float angleRight_, float angleUp_, float angleDown_)
      : angleLeft{angleLeft_}, angleRight{angleRight_}, angleUp{angleUp_}, angleDown{angleDown_} {}

  //! Default/empty constructor
  Fovf()

      : angleLeft{0.0f}, angleRight{0.0f}, angleUp{0.0f}, angleDown{0.0f} {}

  //! Default copy constructor
  Fovf(const Fovf& rhs) = default;
  //! Default copy assignment
  Fovf& operator=(const Fovf& rhs) = default;
  //! Copy construct from raw
  Fovf(const XrFovf& rhs) : Fovf() { *put() = rhs; }
  //! Copy assign from raw
  Fovf& operator=(const XrFovf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFovf&() const { return *reinterpret_cast<const XrFovf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFovf&() { return *reinterpret_cast<XrFovf*>(this); }

  //! Accessor for this as the address of a raw XrFovf
  XrFovf const* get() const noexcept { return reinterpret_cast<XrFovf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFovf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrFovf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Fovf{};
    }
    return reinterpret_cast<XrFovf*>(this);
  }
  float angleLeft;
  float angleRight;
  float angleUp;
  float angleDown;
};
static_assert(sizeof(XrFovf) == sizeof(Fovf), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFovf pointer to const from a Fovf reference to const.
 * @relates Fovf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFovf const* get(Fovf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Fovf as the address of a raw
 * XrFovf
 * @relates Fovf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFovf* put(Fovf& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrView
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrView>
 * @xrentity{XrView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS View : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  View(void* next_ = nullptr)

      : Parent(StructureType::View, next_) {}

  //! Default copy constructor
  View(const View& rhs) = default;
  //! Default copy assignment
  View& operator=(const View& rhs) = default;
  //! Copy construct from raw
  View(const XrView& rhs) : View() { *put() = rhs; }
  //! Copy assign from raw
  View& operator=(const XrView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrView&() const { return *reinterpret_cast<const XrView*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrView&() { return *reinterpret_cast<XrView*>(this); }

  //! Accessor for this as the address of a raw XrView
  XrView const* get() const noexcept { return reinterpret_cast<XrView const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = View{};
      next = oldNext;
    }
    return reinterpret_cast<XrView*>(this);
  }
  Posef pose;
  Fovf fov;
};
static_assert(sizeof(XrView) == sizeof(View), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrView pointer to const from a View reference to const.
 * @relates View
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrView const* get(View const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing View as the address of a raw
 * XrView
 * @relates View
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrView* put(View& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrActionSetCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSetCreateInfo>
 * @xrentity{XrActionSetCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionSetCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionSetCreateInfo(const char* actionSetName_, const char* localizedActionSetName_,
                      uint32_t priority_, const void* next_ = nullptr)
      : Parent(StructureType::ActionSetCreateInfo, next_), priority{priority_} {
    if (nullptr != actionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(actionSetName, XR_MAX_ACTION_SET_NAME_SIZE, actionSetName_,
                XR_MAX_ACTION_SET_NAME_SIZE);
#else
      strncpy(actionSetName, actionSetName_, XR_MAX_ACTION_SET_NAME_SIZE - 1);
      actionSetName[XR_MAX_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != localizedActionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(localizedActionSetName, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE,
                localizedActionSetName_, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE);
#else
      strncpy(localizedActionSetName, localizedActionSetName_,
              XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1);
      localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ActionSetCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionSetCreateInfo, next_), priority{0} {}

  //! Default copy constructor
  ActionSetCreateInfo(const ActionSetCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionSetCreateInfo& operator=(const ActionSetCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionSetCreateInfo(const XrActionSetCreateInfo& rhs) : ActionSetCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionSetCreateInfo& operator=(const XrActionSetCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSetCreateInfo&() const {
    return *reinterpret_cast<const XrActionSetCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSetCreateInfo&() { return *reinterpret_cast<XrActionSetCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionSetCreateInfo
  XrActionSetCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionSetCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSetCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionSetCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionSetCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionSetCreateInfo*>(this);
  }
  char actionSetName[XR_MAX_ACTION_SET_NAME_SIZE];
  char localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE];
  uint32_t priority;
};
static_assert(sizeof(XrActionSetCreateInfo) == sizeof(ActionSetCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSetCreateInfo pointer to const from a
 * ActionSetCreateInfo reference to const.
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSetCreateInfo const* get(ActionSetCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSetCreateInfo as the
 * address of a raw XrActionSetCreateInfo
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSetCreateInfo* put(ActionSetCreateInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionCreateInfo>
 * @xrentity{XrActionCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionCreateInfo(const char* actionName_, const ActionType& actionType_,
                   uint32_t countSubactionPaths_, const Path* subactionPaths_,
                   const char* localizedActionName_, const void* next_ = nullptr)
      : Parent(StructureType::ActionCreateInfo, next_),
        actionType{actionType_},
        countSubactionPaths{countSubactionPaths_},
        subactionPaths{subactionPaths_} {
    if (nullptr != actionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(actionName, XR_MAX_ACTION_NAME_SIZE, actionName_, XR_MAX_ACTION_NAME_SIZE);
#else
      strncpy(actionName, actionName_, XR_MAX_ACTION_NAME_SIZE - 1);
      actionName[XR_MAX_ACTION_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != localizedActionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(localizedActionName, XR_MAX_LOCALIZED_ACTION_NAME_SIZE, localizedActionName_,
                XR_MAX_LOCALIZED_ACTION_NAME_SIZE);
#else
      strncpy(localizedActionName, localizedActionName_, XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1);
      localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ActionCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionCreateInfo, next_),
        actionType{},
        countSubactionPaths{0},
        subactionPaths{nullptr} {}

  //! Default copy constructor
  ActionCreateInfo(const ActionCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionCreateInfo& operator=(const ActionCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionCreateInfo(const XrActionCreateInfo& rhs) : ActionCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionCreateInfo& operator=(const XrActionCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionCreateInfo&() const {
    return *reinterpret_cast<const XrActionCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionCreateInfo&() { return *reinterpret_cast<XrActionCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionCreateInfo
  XrActionCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionCreateInfo*>(this);
  }
  char actionName[XR_MAX_ACTION_NAME_SIZE];
  ActionType actionType;
  uint32_t countSubactionPaths;
  const Path* subactionPaths;
  char localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE];
};
static_assert(sizeof(XrActionCreateInfo) == sizeof(ActionCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionCreateInfo pointer to const from a
 * ActionCreateInfo reference to const.
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionCreateInfo const* get(ActionCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionCreateInfo as the
 * address of a raw XrActionCreateInfo
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionCreateInfo* put(ActionCreateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionSuggestedBinding
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSuggestedBinding>
 * @xrentity{XrActionSuggestedBinding}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActionSuggestedBinding {
public:
  //! Constructor initializing all members.
  ActionSuggestedBinding(const Action& action_, const Path& binding_)
      : action{action_}, binding{binding_} {}

  //! Default/empty constructor
  ActionSuggestedBinding()

      : action{}, binding{} {}

  //! Default copy constructor
  ActionSuggestedBinding(const ActionSuggestedBinding& rhs) = default;
  //! Default copy assignment
  ActionSuggestedBinding& operator=(const ActionSuggestedBinding& rhs) = default;
  //! Copy construct from raw
  ActionSuggestedBinding(const XrActionSuggestedBinding& rhs) : ActionSuggestedBinding() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActionSuggestedBinding& operator=(const XrActionSuggestedBinding& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSuggestedBinding&() const {
    return *reinterpret_cast<const XrActionSuggestedBinding*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSuggestedBinding&() {
    return *reinterpret_cast<XrActionSuggestedBinding*>(this);
  }

  //! Accessor for this as the address of a raw XrActionSuggestedBinding
  XrActionSuggestedBinding const* get() const noexcept {
    return reinterpret_cast<XrActionSuggestedBinding const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSuggestedBinding.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActionSuggestedBinding* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActionSuggestedBinding{};
    }
    return reinterpret_cast<XrActionSuggestedBinding*>(this);
  }
  Action action;
  Path binding;
};
static_assert(sizeof(XrActionSuggestedBinding) == sizeof(ActionSuggestedBinding),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSuggestedBinding pointer to const from a
 * ActionSuggestedBinding reference to const.
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSuggestedBinding const* get(ActionSuggestedBinding const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSuggestedBinding as the
 * address of a raw XrActionSuggestedBinding
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSuggestedBinding* put(ActionSuggestedBinding& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInteractionProfileSuggestedBinding
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileSuggestedBinding>
 * @xrentity{XrInteractionProfileSuggestedBinding}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileSuggestedBinding : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InteractionProfileSuggestedBinding(const Path& interactionProfile_,
                                     uint32_t countSuggestedBindings_,
                                     const ActionSuggestedBinding* suggestedBindings_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileSuggestedBinding, next_),
        interactionProfile{interactionProfile_},
        countSuggestedBindings{countSuggestedBindings_},
        suggestedBindings{suggestedBindings_} {}

  //! Default/empty constructor
  InteractionProfileSuggestedBinding(const void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileSuggestedBinding, next_),
        interactionProfile{},
        countSuggestedBindings{0},
        suggestedBindings{nullptr} {}

  //! Default copy constructor
  InteractionProfileSuggestedBinding(const InteractionProfileSuggestedBinding& rhs) = default;
  //! Default copy assignment
  InteractionProfileSuggestedBinding& operator=(const InteractionProfileSuggestedBinding& rhs) =
      default;
  //! Copy construct from raw
  InteractionProfileSuggestedBinding(const XrInteractionProfileSuggestedBinding& rhs)
      : InteractionProfileSuggestedBinding() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileSuggestedBinding& operator=(const XrInteractionProfileSuggestedBinding& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileSuggestedBinding&() const {
    return *reinterpret_cast<const XrInteractionProfileSuggestedBinding*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileSuggestedBinding&() {
    return *reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileSuggestedBinding
  XrInteractionProfileSuggestedBinding const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileSuggestedBinding const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileSuggestedBinding.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileSuggestedBinding* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileSuggestedBinding{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
  }
  Path interactionProfile;
  uint32_t countSuggestedBindings;
  const ActionSuggestedBinding* suggestedBindings;
};
static_assert(sizeof(XrInteractionProfileSuggestedBinding) ==
                  sizeof(InteractionProfileSuggestedBinding),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileSuggestedBinding pointer to const from
 * a InteractionProfileSuggestedBinding reference to const.
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding const* get(
    InteractionProfileSuggestedBinding const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileSuggestedBinding as the address of a raw XrInteractionProfileSuggestedBinding
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding* put(
    InteractionProfileSuggestedBinding& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionActionSetsAttachInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionActionSetsAttachInfo>
 * @xrentity{XrSessionActionSetsAttachInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionActionSetsAttachInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionActionSetsAttachInfo(uint32_t countActionSets_, const ActionSet* actionSets_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SessionActionSetsAttachInfo, next_),
        countActionSets{countActionSets_},
        actionSets{actionSets_} {}

  //! Default/empty constructor
  SessionActionSetsAttachInfo(const void* next_ = nullptr)

      : Parent(StructureType::SessionActionSetsAttachInfo, next_),
        countActionSets{0},
        actionSets{nullptr} {}

  //! Default copy constructor
  SessionActionSetsAttachInfo(const SessionActionSetsAttachInfo& rhs) = default;
  //! Default copy assignment
  SessionActionSetsAttachInfo& operator=(const SessionActionSetsAttachInfo& rhs) = default;
  //! Copy construct from raw
  SessionActionSetsAttachInfo(const XrSessionActionSetsAttachInfo& rhs)
      : SessionActionSetsAttachInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SessionActionSetsAttachInfo& operator=(const XrSessionActionSetsAttachInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionActionSetsAttachInfo&() const {
    return *reinterpret_cast<const XrSessionActionSetsAttachInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionActionSetsAttachInfo&() {
    return *reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSessionActionSetsAttachInfo
  XrSessionActionSetsAttachInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionActionSetsAttachInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSessionActionSetsAttachInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionActionSetsAttachInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionActionSetsAttachInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
  }
  uint32_t countActionSets;
  const ActionSet* actionSets;
};
static_assert(sizeof(XrSessionActionSetsAttachInfo) == sizeof(SessionActionSetsAttachInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionActionSetsAttachInfo pointer to const from a
 * SessionActionSetsAttachInfo reference to const.
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo const* get(
    SessionActionSetsAttachInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionActionSetsAttachInfo
 * as the address of a raw XrSessionActionSetsAttachInfo
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo* put(SessionActionSetsAttachInfo& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInteractionProfileState
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileState>
 * @xrentity{XrInteractionProfileState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  InteractionProfileState(void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileState, next_) {}

  //! Default copy constructor
  InteractionProfileState(const InteractionProfileState& rhs) = default;
  //! Default copy assignment
  InteractionProfileState& operator=(const InteractionProfileState& rhs) = default;
  //! Copy construct from raw
  InteractionProfileState(const XrInteractionProfileState& rhs) : InteractionProfileState() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileState& operator=(const XrInteractionProfileState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileState&() const {
    return *reinterpret_cast<const XrInteractionProfileState*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileState&() {
    return *reinterpret_cast<XrInteractionProfileState*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileState
  XrInteractionProfileState const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileState const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileState{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileState*>(this);
  }
  Path interactionProfile;
};
static_assert(sizeof(XrInteractionProfileState) == sizeof(InteractionProfileState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileState pointer to const from a
 * InteractionProfileState reference to const.
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileState const* get(InteractionProfileState const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileState as
 * the address of a raw XrInteractionProfileState
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileState* put(InteractionProfileState& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateGetInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateGetInfo>
 * @xrentity{XrActionStateGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionStateGetInfo(const Action& action_, const Path& subactionPath_, const void* next_ = nullptr)
      : Parent(StructureType::ActionStateGetInfo, next_),
        action{action_},
        subactionPath{subactionPath_} {}

  //! Default/empty constructor
  ActionStateGetInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionStateGetInfo, next_), action{}, subactionPath{} {}

  //! Default copy constructor
  ActionStateGetInfo(const ActionStateGetInfo& rhs) = default;
  //! Default copy assignment
  ActionStateGetInfo& operator=(const ActionStateGetInfo& rhs) = default;
  //! Copy construct from raw
  ActionStateGetInfo(const XrActionStateGetInfo& rhs) : ActionStateGetInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateGetInfo& operator=(const XrActionStateGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateGetInfo&() const {
    return *reinterpret_cast<const XrActionStateGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateGetInfo&() { return *reinterpret_cast<XrActionStateGetInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionStateGetInfo
  XrActionStateGetInfo const* get() const noexcept {
    return reinterpret_cast<XrActionStateGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateGetInfo*>(this);
  }
  Action action;
  Path subactionPath;
};
static_assert(sizeof(XrActionStateGetInfo) == sizeof(ActionStateGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateGetInfo pointer to const from a
 * ActionStateGetInfo reference to const.
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateGetInfo const* get(ActionStateGetInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateGetInfo as the
 * address of a raw XrActionStateGetInfo
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateGetInfo* put(ActionStateGetInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateBoolean
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateBoolean>
 * @xrentity{XrActionStateBoolean}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateBoolean : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateBoolean(void* next_ = nullptr)

      : Parent(StructureType::ActionStateBoolean, next_) {}

  //! Default copy constructor
  ActionStateBoolean(const ActionStateBoolean& rhs) = default;
  //! Default copy assignment
  ActionStateBoolean& operator=(const ActionStateBoolean& rhs) = default;
  //! Copy construct from raw
  ActionStateBoolean(const XrActionStateBoolean& rhs) : ActionStateBoolean() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateBoolean& operator=(const XrActionStateBoolean& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateBoolean&() const {
    return *reinterpret_cast<const XrActionStateBoolean*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateBoolean&() { return *reinterpret_cast<XrActionStateBoolean*>(this); }

  //! Accessor for this as the address of a raw XrActionStateBoolean
  XrActionStateBoolean const* get() const noexcept {
    return reinterpret_cast<XrActionStateBoolean const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateBoolean.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateBoolean* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateBoolean{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateBoolean*>(this);
  }
  Bool32 currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateBoolean) == sizeof(ActionStateBoolean),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateBoolean pointer to const from a
 * ActionStateBoolean reference to const.
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateBoolean const* get(ActionStateBoolean const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateBoolean as the
 * address of a raw XrActionStateBoolean
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateBoolean* put(ActionStateBoolean& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateFloat
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateFloat>
 * @xrentity{XrActionStateFloat}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateFloat : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateFloat(void* next_ = nullptr)

      : Parent(StructureType::ActionStateFloat, next_) {}

  //! Default copy constructor
  ActionStateFloat(const ActionStateFloat& rhs) = default;
  //! Default copy assignment
  ActionStateFloat& operator=(const ActionStateFloat& rhs) = default;
  //! Copy construct from raw
  ActionStateFloat(const XrActionStateFloat& rhs) : ActionStateFloat() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateFloat& operator=(const XrActionStateFloat& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateFloat&() const {
    return *reinterpret_cast<const XrActionStateFloat*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateFloat&() { return *reinterpret_cast<XrActionStateFloat*>(this); }

  //! Accessor for this as the address of a raw XrActionStateFloat
  XrActionStateFloat const* get() const noexcept {
    return reinterpret_cast<XrActionStateFloat const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateFloat.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateFloat* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateFloat{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateFloat*>(this);
  }
  float currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateFloat) == sizeof(ActionStateFloat),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateFloat pointer to const from a
 * ActionStateFloat reference to const.
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateFloat const* get(ActionStateFloat const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateFloat as the
 * address of a raw XrActionStateFloat
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateFloat* put(ActionStateFloat& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector2f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector2f>
 * @xrentity{XrVector2f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector2f {
public:
  //! Constructor initializing all members.
  Vector2f(float x_, float y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Vector2f()

      : x{0.0f}, y{0.0f} {}

  //! Default copy constructor
  Vector2f(const Vector2f& rhs) = default;
  //! Default copy assignment
  Vector2f& operator=(const Vector2f& rhs) = default;
  //! Copy construct from raw
  Vector2f(const XrVector2f& rhs) : Vector2f() { *put() = rhs; }
  //! Copy assign from raw
  Vector2f& operator=(const XrVector2f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector2f&() const { return *reinterpret_cast<const XrVector2f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector2f&() { return *reinterpret_cast<XrVector2f*>(this); }

  //! Accessor for this as the address of a raw XrVector2f
  XrVector2f const* get() const noexcept { return reinterpret_cast<XrVector2f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector2f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector2f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector2f{};
    }
    return reinterpret_cast<XrVector2f*>(this);
  }
  float x;
  float y;
};
static_assert(sizeof(XrVector2f) == sizeof(Vector2f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector2f pointer to const from a Vector2f reference to
 * const.
 * @relates Vector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector2f const* get(Vector2f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector2f as the address of a
 * raw XrVector2f
 * @relates Vector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector2f* put(Vector2f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateVector2f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateVector2f>
 * @xrentity{XrActionStateVector2f}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateVector2f : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateVector2f(void* next_ = nullptr)

      : Parent(StructureType::ActionStateVector2F, next_) {}

  //! Default copy constructor
  ActionStateVector2f(const ActionStateVector2f& rhs) = default;
  //! Default copy assignment
  ActionStateVector2f& operator=(const ActionStateVector2f& rhs) = default;
  //! Copy construct from raw
  ActionStateVector2f(const XrActionStateVector2f& rhs) : ActionStateVector2f() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateVector2f& operator=(const XrActionStateVector2f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateVector2f&() const {
    return *reinterpret_cast<const XrActionStateVector2f*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateVector2f&() { return *reinterpret_cast<XrActionStateVector2f*>(this); }

  //! Accessor for this as the address of a raw XrActionStateVector2f
  XrActionStateVector2f const* get() const noexcept {
    return reinterpret_cast<XrActionStateVector2f const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateVector2f.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateVector2f* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateVector2f{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateVector2f*>(this);
  }
  Vector2f currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateVector2f) == sizeof(ActionStateVector2f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateVector2f pointer to const from a
 * ActionStateVector2f reference to const.
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateVector2f const* get(ActionStateVector2f const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateVector2f as the
 * address of a raw XrActionStateVector2f
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateVector2f* put(ActionStateVector2f& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStatePose
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStatePose>
 * @xrentity{XrActionStatePose}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStatePose : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStatePose(void* next_ = nullptr)

      : Parent(StructureType::ActionStatePose, next_) {}

  //! Default copy constructor
  ActionStatePose(const ActionStatePose& rhs) = default;
  //! Default copy assignment
  ActionStatePose& operator=(const ActionStatePose& rhs) = default;
  //! Copy construct from raw
  ActionStatePose(const XrActionStatePose& rhs) : ActionStatePose() { *put() = rhs; }
  //! Copy assign from raw
  ActionStatePose& operator=(const XrActionStatePose& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStatePose&() const {
    return *reinterpret_cast<const XrActionStatePose*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStatePose&() { return *reinterpret_cast<XrActionStatePose*>(this); }

  //! Accessor for this as the address of a raw XrActionStatePose
  XrActionStatePose const* get() const noexcept {
    return reinterpret_cast<XrActionStatePose const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStatePose.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStatePose* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStatePose{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStatePose*>(this);
  }
  Bool32 isActive;
};
static_assert(sizeof(XrActionStatePose) == sizeof(ActionStatePose),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStatePose pointer to const from a ActionStatePose
 * reference to const.
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStatePose const* get(ActionStatePose const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStatePose as the
 * address of a raw XrActionStatePose
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStatePose* put(ActionStatePose& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActiveActionSet
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSet>
 * @xrentity{XrActiveActionSet}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActiveActionSet {
public:
  //! Constructor initializing all members.
  ActiveActionSet(const ActionSet& actionSet_, const Path& subactionPath_)
      : actionSet{actionSet_}, subactionPath{subactionPath_} {}

  //! Default/empty constructor
  ActiveActionSet()

      : actionSet{}, subactionPath{} {}

  //! Default copy constructor
  ActiveActionSet(const ActiveActionSet& rhs) = default;
  //! Default copy assignment
  ActiveActionSet& operator=(const ActiveActionSet& rhs) = default;
  //! Copy construct from raw
  ActiveActionSet(const XrActiveActionSet& rhs) : ActiveActionSet() { *put() = rhs; }
  //! Copy assign from raw
  ActiveActionSet& operator=(const XrActiveActionSet& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActiveActionSet&() const {
    return *reinterpret_cast<const XrActiveActionSet*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActiveActionSet&() { return *reinterpret_cast<XrActiveActionSet*>(this); }

  //! Accessor for this as the address of a raw XrActiveActionSet
  XrActiveActionSet const* get() const noexcept {
    return reinterpret_cast<XrActiveActionSet const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActiveActionSet.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActiveActionSet* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActiveActionSet{};
    }
    return reinterpret_cast<XrActiveActionSet*>(this);
  }
  ActionSet actionSet;
  Path subactionPath;
};
static_assert(sizeof(XrActiveActionSet) == sizeof(ActiveActionSet),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActiveActionSet pointer to const from a ActiveActionSet
 * reference to const.
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSet const* get(ActiveActionSet const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSet as the
 * address of a raw XrActiveActionSet
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSet* put(ActiveActionSet& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionsSyncInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionsSyncInfo>
 * @xrentity{XrActionsSyncInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionsSyncInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionsSyncInfo(uint32_t countActiveActionSets_, const ActiveActionSet* activeActionSets_,
                  const void* next_ = nullptr)
      : Parent(StructureType::ActionsSyncInfo, next_),
        countActiveActionSets{countActiveActionSets_},
        activeActionSets{activeActionSets_} {}

  //! Default/empty constructor
  ActionsSyncInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionsSyncInfo, next_),
        countActiveActionSets{0},
        activeActionSets{nullptr} {}

  //! Default copy constructor
  ActionsSyncInfo(const ActionsSyncInfo& rhs) = default;
  //! Default copy assignment
  ActionsSyncInfo& operator=(const ActionsSyncInfo& rhs) = default;
  //! Copy construct from raw
  ActionsSyncInfo(const XrActionsSyncInfo& rhs) : ActionsSyncInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionsSyncInfo& operator=(const XrActionsSyncInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionsSyncInfo&() const {
    return *reinterpret_cast<const XrActionsSyncInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionsSyncInfo&() { return *reinterpret_cast<XrActionsSyncInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionsSyncInfo
  XrActionsSyncInfo const* get() const noexcept {
    return reinterpret_cast<XrActionsSyncInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionsSyncInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionsSyncInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionsSyncInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionsSyncInfo*>(this);
  }
  uint32_t countActiveActionSets;
  const ActiveActionSet* activeActionSets;
};
static_assert(sizeof(XrActionsSyncInfo) == sizeof(ActionsSyncInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionsSyncInfo pointer to const from a ActionsSyncInfo
 * reference to const.
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionsSyncInfo const* get(ActionsSyncInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionsSyncInfo as the
 * address of a raw XrActionsSyncInfo
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionsSyncInfo* put(ActionsSyncInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrBoundSourcesForActionEnumerateInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoundSourcesForActionEnumerateInfo>
 * @xrentity{XrBoundSourcesForActionEnumerateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BoundSourcesForActionEnumerateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BoundSourcesForActionEnumerateInfo(const Action& action_, const void* next_ = nullptr)
      : Parent(StructureType::BoundSourcesForActionEnumerateInfo, next_), action{action_} {}

  //! Default/empty constructor
  BoundSourcesForActionEnumerateInfo(const void* next_ = nullptr)

      : Parent(StructureType::BoundSourcesForActionEnumerateInfo, next_), action{} {}

  //! Default copy constructor
  BoundSourcesForActionEnumerateInfo(const BoundSourcesForActionEnumerateInfo& rhs) = default;
  //! Default copy assignment
  BoundSourcesForActionEnumerateInfo& operator=(const BoundSourcesForActionEnumerateInfo& rhs) =
      default;
  //! Copy construct from raw
  BoundSourcesForActionEnumerateInfo(const XrBoundSourcesForActionEnumerateInfo& rhs)
      : BoundSourcesForActionEnumerateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BoundSourcesForActionEnumerateInfo& operator=(const XrBoundSourcesForActionEnumerateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBoundSourcesForActionEnumerateInfo&() const {
    return *reinterpret_cast<const XrBoundSourcesForActionEnumerateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBoundSourcesForActionEnumerateInfo&() {
    return *reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrBoundSourcesForActionEnumerateInfo
  XrBoundSourcesForActionEnumerateInfo const* get() const noexcept {
    return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBoundSourcesForActionEnumerateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBoundSourcesForActionEnumerateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BoundSourcesForActionEnumerateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
  }
  Action action;
};
static_assert(sizeof(XrBoundSourcesForActionEnumerateInfo) ==
                  sizeof(BoundSourcesForActionEnumerateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBoundSourcesForActionEnumerateInfo pointer to const from
 * a BoundSourcesForActionEnumerateInfo reference to const.
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo const* get(
    BoundSourcesForActionEnumerateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * BoundSourcesForActionEnumerateInfo as the address of a raw XrBoundSourcesForActionEnumerateInfo
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo* put(
    BoundSourcesForActionEnumerateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInputSourceLocalizedNameGetInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInputSourceLocalizedNameGetInfo>
 * @xrentity{XrInputSourceLocalizedNameGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InputSourceLocalizedNameGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InputSourceLocalizedNameGetInfo(const Path& sourcePath_,
                                  const InputSourceLocalizedNameFlags& whichComponents_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::InputSourceLocalizedNameGetInfo, next_),
        sourcePath{sourcePath_},
        whichComponents{whichComponents_} {}

  //! Default/empty constructor
  InputSourceLocalizedNameGetInfo(const void* next_ = nullptr)

      : Parent(StructureType::InputSourceLocalizedNameGetInfo, next_),
        sourcePath{},
        whichComponents{} {}

  //! Default copy constructor
  InputSourceLocalizedNameGetInfo(const InputSourceLocalizedNameGetInfo& rhs) = default;
  //! Default copy assignment
  InputSourceLocalizedNameGetInfo& operator=(const InputSourceLocalizedNameGetInfo& rhs) = default;
  //! Copy construct from raw
  InputSourceLocalizedNameGetInfo(const XrInputSourceLocalizedNameGetInfo& rhs)
      : InputSourceLocalizedNameGetInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InputSourceLocalizedNameGetInfo& operator=(const XrInputSourceLocalizedNameGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInputSourceLocalizedNameGetInfo&() const {
    return *reinterpret_cast<const XrInputSourceLocalizedNameGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInputSourceLocalizedNameGetInfo&() {
    return *reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrInputSourceLocalizedNameGetInfo
  XrInputSourceLocalizedNameGetInfo const* get() const noexcept {
    return reinterpret_cast<XrInputSourceLocalizedNameGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInputSourceLocalizedNameGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInputSourceLocalizedNameGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InputSourceLocalizedNameGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
  }
  Path sourcePath;
  InputSourceLocalizedNameFlags whichComponents;
};
static_assert(sizeof(XrInputSourceLocalizedNameGetInfo) == sizeof(InputSourceLocalizedNameGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInputSourceLocalizedNameGetInfo pointer to const from a
 * InputSourceLocalizedNameGetInfo reference to const.
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo const* get(
    InputSourceLocalizedNameGetInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InputSourceLocalizedNameGetInfo as the address of a raw XrInputSourceLocalizedNameGetInfo
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo* put(InputSourceLocalizedNameGetInfo& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrHapticActionInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticActionInfo>
 * @xrentity{XrHapticActionInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticActionInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HapticActionInfo(const Action& action_, const Path& subactionPath_, const void* next_ = nullptr)
      : Parent(StructureType::HapticActionInfo, next_),
        action{action_},
        subactionPath{subactionPath_} {}

  //! Default/empty constructor
  HapticActionInfo(const void* next_ = nullptr)

      : Parent(StructureType::HapticActionInfo, next_), action{}, subactionPath{} {}

  //! Default copy constructor
  HapticActionInfo(const HapticActionInfo& rhs) = default;
  //! Default copy assignment
  HapticActionInfo& operator=(const HapticActionInfo& rhs) = default;
  //! Copy construct from raw
  HapticActionInfo(const XrHapticActionInfo& rhs) : HapticActionInfo() { *put() = rhs; }
  //! Copy assign from raw
  HapticActionInfo& operator=(const XrHapticActionInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticActionInfo&() const {
    return *reinterpret_cast<const XrHapticActionInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticActionInfo&() { return *reinterpret_cast<XrHapticActionInfo*>(this); }

  //! Accessor for this as the address of a raw XrHapticActionInfo
  XrHapticActionInfo const* get() const noexcept {
    return reinterpret_cast<XrHapticActionInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticActionInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticActionInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticActionInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticActionInfo*>(this);
  }
  Action action;
  Path subactionPath;
};
static_assert(sizeof(XrHapticActionInfo) == sizeof(HapticActionInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticActionInfo pointer to const from a
 * HapticActionInfo reference to const.
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticActionInfo const* get(HapticActionInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticActionInfo as the
 * address of a raw XrHapticActionInfo
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticActionInfo* put(HapticActionInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrHapticBaseHeader
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticBaseHeader>
 * @xrentity{XrHapticBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS HapticBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  HapticBaseHeader(StructureType type_, const void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticBaseHeader&() const {
    return *reinterpret_cast<const XrHapticBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticBaseHeader&() { return *reinterpret_cast<XrHapticBaseHeader*>(this); }

  //! Accessor for this as the address of a raw XrHapticBaseHeader
  XrHapticBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
};
static_assert(sizeof(XrHapticBaseHeader) == sizeof(HapticBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticBaseHeader pointer to const from a
 * HapticBaseHeader reference to const.
 * @relates HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get(HapticBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrOffset2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Di>
 * @xrentity{XrOffset2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset2Di {
public:
  //! Constructor initializing all members.
  Offset2Di(int32_t x_, int32_t y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Offset2Di()

      : x{0}, y{0} {}

  //! Default copy constructor
  Offset2Di(const Offset2Di& rhs) = default;
  //! Default copy assignment
  Offset2Di& operator=(const Offset2Di& rhs) = default;
  //! Copy construct from raw
  Offset2Di(const XrOffset2Di& rhs) : Offset2Di() { *put() = rhs; }
  //! Copy assign from raw
  Offset2Di& operator=(const XrOffset2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset2Di&() const { return *reinterpret_cast<const XrOffset2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset2Di&() { return *reinterpret_cast<XrOffset2Di*>(this); }

  //! Accessor for this as the address of a raw XrOffset2Di
  XrOffset2Di const* get() const noexcept { return reinterpret_cast<XrOffset2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset2Di{};
    }
    return reinterpret_cast<XrOffset2Di*>(this);
  }
  int32_t x;
  int32_t y;
};
static_assert(sizeof(XrOffset2Di) == sizeof(Offset2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset2Di pointer to const from a Offset2Di reference to
 * const.
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Di const* get(Offset2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Di as the address of a
 * raw XrOffset2Di
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Di* put(Offset2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Di>
 * @xrentity{XrExtent2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent2Di {
public:
  //! Constructor initializing all members.
  Extent2Di(int32_t width_, int32_t height_) : width{width_}, height{height_} {}

  //! Default/empty constructor
  Extent2Di()

      : width{0}, height{0} {}

  //! Default copy constructor
  Extent2Di(const Extent2Di& rhs) = default;
  //! Default copy assignment
  Extent2Di& operator=(const Extent2Di& rhs) = default;
  //! Copy construct from raw
  Extent2Di(const XrExtent2Di& rhs) : Extent2Di() { *put() = rhs; }
  //! Copy assign from raw
  Extent2Di& operator=(const XrExtent2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent2Di&() const { return *reinterpret_cast<const XrExtent2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent2Di&() { return *reinterpret_cast<XrExtent2Di*>(this); }

  //! Accessor for this as the address of a raw XrExtent2Di
  XrExtent2Di const* get() const noexcept { return reinterpret_cast<XrExtent2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent2Di{};
    }
    return reinterpret_cast<XrExtent2Di*>(this);
  }
  int32_t width;
  int32_t height;
};
static_assert(sizeof(XrExtent2Di) == sizeof(Extent2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent2Di pointer to const from a Extent2Di reference to
 * const.
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Di const* get(Extent2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Di as the address of a
 * raw XrExtent2Di
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Di* put(Extent2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrRect2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Di>
 * @xrentity{XrRect2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect2Di {
public:
  //! Constructor initializing all members.
  Rect2Di(const Offset2Di& offset_, const Extent2Di& extent_) : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect2Di()

      : offset{}, extent{} {}

  //! Default copy constructor
  Rect2Di(const Rect2Di& rhs) = default;
  //! Default copy assignment
  Rect2Di& operator=(const Rect2Di& rhs) = default;
  //! Copy construct from raw
  Rect2Di(const XrRect2Di& rhs) : Rect2Di() { *put() = rhs; }
  //! Copy assign from raw
  Rect2Di& operator=(const XrRect2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect2Di&() const { return *reinterpret_cast<const XrRect2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect2Di&() { return *reinterpret_cast<XrRect2Di*>(this); }

  //! Accessor for this as the address of a raw XrRect2Di
  XrRect2Di const* get() const noexcept { return reinterpret_cast<XrRect2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect2Di{};
    }
    return reinterpret_cast<XrRect2Di*>(this);
  }
  Offset2Di offset;
  Extent2Di extent;
};
static_assert(sizeof(XrRect2Di) == sizeof(Rect2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect2Di pointer to const from a Rect2Di reference to
 * const.
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Di const* get(Rect2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Di as the address of a
 * raw XrRect2Di
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Di* put(Rect2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainSubImage
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainSubImage>
 * @xrentity{XrSwapchainSubImage}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SwapchainSubImage {
public:
  //! Constructor initializing all members.
  SwapchainSubImage(const Swapchain& swapchain_, const Rect2Di& imageRect_,
                    uint32_t imageArrayIndex_)
      : swapchain{swapchain_}, imageRect{imageRect_}, imageArrayIndex{imageArrayIndex_} {}

  //! Default/empty constructor
  SwapchainSubImage()

      : swapchain{}, imageRect{}, imageArrayIndex{0} {}

  //! Default copy constructor
  SwapchainSubImage(const SwapchainSubImage& rhs) = default;
  //! Default copy assignment
  SwapchainSubImage& operator=(const SwapchainSubImage& rhs) = default;
  //! Copy construct from raw
  SwapchainSubImage(const XrSwapchainSubImage& rhs) : SwapchainSubImage() { *put() = rhs; }
  //! Copy assign from raw
  SwapchainSubImage& operator=(const XrSwapchainSubImage& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainSubImage&() const {
    return *reinterpret_cast<const XrSwapchainSubImage*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainSubImage&() { return *reinterpret_cast<XrSwapchainSubImage*>(this); }

  //! Accessor for this as the address of a raw XrSwapchainSubImage
  XrSwapchainSubImage const* get() const noexcept {
    return reinterpret_cast<XrSwapchainSubImage const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainSubImage.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSwapchainSubImage* put(bool clear = true) noexcept {
    if (clear) {
      *this = SwapchainSubImage{};
    }
    return reinterpret_cast<XrSwapchainSubImage*>(this);
  }
  Swapchain swapchain;
  Rect2Di imageRect;
  uint32_t imageArrayIndex;
};
static_assert(sizeof(XrSwapchainSubImage) == sizeof(SwapchainSubImage),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainSubImage pointer to const from a
 * SwapchainSubImage reference to const.
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainSubImage const* get(SwapchainSubImage const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainSubImage as the
 * address of a raw XrSwapchainSubImage
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainSubImage* put(SwapchainSubImage& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerProjectionView
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjectionView>
 * @xrentity{XrCompositionLayerProjectionView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerProjectionView : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerProjectionView(const Posef& pose_, const Fovf& fov_,
                                 const SwapchainSubImage& subImage_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjectionView, next_),
        pose{pose_},
        fov{fov_},
        subImage{subImage_} {}

  //! Default/empty constructor
  CompositionLayerProjectionView(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerProjectionView, next_), pose{}, fov{}, subImage{} {}

  //! Default copy constructor
  CompositionLayerProjectionView(const CompositionLayerProjectionView& rhs) = default;
  //! Default copy assignment
  CompositionLayerProjectionView& operator=(const CompositionLayerProjectionView& rhs) = default;
  //! Copy construct from raw
  CompositionLayerProjectionView(const XrCompositionLayerProjectionView& rhs)
      : CompositionLayerProjectionView() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerProjectionView& operator=(const XrCompositionLayerProjectionView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerProjectionView&() const {
    return *reinterpret_cast<const XrCompositionLayerProjectionView*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerProjectionView&() {
    return *reinterpret_cast<XrCompositionLayerProjectionView*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerProjectionView
  XrCompositionLayerProjectionView const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerProjectionView const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerProjectionView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerProjectionView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerProjectionView{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerProjectionView*>(this);
  }
  Posef pose;
  Fovf fov;
  SwapchainSubImage subImage;
};
static_assert(sizeof(XrCompositionLayerProjectionView) == sizeof(CompositionLayerProjectionView),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjectionView pointer to const from a
 * CompositionLayerProjectionView reference to const.
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjectionView const* get(
    CompositionLayerProjectionView const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerProjectionView as the address of a raw XrCompositionLayerProjectionView
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjectionView* put(CompositionLayerProjectionView& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerProjection
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjection>
 * @xrentity{XrCompositionLayerProjection}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerProjection : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerProjection(const CompositionLayerFlags& layerFlags_, const Space& space_,
                             uint32_t viewCount_, const CompositionLayerProjectionView* views_,
                             const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjection, layerFlags_, space_, next_),
        viewCount{viewCount_},
        views{views_} {}

  //! Default/empty constructor
  CompositionLayerProjection(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerProjection, {}, {}, next_),
        viewCount{0},
        views{nullptr} {}

  //! Default copy constructor
  CompositionLayerProjection(const CompositionLayerProjection& rhs) = default;
  //! Default copy assignment
  CompositionLayerProjection& operator=(const CompositionLayerProjection& rhs) = default;
  //! Copy construct from raw
  CompositionLayerProjection(const XrCompositionLayerProjection& rhs)
      : CompositionLayerProjection() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerProjection& operator=(const XrCompositionLayerProjection& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerProjection&() const {
    return *reinterpret_cast<const XrCompositionLayerProjection*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerProjection&() {
    return *reinterpret_cast<XrCompositionLayerProjection*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerProjection
  XrCompositionLayerProjection const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerProjection const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerProjection.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerProjection* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerProjection{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerProjection*>(this);
  }
  uint32_t viewCount;
  const CompositionLayerProjectionView* views;
};
static_assert(sizeof(XrCompositionLayerProjection) == sizeof(CompositionLayerProjection),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjection pointer to const from a
 * CompositionLayerProjection reference to const.
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjection const* get(
    CompositionLayerProjection const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerProjection as
 * the address of a raw XrCompositionLayerProjection
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjection* put(CompositionLayerProjection& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerProjection as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerProjection
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerProjection const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrCompositionLayerQuad
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerQuad>
 * @xrentity{XrCompositionLayerQuad}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerQuad : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerQuad(const CompositionLayerFlags& layerFlags_, const Space& space_,
                       const EyeVisibility& eyeVisibility_, const SwapchainSubImage& subImage_,
                       const Posef& pose_, const Extent2Df& size_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerQuad, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        size{size_} {}

  //! Default/empty constructor
  CompositionLayerQuad(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerQuad, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        size{} {}

  //! Default copy constructor
  CompositionLayerQuad(const CompositionLayerQuad& rhs) = default;
  //! Default copy assignment
  CompositionLayerQuad& operator=(const CompositionLayerQuad& rhs) = default;
  //! Copy construct from raw
  CompositionLayerQuad(const XrCompositionLayerQuad& rhs) : CompositionLayerQuad() { *put() = rhs; }
  //! Copy assign from raw
  CompositionLayerQuad& operator=(const XrCompositionLayerQuad& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerQuad&() const {
    return *reinterpret_cast<const XrCompositionLayerQuad*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerQuad&() { return *reinterpret_cast<XrCompositionLayerQuad*>(this); }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerQuad
  XrCompositionLayerQuad const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerQuad const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerQuad.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerQuad* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerQuad{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerQuad*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  Extent2Df size;
};
static_assert(sizeof(XrCompositionLayerQuad) == sizeof(CompositionLayerQuad),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerQuad pointer to const from a
 * CompositionLayerQuad reference to const.
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerQuad const* get(CompositionLayerQuad const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerQuad as the
 * address of a raw XrCompositionLayerQuad
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerQuad* put(CompositionLayerQuad& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerQuad as a raw, pointer to
 * const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerQuad
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerQuad const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataBaseHeader
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBaseHeader>
 * @xrentity{XrEventDataBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS EventDataBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  EventDataBaseHeader(StructureType type_, const void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataBaseHeader&() const {
    return *reinterpret_cast<const XrEventDataBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataBaseHeader&() { return *reinterpret_cast<XrEventDataBaseHeader*>(this); }

  //! Accessor for this as the address of a raw XrEventDataBaseHeader
  XrEventDataBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
};
static_assert(sizeof(XrEventDataBaseHeader) == sizeof(EventDataBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataBaseHeader pointer to const from a
 * EventDataBaseHeader reference to const.
 * @relates EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get(EventDataBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrEventDataEventsLost
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataEventsLost>
 * @xrentity{XrEventDataEventsLost}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataEventsLost : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataEventsLost(uint32_t lostEventCount_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataEventsLost, next_), lostEventCount{lostEventCount_} {}

  //! Default/empty constructor
  EventDataEventsLost(const void* next_ = nullptr)

      : Parent(StructureType::EventDataEventsLost, next_), lostEventCount{0} {}

  //! Default copy constructor
  EventDataEventsLost(const EventDataEventsLost& rhs) = default;
  //! Default copy assignment
  EventDataEventsLost& operator=(const EventDataEventsLost& rhs) = default;
  //! Copy construct from raw
  EventDataEventsLost(const XrEventDataEventsLost& rhs) : EventDataEventsLost() { *put() = rhs; }
  //! Copy assign from raw
  EventDataEventsLost& operator=(const XrEventDataEventsLost& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataEventsLost&() const {
    return *reinterpret_cast<const XrEventDataEventsLost*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataEventsLost&() { return *reinterpret_cast<XrEventDataEventsLost*>(this); }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataEventsLost
  XrEventDataEventsLost const* get() const noexcept {
    return reinterpret_cast<XrEventDataEventsLost const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEventDataEventsLost.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataEventsLost* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataEventsLost{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataEventsLost*>(this);
  }
  uint32_t lostEventCount;
};
static_assert(sizeof(XrEventDataEventsLost) == sizeof(EventDataEventsLost),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataEventsLost pointer to const from a
 * EventDataEventsLost reference to const.
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEventsLost const* get(EventDataEventsLost const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataEventsLost as the
 * address of a raw XrEventDataEventsLost
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEventsLost* put(EventDataEventsLost& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataEventsLost as a raw, pointer to
 * const XrEventDataBaseHeader (the base type)
 * @relates EventDataEventsLost
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataEventsLost const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataInstanceLossPending
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInstanceLossPending>
 * @xrentity{XrEventDataInstanceLossPending}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInstanceLossPending : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataInstanceLossPending(const Time& lossTime_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataInstanceLossPending, next_), lossTime{lossTime_} {}

  //! Default/empty constructor
  EventDataInstanceLossPending(const void* next_ = nullptr)

      : Parent(StructureType::EventDataInstanceLossPending, next_), lossTime{} {}

  //! Default copy constructor
  EventDataInstanceLossPending(const EventDataInstanceLossPending& rhs) = default;
  //! Default copy assignment
  EventDataInstanceLossPending& operator=(const EventDataInstanceLossPending& rhs) = default;
  //! Copy construct from raw
  EventDataInstanceLossPending(const XrEventDataInstanceLossPending& rhs)
      : EventDataInstanceLossPending() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInstanceLossPending& operator=(const XrEventDataInstanceLossPending& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInstanceLossPending&() const {
    return *reinterpret_cast<const XrEventDataInstanceLossPending*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInstanceLossPending&() {
    return *reinterpret_cast<XrEventDataInstanceLossPending*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataInstanceLossPending
  XrEventDataInstanceLossPending const* get() const noexcept {
    return reinterpret_cast<XrEventDataInstanceLossPending const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInstanceLossPending.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInstanceLossPending* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInstanceLossPending{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInstanceLossPending*>(this);
  }
  Time lossTime;
};
static_assert(sizeof(XrEventDataInstanceLossPending) == sizeof(EventDataInstanceLossPending),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInstanceLossPending pointer to const from a
 * EventDataInstanceLossPending reference to const.
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInstanceLossPending const* get(
    EventDataInstanceLossPending const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataInstanceLossPending
 * as the address of a raw XrEventDataInstanceLossPending
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInstanceLossPending* put(EventDataInstanceLossPending& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataInstanceLossPending as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInstanceLossPending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataInstanceLossPending const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataSessionStateChanged
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSessionStateChanged>
 * @xrentity{XrEventDataSessionStateChanged}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSessionStateChanged : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataSessionStateChanged(const Session& session_, const SessionState& state_,
                               const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataSessionStateChanged, next_),
        session{session_},
        state{state_},
        time{time_} {}

  //! Default/empty constructor
  EventDataSessionStateChanged(const void* next_ = nullptr)

      : Parent(StructureType::EventDataSessionStateChanged, next_), session{}, state{}, time{} {}

  //! Default copy constructor
  EventDataSessionStateChanged(const EventDataSessionStateChanged& rhs) = default;
  //! Default copy assignment
  EventDataSessionStateChanged& operator=(const EventDataSessionStateChanged& rhs) = default;
  //! Copy construct from raw
  EventDataSessionStateChanged(const XrEventDataSessionStateChanged& rhs)
      : EventDataSessionStateChanged() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSessionStateChanged& operator=(const XrEventDataSessionStateChanged& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSessionStateChanged&() const {
    return *reinterpret_cast<const XrEventDataSessionStateChanged*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSessionStateChanged&() {
    return *reinterpret_cast<XrEventDataSessionStateChanged*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSessionStateChanged
  XrEventDataSessionStateChanged const* get() const noexcept {
    return reinterpret_cast<XrEventDataSessionStateChanged const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSessionStateChanged.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSessionStateChanged* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSessionStateChanged{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSessionStateChanged*>(this);
  }
  Session session;
  SessionState state;
  Time time;
};
static_assert(sizeof(XrEventDataSessionStateChanged) == sizeof(EventDataSessionStateChanged),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSessionStateChanged pointer to const from a
 * EventDataSessionStateChanged reference to const.
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSessionStateChanged const* get(
    EventDataSessionStateChanged const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSessionStateChanged
 * as the address of a raw XrEventDataSessionStateChanged
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSessionStateChanged* put(EventDataSessionStateChanged& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSessionStateChanged as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSessionStateChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSessionStateChanged const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataReferenceSpaceChangePending
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataReferenceSpaceChangePending>
 * @xrentity{XrEventDataReferenceSpaceChangePending}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataReferenceSpaceChangePending : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataReferenceSpaceChangePending(const Session& session_,
                                       const ReferenceSpaceType& referenceSpaceType_,
                                       const Time& changeTime_, const Bool32& poseValid_,
                                       const Posef& poseInPreviousSpace_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::EventDataReferenceSpaceChangePending, next_),
        session{session_},
        referenceSpaceType{referenceSpaceType_},
        changeTime{changeTime_},
        poseValid{poseValid_},
        poseInPreviousSpace{poseInPreviousSpace_} {}

  //! Default/empty constructor
  EventDataReferenceSpaceChangePending(const void* next_ = nullptr)

      : Parent(StructureType::EventDataReferenceSpaceChangePending, next_),
        session{},
        referenceSpaceType{},
        changeTime{},
        poseValid{false},
        poseInPreviousSpace{} {}

  //! Default copy constructor
  EventDataReferenceSpaceChangePending(const EventDataReferenceSpaceChangePending& rhs) = default;
  //! Default copy assignment
  EventDataReferenceSpaceChangePending& operator=(const EventDataReferenceSpaceChangePending& rhs) =
      default;
  //! Copy construct from raw
  EventDataReferenceSpaceChangePending(const XrEventDataReferenceSpaceChangePending& rhs)
      : EventDataReferenceSpaceChangePending() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataReferenceSpaceChangePending& operator=(
      const XrEventDataReferenceSpaceChangePending& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataReferenceSpaceChangePending&() const {
    return *reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataReferenceSpaceChangePending&() {
    return *reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataReferenceSpaceChangePending
  XrEventDataReferenceSpaceChangePending const* get() const noexcept {
    return reinterpret_cast<XrEventDataReferenceSpaceChangePending const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataReferenceSpaceChangePending.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataReferenceSpaceChangePending* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataReferenceSpaceChangePending{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
  }
  Session session;
  ReferenceSpaceType referenceSpaceType;
  Time changeTime;
  Bool32 poseValid;
  Posef poseInPreviousSpace;
};
static_assert(sizeof(XrEventDataReferenceSpaceChangePending) ==
                  sizeof(EventDataReferenceSpaceChangePending),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataReferenceSpaceChangePending pointer to const
 * from a EventDataReferenceSpaceChangePending reference to const.
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending const* get(
    EventDataReferenceSpaceChangePending const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataReferenceSpaceChangePending as the address of a raw
 * XrEventDataReferenceSpaceChangePending
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending* put(
    EventDataReferenceSpaceChangePending& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataReferenceSpaceChangePending as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataReferenceSpaceChangePending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataReferenceSpaceChangePending const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataInteractionProfileChanged
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInteractionProfileChanged>
 * @xrentity{XrEventDataInteractionProfileChanged}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInteractionProfileChanged : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataInteractionProfileChanged(const Session& session_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataInteractionProfileChanged, next_), session{session_} {}

  //! Default/empty constructor
  EventDataInteractionProfileChanged(const void* next_ = nullptr)

      : Parent(StructureType::EventDataInteractionProfileChanged, next_), session{} {}

  //! Default copy constructor
  EventDataInteractionProfileChanged(const EventDataInteractionProfileChanged& rhs) = default;
  //! Default copy assignment
  EventDataInteractionProfileChanged& operator=(const EventDataInteractionProfileChanged& rhs) =
      default;
  //! Copy construct from raw
  EventDataInteractionProfileChanged(const XrEventDataInteractionProfileChanged& rhs)
      : EventDataInteractionProfileChanged() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInteractionProfileChanged& operator=(const XrEventDataInteractionProfileChanged& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInteractionProfileChanged&() const {
    return *reinterpret_cast<const XrEventDataInteractionProfileChanged*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInteractionProfileChanged&() {
    return *reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataInteractionProfileChanged
  XrEventDataInteractionProfileChanged const* get() const noexcept {
    return reinterpret_cast<XrEventDataInteractionProfileChanged const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInteractionProfileChanged.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInteractionProfileChanged* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInteractionProfileChanged{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
  }
  Session session;
};
static_assert(sizeof(XrEventDataInteractionProfileChanged) ==
                  sizeof(EventDataInteractionProfileChanged),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInteractionProfileChanged pointer to const from
 * a EventDataInteractionProfileChanged reference to const.
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged const* get(
    EventDataInteractionProfileChanged const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataInteractionProfileChanged as the address of a raw XrEventDataInteractionProfileChanged
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged* put(
    EventDataInteractionProfileChanged& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataInteractionProfileChanged as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInteractionProfileChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataInteractionProfileChanged const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrHapticVibration
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticVibration>
 * @xrentity{XrHapticVibration}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticVibration : public HapticBaseHeader {
private:
  using Parent = HapticBaseHeader;

public:
  //! Constructor initializing all members.
  HapticVibration(const Duration& duration_, float frequency_, float amplitude_,
                  const void* next_ = nullptr)
      : Parent(StructureType::HapticVibration, next_),
        duration{duration_},
        frequency{frequency_},
        amplitude{amplitude_} {}

  //! Default/empty constructor
  HapticVibration(const void* next_ = nullptr)

      : Parent(StructureType::HapticVibration, next_),
        duration{},
        frequency{0.0f},
        amplitude{0.0f} {}

  //! Default copy constructor
  HapticVibration(const HapticVibration& rhs) = default;
  //! Default copy assignment
  HapticVibration& operator=(const HapticVibration& rhs) = default;
  //! Copy construct from raw
  HapticVibration(const XrHapticVibration& rhs) : HapticVibration() { *put() = rhs; }
  //! Copy assign from raw
  HapticVibration& operator=(const XrHapticVibration& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticVibration&() const {
    return *reinterpret_cast<const XrHapticVibration*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticVibration&() { return *reinterpret_cast<XrHapticVibration*>(this); }

  //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
  XrHapticBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrHapticVibration
  XrHapticVibration const* get() const noexcept {
    return reinterpret_cast<XrHapticVibration const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticVibration.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticVibration* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticVibration{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticVibration*>(this);
  }
  Duration duration;
  float frequency;
  float amplitude;
};
static_assert(sizeof(XrHapticVibration) == sizeof(HapticVibration),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticVibration pointer to const from a HapticVibration
 * reference to const.
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticVibration const* get(HapticVibration const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticVibration as the
 * address of a raw XrHapticVibration
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticVibration* put(HapticVibration& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const HapticVibration as a raw, pointer to const
 * XrHapticBaseHeader (the base type)
 * @relates HapticVibration
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticVibration const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrOffset2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Df>
 * @xrentity{XrOffset2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset2Df {
public:
  //! Constructor initializing all members.
  Offset2Df(float x_, float y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Offset2Df()

      : x{0.0f}, y{0.0f} {}

  //! Default copy constructor
  Offset2Df(const Offset2Df& rhs) = default;
  //! Default copy assignment
  Offset2Df& operator=(const Offset2Df& rhs) = default;
  //! Copy construct from raw
  Offset2Df(const XrOffset2Df& rhs) : Offset2Df() { *put() = rhs; }
  //! Copy assign from raw
  Offset2Df& operator=(const XrOffset2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset2Df&() const { return *reinterpret_cast<const XrOffset2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset2Df&() { return *reinterpret_cast<XrOffset2Df*>(this); }

  //! Accessor for this as the address of a raw XrOffset2Df
  XrOffset2Df const* get() const noexcept { return reinterpret_cast<XrOffset2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset2Df{};
    }
    return reinterpret_cast<XrOffset2Df*>(this);
  }
  float x;
  float y;
};
static_assert(sizeof(XrOffset2Df) == sizeof(Offset2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset2Df pointer to const from a Offset2Df reference to
 * const.
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Df const* get(Offset2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Df as the address of a
 * raw XrOffset2Df
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Df* put(Offset2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrRect2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Df>
 * @xrentity{XrRect2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect2Df {
public:
  //! Constructor initializing all members.
  Rect2Df(const Offset2Df& offset_, const Extent2Df& extent_) : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect2Df()

      : offset{}, extent{} {}

  //! Default copy constructor
  Rect2Df(const Rect2Df& rhs) = default;
  //! Default copy assignment
  Rect2Df& operator=(const Rect2Df& rhs) = default;
  //! Copy construct from raw
  Rect2Df(const XrRect2Df& rhs) : Rect2Df() { *put() = rhs; }
  //! Copy assign from raw
  Rect2Df& operator=(const XrRect2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect2Df&() const { return *reinterpret_cast<const XrRect2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect2Df&() { return *reinterpret_cast<XrRect2Df*>(this); }

  //! Accessor for this as the address of a raw XrRect2Df
  XrRect2Df const* get() const noexcept { return reinterpret_cast<XrRect2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect2Df{};
    }
    return reinterpret_cast<XrRect2Df*>(this);
  }
  Offset2Df offset;
  Extent2Df extent;
};
static_assert(sizeof(XrRect2Df) == sizeof(Rect2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect2Df pointer to const from a Rect2Df reference to
 * const.
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Df const* get(Rect2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Df as the address of a
 * raw XrRect2Df
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Df* put(Rect2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector4f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4f>
 * @xrentity{XrVector4f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector4f {
public:
  //! Constructor initializing all members.
  Vector4f(float x_, float y_, float z_, float w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Vector4f()

      : x{0.0f}, y{0.0f}, z{0.0f}, w{0.0f} {}

  //! Default copy constructor
  Vector4f(const Vector4f& rhs) = default;
  //! Default copy assignment
  Vector4f& operator=(const Vector4f& rhs) = default;
  //! Copy construct from raw
  Vector4f(const XrVector4f& rhs) : Vector4f() { *put() = rhs; }
  //! Copy assign from raw
  Vector4f& operator=(const XrVector4f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector4f&() const { return *reinterpret_cast<const XrVector4f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector4f&() { return *reinterpret_cast<XrVector4f*>(this); }

  //! Accessor for this as the address of a raw XrVector4f
  XrVector4f const* get() const noexcept { return reinterpret_cast<XrVector4f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector4f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector4f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector4f{};
    }
    return reinterpret_cast<XrVector4f*>(this);
  }
  float x;
  float y;
  float z;
  float w;
};
static_assert(sizeof(XrVector4f) == sizeof(Vector4f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector4f pointer to const from a Vector4f reference to
 * const.
 * @relates Vector4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4f const* get(Vector4f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4f as the address of a
 * raw XrVector4f
 * @relates Vector4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4f* put(Vector4f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrColor4f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColor4f>
 * @xrentity{XrColor4f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Color4f {
public:
  //! Constructor initializing all members.
  Color4f(float r_, float g_, float b_, float a_) : r{r_}, g{g_}, b{b_}, a{a_} {}

  //! Default/empty constructor
  Color4f()

      : r{0.0f}, g{0.0f}, b{0.0f}, a{0.0f} {}

  //! Default copy constructor
  Color4f(const Color4f& rhs) = default;
  //! Default copy assignment
  Color4f& operator=(const Color4f& rhs) = default;
  //! Copy construct from raw
  Color4f(const XrColor4f& rhs) : Color4f() { *put() = rhs; }
  //! Copy assign from raw
  Color4f& operator=(const XrColor4f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColor4f&() const { return *reinterpret_cast<const XrColor4f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColor4f&() { return *reinterpret_cast<XrColor4f*>(this); }

  //! Accessor for this as the address of a raw XrColor4f
  XrColor4f const* get() const noexcept { return reinterpret_cast<XrColor4f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrColor4f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrColor4f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Color4f{};
    }
    return reinterpret_cast<XrColor4f*>(this);
  }
  float r;
  float g;
  float b;
  float a;
};
static_assert(sizeof(XrColor4f) == sizeof(Color4f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColor4f pointer to const from a Color4f reference to
 * const.
 * @relates Color4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor4f const* get(Color4f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Color4f as the address of a
 * raw XrColor4f
 * @relates Color4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor4f* put(Color4f& s, bool clear = true) noexcept {
  return s.put(clear);
}

#ifdef XR_KHR_composition_layer_cube
/*!
 * C++ projection of XrCompositionLayerCubeKHR
 *
 * Provided by the `XR_KHR_composition_layer_cube` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCubeKHR>
 * @xrentity{XrCompositionLayerCubeKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerCubeKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerCubeKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                          const EyeVisibility& eyeVisibility_, const Swapchain& swapchain_,
                          uint32_t imageArrayIndex_, const Quaternionf& orientation_,
                          const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCubeKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        swapchain{swapchain_},
        imageArrayIndex{imageArrayIndex_},
        orientation{orientation_} {}

  //! Default/empty constructor
  CompositionLayerCubeKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerCubeKHR, {}, {}, next_),
        eyeVisibility{},
        swapchain{},
        imageArrayIndex{0},
        orientation{} {}

  //! Default copy constructor
  CompositionLayerCubeKHR(const CompositionLayerCubeKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerCubeKHR& operator=(const CompositionLayerCubeKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerCubeKHR(const XrCompositionLayerCubeKHR& rhs) : CompositionLayerCubeKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerCubeKHR& operator=(const XrCompositionLayerCubeKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerCubeKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerCubeKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerCubeKHR&() {
    return *reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerCubeKHR
  XrCompositionLayerCubeKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerCubeKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerCubeKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerCubeKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerCubeKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  Swapchain swapchain;
  uint32_t imageArrayIndex;
  Quaternionf orientation;
};
static_assert(sizeof(XrCompositionLayerCubeKHR) == sizeof(CompositionLayerCubeKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerCubeKHR pointer to const from a
 * CompositionLayerCubeKHR reference to const.
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR const* get(CompositionLayerCubeKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCubeKHR as
 * the address of a raw XrCompositionLayerCubeKHR
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR* put(CompositionLayerCubeKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCubeKHR as a raw, pointer
 * to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCubeKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerCubeKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_cube

#ifdef XR_KHR_android_create_instance
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrInstanceCreateInfoAndroidKHR
 *
 * Provided by the `XR_KHR_android_create_instance` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfoAndroidKHR>
 * @xrentity{XrInstanceCreateInfoAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceCreateInfoAndroidKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InstanceCreateInfoAndroidKHR(void* XR_MAY_ALIAS applicationVM_,
                               void* XR_MAY_ALIAS applicationActivity_, const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfoAndroidKHR, next_),
        applicationVM{applicationVM_},
        applicationActivity{applicationActivity_} {}

  //! Default/empty constructor
  InstanceCreateInfoAndroidKHR(const void* next_ = nullptr)

      : Parent(StructureType::InstanceCreateInfoAndroidKHR, next_),
        applicationVM{nullptr},
        applicationActivity{nullptr} {}

  //! Default copy constructor
  InstanceCreateInfoAndroidKHR(const InstanceCreateInfoAndroidKHR& rhs) = default;
  //! Default copy assignment
  InstanceCreateInfoAndroidKHR& operator=(const InstanceCreateInfoAndroidKHR& rhs) = default;
  //! Copy construct from raw
  InstanceCreateInfoAndroidKHR(const XrInstanceCreateInfoAndroidKHR& rhs)
      : InstanceCreateInfoAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InstanceCreateInfoAndroidKHR& operator=(const XrInstanceCreateInfoAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceCreateInfoAndroidKHR&() const {
    return *reinterpret_cast<const XrInstanceCreateInfoAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceCreateInfoAndroidKHR&() {
    return *reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrInstanceCreateInfoAndroidKHR
  XrInstanceCreateInfoAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrInstanceCreateInfoAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInstanceCreateInfoAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceCreateInfoAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceCreateInfoAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
  }
  void* XR_MAY_ALIAS applicationVM;
  void* XR_MAY_ALIAS applicationActivity;
};
static_assert(sizeof(XrInstanceCreateInfoAndroidKHR) == sizeof(InstanceCreateInfoAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfoAndroidKHR pointer to const from a
 * InstanceCreateInfoAndroidKHR reference to const.
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR const* get(
    InstanceCreateInfoAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfoAndroidKHR
 * as the address of a raw XrInstanceCreateInfoAndroidKHR
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR* put(InstanceCreateInfoAndroidKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_create_instance

#ifdef XR_KHR_composition_layer_depth
/*!
 * C++ projection of XrCompositionLayerDepthInfoKHR
 *
 * Provided by the `XR_KHR_composition_layer_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthInfoKHR>
 * @xrentity{XrCompositionLayerDepthInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerDepthInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerDepthInfoKHR(const SwapchainSubImage& subImage_, float minDepth_, float maxDepth_,
                               float nearZ_, float farZ_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthInfoKHR, next_),
        subImage{subImage_},
        minDepth{minDepth_},
        maxDepth{maxDepth_},
        nearZ{nearZ_},
        farZ{farZ_} {}

  //! Default/empty constructor
  CompositionLayerDepthInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerDepthInfoKHR, next_),
        subImage{},
        minDepth{0.0f},
        maxDepth{0.0f},
        nearZ{0.0f},
        farZ{0.0f} {}

  //! Default copy constructor
  CompositionLayerDepthInfoKHR(const CompositionLayerDepthInfoKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerDepthInfoKHR& operator=(const CompositionLayerDepthInfoKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerDepthInfoKHR(const XrCompositionLayerDepthInfoKHR& rhs)
      : CompositionLayerDepthInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerDepthInfoKHR& operator=(const XrCompositionLayerDepthInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerDepthInfoKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerDepthInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerDepthInfoKHR&() {
    return *reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerDepthInfoKHR
  XrCompositionLayerDepthInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerDepthInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerDepthInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerDepthInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerDepthInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
  }
  SwapchainSubImage subImage;
  float minDepth;
  float maxDepth;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrCompositionLayerDepthInfoKHR) == sizeof(CompositionLayerDepthInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthInfoKHR pointer to const from a
 * CompositionLayerDepthInfoKHR reference to const.
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR const* get(
    CompositionLayerDepthInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthInfoKHR
 * as the address of a raw XrCompositionLayerDepthInfoKHR
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR* put(CompositionLayerDepthInfoKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_composition_layer_depth

#ifdef XR_KHR_vulkan_swapchain_format_list
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanSwapchainFormatListCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_swapchain_format_list` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanSwapchainFormatListCreateInfoKHR>
 * @xrentity{XrVulkanSwapchainFormatListCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanSwapchainFormatListCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanSwapchainFormatListCreateInfoKHR(uint32_t viewFormatCount_, const VkFormat* viewFormats_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR, next_),
        viewFormatCount{viewFormatCount_},
        viewFormats{viewFormats_} {}

  //! Default/empty constructor
  VulkanSwapchainFormatListCreateInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR, next_),
        viewFormatCount{0},
        viewFormats{nullptr} {}

  //! Default copy constructor
  VulkanSwapchainFormatListCreateInfoKHR(const VulkanSwapchainFormatListCreateInfoKHR& rhs) =
      default;
  //! Default copy assignment
  VulkanSwapchainFormatListCreateInfoKHR& operator=(
      const VulkanSwapchainFormatListCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanSwapchainFormatListCreateInfoKHR(const XrVulkanSwapchainFormatListCreateInfoKHR& rhs)
      : VulkanSwapchainFormatListCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanSwapchainFormatListCreateInfoKHR& operator=(
      const XrVulkanSwapchainFormatListCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanSwapchainFormatListCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanSwapchainFormatListCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanSwapchainFormatListCreateInfoKHR
  XrVulkanSwapchainFormatListCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanSwapchainFormatListCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanSwapchainFormatListCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanSwapchainFormatListCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }
  uint32_t viewFormatCount;
  const VkFormat* viewFormats;
};
static_assert(sizeof(XrVulkanSwapchainFormatListCreateInfoKHR) ==
                  sizeof(VulkanSwapchainFormatListCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanSwapchainFormatListCreateInfoKHR pointer to const
 * from a VulkanSwapchainFormatListCreateInfoKHR reference to const.
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR const* get(
    VulkanSwapchainFormatListCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VulkanSwapchainFormatListCreateInfoKHR as the address of a raw
 * XrVulkanSwapchainFormatListCreateInfoKHR
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR* put(
    VulkanSwapchainFormatListCreateInfoKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_swapchain_format_list

#ifdef XR_KHR_composition_layer_cylinder
/*!
 * C++ projection of XrCompositionLayerCylinderKHR
 *
 * Provided by the `XR_KHR_composition_layer_cylinder` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCylinderKHR>
 * @xrentity{XrCompositionLayerCylinderKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerCylinderKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerCylinderKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                              const EyeVisibility& eyeVisibility_,
                              const SwapchainSubImage& subImage_, const Posef& pose_, float radius_,
                              float centralAngle_, float aspectRatio_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCylinderKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        centralAngle{centralAngle_},
        aspectRatio{aspectRatio_} {}

  //! Default/empty constructor
  CompositionLayerCylinderKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerCylinderKHR, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        radius{0.0f},
        centralAngle{0.0f},
        aspectRatio{0.0f} {}

  //! Default copy constructor
  CompositionLayerCylinderKHR(const CompositionLayerCylinderKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerCylinderKHR& operator=(const CompositionLayerCylinderKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerCylinderKHR(const XrCompositionLayerCylinderKHR& rhs)
      : CompositionLayerCylinderKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerCylinderKHR& operator=(const XrCompositionLayerCylinderKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerCylinderKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerCylinderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerCylinderKHR&() {
    return *reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerCylinderKHR
  XrCompositionLayerCylinderKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerCylinderKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerCylinderKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerCylinderKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerCylinderKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  float centralAngle;
  float aspectRatio;
};
static_assert(sizeof(XrCompositionLayerCylinderKHR) == sizeof(CompositionLayerCylinderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerCylinderKHR pointer to const from a
 * CompositionLayerCylinderKHR reference to const.
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR const* get(
    CompositionLayerCylinderKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCylinderKHR
 * as the address of a raw XrCompositionLayerCylinderKHR
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR* put(CompositionLayerCylinderKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCylinderKHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCylinderKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerCylinderKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_cylinder

#ifdef XR_KHR_composition_layer_equirect
/*!
 * C++ projection of XrCompositionLayerEquirectKHR
 *
 * Provided by the `XR_KHR_composition_layer_equirect` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirectKHR>
 * @xrentity{XrCompositionLayerEquirectKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerEquirectKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerEquirectKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                              const EyeVisibility& eyeVisibility_,
                              const SwapchainSubImage& subImage_, const Posef& pose_, float radius_,
                              const Vector2f& scale_, const Vector2f& bias_,
                              const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirectKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        scale{scale_},
        bias{bias_} {}

  //! Default/empty constructor
  CompositionLayerEquirectKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerEquirectKHR, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        radius{0.0f},
        scale{},
        bias{} {}

  //! Default copy constructor
  CompositionLayerEquirectKHR(const CompositionLayerEquirectKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerEquirectKHR& operator=(const CompositionLayerEquirectKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerEquirectKHR(const XrCompositionLayerEquirectKHR& rhs)
      : CompositionLayerEquirectKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerEquirectKHR& operator=(const XrCompositionLayerEquirectKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerEquirectKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerEquirectKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerEquirectKHR&() {
    return *reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerEquirectKHR
  XrCompositionLayerEquirectKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerEquirectKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerEquirectKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerEquirectKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerEquirectKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  Vector2f scale;
  Vector2f bias;
};
static_assert(sizeof(XrCompositionLayerEquirectKHR) == sizeof(CompositionLayerEquirectKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirectKHR pointer to const from a
 * CompositionLayerEquirectKHR reference to const.
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR const* get(
    CompositionLayerEquirectKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirectKHR
 * as the address of a raw XrCompositionLayerEquirectKHR
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR* put(CompositionLayerEquirectKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirectKHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirectKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerEquirectKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_equirect

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWin32KHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWin32KHR>
 * @xrentity{XrGraphicsBindingOpenGLWin32KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLWin32KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLWin32KHR(HDC hDC_, HGLRC hGLRC_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWin32KHR, next_), hDC{hDC_}, hGLRC{hGLRC_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLWin32KHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLWin32KHR, next_), hDC{}, hGLRC{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLWin32KHR(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLWin32KHR& operator=(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLWin32KHR(const XrGraphicsBindingOpenGLWin32KHR& rhs)
      : GraphicsBindingOpenGLWin32KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLWin32KHR& operator=(const XrGraphicsBindingOpenGLWin32KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLWin32KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLWin32KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLWin32KHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWin32KHR
  XrGraphicsBindingOpenGLWin32KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLWin32KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLWin32KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLWin32KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
  }
  HDC hDC;
  HGLRC hGLRC;
};
static_assert(sizeof(XrGraphicsBindingOpenGLWin32KHR) == sizeof(GraphicsBindingOpenGLWin32KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWin32KHR pointer to const from a
 * GraphicsBindingOpenGLWin32KHR reference to const.
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR const* get(
    GraphicsBindingOpenGLWin32KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLWin32KHR
 * as the address of a raw XrGraphicsBindingOpenGLWin32KHR
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR* put(GraphicsBindingOpenGLWin32KHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXlibKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXlibKHR>
 * @xrentity{XrGraphicsBindingOpenGLXlibKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLXlibKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLXlibKHR(Display* xDisplay_, uint32_t visualid_, GLXFBConfig glxFBConfig_,
                               GLXDrawable glxDrawable_, GLXContext glxContext_,
                               const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXlibKHR, next_),
        xDisplay{xDisplay_},
        visualid{visualid_},
        glxFBConfig{glxFBConfig_},
        glxDrawable{glxDrawable_},
        glxContext{glxContext_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLXlibKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLXlibKHR, next_),
        xDisplay{nullptr},
        visualid{0},
        glxFBConfig{},
        glxDrawable{},
        glxContext{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLXlibKHR(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLXlibKHR& operator=(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLXlibKHR(const XrGraphicsBindingOpenGLXlibKHR& rhs)
      : GraphicsBindingOpenGLXlibKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLXlibKHR& operator=(const XrGraphicsBindingOpenGLXlibKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLXlibKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLXlibKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLXlibKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXlibKHR
  XrGraphicsBindingOpenGLXlibKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLXlibKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLXlibKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLXlibKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
  }
  Display* xDisplay;
  uint32_t visualid;
  GLXFBConfig glxFBConfig;
  GLXDrawable glxDrawable;
  GLXContext glxContext;
};
static_assert(sizeof(XrGraphicsBindingOpenGLXlibKHR) == sizeof(GraphicsBindingOpenGLXlibKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXlibKHR pointer to const from a
 * GraphicsBindingOpenGLXlibKHR reference to const.
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR const* get(
    GraphicsBindingOpenGLXlibKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXlibKHR
 * as the address of a raw XrGraphicsBindingOpenGLXlibKHR
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR* put(GraphicsBindingOpenGLXlibKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXcbKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXcbKHR>
 * @xrentity{XrGraphicsBindingOpenGLXcbKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLXcbKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLXcbKHR(xcb_connection_t* connection_, uint32_t screenNumber_,
                              xcb_glx_fbconfig_t fbconfigid_, xcb_visualid_t visualid_,
                              xcb_glx_drawable_t glxDrawable_, xcb_glx_context_t glxContext_,
                              const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXcbKHR, next_),
        connection{connection_},
        screenNumber{screenNumber_},
        fbconfigid{fbconfigid_},
        visualid{visualid_},
        glxDrawable{glxDrawable_},
        glxContext{glxContext_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLXcbKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLXcbKHR, next_),
        connection{},
        screenNumber{0},
        fbconfigid{},
        visualid{},
        glxDrawable{},
        glxContext{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLXcbKHR(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLXcbKHR& operator=(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLXcbKHR(const XrGraphicsBindingOpenGLXcbKHR& rhs)
      : GraphicsBindingOpenGLXcbKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLXcbKHR& operator=(const XrGraphicsBindingOpenGLXcbKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLXcbKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLXcbKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLXcbKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXcbKHR
  XrGraphicsBindingOpenGLXcbKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLXcbKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLXcbKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLXcbKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
  }
  xcb_connection_t* connection;
  uint32_t screenNumber;
  xcb_glx_fbconfig_t fbconfigid;
  xcb_visualid_t visualid;
  xcb_glx_drawable_t glxDrawable;
  xcb_glx_context_t glxContext;
};
static_assert(sizeof(XrGraphicsBindingOpenGLXcbKHR) == sizeof(GraphicsBindingOpenGLXcbKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXcbKHR pointer to const from a
 * GraphicsBindingOpenGLXcbKHR reference to const.
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR const* get(
    GraphicsBindingOpenGLXcbKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXcbKHR
 * as the address of a raw XrGraphicsBindingOpenGLXcbKHR
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR* put(GraphicsBindingOpenGLXcbKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWaylandKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWaylandKHR>
 * @xrentity{XrGraphicsBindingOpenGLWaylandKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLWaylandKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLWaylandKHR(struct wl_display* display_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWaylandKHR, next_), display{display_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLWaylandKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLWaylandKHR, next_), display{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLWaylandKHR(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLWaylandKHR& operator=(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLWaylandKHR(const XrGraphicsBindingOpenGLWaylandKHR& rhs)
      : GraphicsBindingOpenGLWaylandKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLWaylandKHR& operator=(const XrGraphicsBindingOpenGLWaylandKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLWaylandKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLWaylandKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
  XrGraphicsBindingOpenGLWaylandKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLWaylandKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLWaylandKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLWaylandKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }
  struct wl_display* display;
};
static_assert(sizeof(XrGraphicsBindingOpenGLWaylandKHR) == sizeof(GraphicsBindingOpenGLWaylandKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWaylandKHR pointer to const from a
 * GraphicsBindingOpenGLWaylandKHR reference to const.
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR const* get(
    GraphicsBindingOpenGLWaylandKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsBindingOpenGLWaylandKHR as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR* put(GraphicsBindingOpenGLWaylandKHR& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrSwapchainImageOpenGLKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLKHR>
 * @xrentity{XrSwapchainImageOpenGLKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageOpenGLKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageOpenGLKHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageOpenGLKHR, next_) {}

  //! Default copy constructor
  SwapchainImageOpenGLKHR(const SwapchainImageOpenGLKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageOpenGLKHR& operator=(const SwapchainImageOpenGLKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageOpenGLKHR(const XrSwapchainImageOpenGLKHR& rhs) : SwapchainImageOpenGLKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageOpenGLKHR& operator=(const XrSwapchainImageOpenGLKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageOpenGLKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageOpenGLKHR&() {
    return *reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageOpenGLKHR
  XrSwapchainImageOpenGLKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageOpenGLKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageOpenGLKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageOpenGLKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageOpenGLKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
  }
  uint32_t image;
};
static_assert(sizeof(XrSwapchainImageOpenGLKHR) == sizeof(SwapchainImageOpenGLKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLKHR pointer to const from a
 * SwapchainImageOpenGLKHR reference to const.
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR const* get(SwapchainImageOpenGLKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLKHR as
 * the address of a raw XrSwapchainImageOpenGLKHR
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR* put(SwapchainImageOpenGLKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLKHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageOpenGLKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsOpenGLKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsOpenGLKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsOpenGLKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsOpenGLKHR(const GraphicsRequirementsOpenGLKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsOpenGLKHR& operator=(const GraphicsRequirementsOpenGLKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsOpenGLKHR(const XrGraphicsRequirementsOpenGLKHR& rhs)
      : GraphicsRequirementsOpenGLKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsOpenGLKHR& operator=(const XrGraphicsRequirementsOpenGLKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsOpenGLKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsOpenGLKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsOpenGLKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLKHR
  XrGraphicsRequirementsOpenGLKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsOpenGLKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsOpenGLKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsOpenGLKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsOpenGLKHR) == sizeof(GraphicsRequirementsOpenGLKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLKHR pointer to const from a
 * GraphicsRequirementsOpenGLKHR reference to const.
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR const* get(
    GraphicsRequirementsOpenGLKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsOpenGLKHR
 * as the address of a raw XrGraphicsRequirementsOpenGLKHR
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR* put(GraphicsRequirementsOpenGLKHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrGraphicsBindingOpenGLESAndroidKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLESAndroidKHR>
 * @xrentity{XrGraphicsBindingOpenGLESAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLESAndroidKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLESAndroidKHR(EGLDisplay display_, EGLConfig config_, EGLContext context_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR, next_),
        display{display_},
        config{config_},
        context{context_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLESAndroidKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR, next_),
        display{},
        config{},
        context{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLESAndroidKHR(const GraphicsBindingOpenGLESAndroidKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLESAndroidKHR& operator=(const GraphicsBindingOpenGLESAndroidKHR& rhs) =
      default;
  //! Copy construct from raw
  GraphicsBindingOpenGLESAndroidKHR(const XrGraphicsBindingOpenGLESAndroidKHR& rhs)
      : GraphicsBindingOpenGLESAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLESAndroidKHR& operator=(const XrGraphicsBindingOpenGLESAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLESAndroidKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLESAndroidKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
  XrGraphicsBindingOpenGLESAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLESAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLESAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLESAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
};
static_assert(sizeof(XrGraphicsBindingOpenGLESAndroidKHR) ==
                  sizeof(GraphicsBindingOpenGLESAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLESAndroidKHR pointer to const from
 * a GraphicsBindingOpenGLESAndroidKHR reference to const.
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR const* get(
    GraphicsBindingOpenGLESAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsBindingOpenGLESAndroidKHR as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR* put(
    GraphicsBindingOpenGLESAndroidKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainImageOpenGLESKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLESKHR>
 * @xrentity{XrSwapchainImageOpenGLESKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageOpenGLESKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageOpenGLESKHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageOpenGLESKHR, next_) {}

  //! Default copy constructor
  SwapchainImageOpenGLESKHR(const SwapchainImageOpenGLESKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageOpenGLESKHR& operator=(const SwapchainImageOpenGLESKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageOpenGLESKHR(const XrSwapchainImageOpenGLESKHR& rhs) : SwapchainImageOpenGLESKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageOpenGLESKHR& operator=(const XrSwapchainImageOpenGLESKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageOpenGLESKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageOpenGLESKHR&() {
    return *reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageOpenGLESKHR
  XrSwapchainImageOpenGLESKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageOpenGLESKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageOpenGLESKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageOpenGLESKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageOpenGLESKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
  }
  uint32_t image;
};
static_assert(sizeof(XrSwapchainImageOpenGLESKHR) == sizeof(SwapchainImageOpenGLESKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLESKHR pointer to const from a
 * SwapchainImageOpenGLESKHR reference to const.
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR const* get(
    SwapchainImageOpenGLESKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLESKHR as
 * the address of a raw XrSwapchainImageOpenGLESKHR
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR* put(SwapchainImageOpenGLESKHR& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLESKHR as a raw,
 * pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLESKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageOpenGLESKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLESKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLESKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLESKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsOpenGLESKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsOpenGLESKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsOpenGLESKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsOpenGLESKHR(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsOpenGLESKHR& operator=(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsOpenGLESKHR(const XrGraphicsRequirementsOpenGLESKHR& rhs)
      : GraphicsRequirementsOpenGLESKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsOpenGLESKHR& operator=(const XrGraphicsRequirementsOpenGLESKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsOpenGLESKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsOpenGLESKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsOpenGLESKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLESKHR
  XrGraphicsRequirementsOpenGLESKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsOpenGLESKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsOpenGLESKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsOpenGLESKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsOpenGLESKHR) == sizeof(GraphicsRequirementsOpenGLESKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLESKHR pointer to const from a
 * GraphicsRequirementsOpenGLESKHR reference to const.
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR const* get(
    GraphicsRequirementsOpenGLESKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsRequirementsOpenGLESKHR as the address of a raw XrGraphicsRequirementsOpenGLESKHR
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR* put(GraphicsRequirementsOpenGLESKHR& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsBindingVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingVulkanKHR>
 * @xrentity{XrGraphicsBindingVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingVulkanKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingVulkanKHR(VkInstance instance_, VkPhysicalDevice physicalDevice_, VkDevice device_,
                           uint32_t queueFamilyIndex_, uint32_t queueIndex_,
                           const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingVulkanKHR, next_),
        instance{instance_},
        physicalDevice{physicalDevice_},
        device{device_},
        queueFamilyIndex{queueFamilyIndex_},
        queueIndex{queueIndex_} {}

  //! Default/empty constructor
  GraphicsBindingVulkanKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingVulkanKHR, next_),
        instance{},
        physicalDevice{},
        device{},
        queueFamilyIndex{0},
        queueIndex{0} {}

  //! Default copy constructor
  GraphicsBindingVulkanKHR(const GraphicsBindingVulkanKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingVulkanKHR& operator=(const GraphicsBindingVulkanKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingVulkanKHR(const XrGraphicsBindingVulkanKHR& rhs) : GraphicsBindingVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingVulkanKHR& operator=(const XrGraphicsBindingVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingVulkanKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingVulkanKHR&() {
    return *reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingVulkanKHR
  XrGraphicsBindingVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
  }
  VkInstance instance;
  VkPhysicalDevice physicalDevice;
  VkDevice device;
  uint32_t queueFamilyIndex;
  uint32_t queueIndex;
};
static_assert(sizeof(XrGraphicsBindingVulkanKHR) == sizeof(GraphicsBindingVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingVulkanKHR pointer to const from a
 * GraphicsBindingVulkanKHR reference to const.
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR const* get(GraphicsBindingVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingVulkanKHR as
 * the address of a raw XrGraphicsBindingVulkanKHR
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR* put(GraphicsBindingVulkanKHR& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageVulkanKHR>
 * @xrentity{XrSwapchainImageVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageVulkanKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageVulkanKHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageVulkanKHR, next_) {}

  //! Default copy constructor
  SwapchainImageVulkanKHR(const SwapchainImageVulkanKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageVulkanKHR& operator=(const SwapchainImageVulkanKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageVulkanKHR(const XrSwapchainImageVulkanKHR& rhs) : SwapchainImageVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageVulkanKHR& operator=(const XrSwapchainImageVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageVulkanKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageVulkanKHR&() {
    return *reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageVulkanKHR
  XrSwapchainImageVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
  }
  VkImage image;
};
static_assert(sizeof(XrSwapchainImageVulkanKHR) == sizeof(SwapchainImageVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageVulkanKHR pointer to const from a
 * SwapchainImageVulkanKHR reference to const.
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR const* get(SwapchainImageVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageVulkanKHR as
 * the address of a raw XrSwapchainImageVulkanKHR
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR* put(SwapchainImageVulkanKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageVulkanKHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageVulkanKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageVulkanKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsRequirementsVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsVulkanKHR>
 * @xrentity{XrGraphicsRequirementsVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsVulkanKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsVulkanKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsVulkanKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsVulkanKHR(const GraphicsRequirementsVulkanKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsVulkanKHR& operator=(const GraphicsRequirementsVulkanKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsVulkanKHR(const XrGraphicsRequirementsVulkanKHR& rhs)
      : GraphicsRequirementsVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsVulkanKHR& operator=(const XrGraphicsRequirementsVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsVulkanKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsVulkanKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsVulkanKHR
  XrGraphicsRequirementsVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsVulkanKHR) == sizeof(GraphicsRequirementsVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsVulkanKHR pointer to const from a
 * GraphicsRequirementsVulkanKHR reference to const.
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR const* get(
    GraphicsRequirementsVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsVulkanKHR
 * as the address of a raw XrGraphicsRequirementsVulkanKHR
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR* put(GraphicsRequirementsVulkanKHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsBindingD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D11KHR>
 * @xrentity{XrGraphicsBindingD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingD3D11KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingD3D11KHR(ID3D11Device* device_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D11KHR, next_), device{device_} {}

  //! Default/empty constructor
  GraphicsBindingD3D11KHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingD3D11KHR, next_), device{nullptr} {}

  //! Default copy constructor
  GraphicsBindingD3D11KHR(const GraphicsBindingD3D11KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingD3D11KHR& operator=(const GraphicsBindingD3D11KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingD3D11KHR(const XrGraphicsBindingD3D11KHR& rhs) : GraphicsBindingD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingD3D11KHR& operator=(const XrGraphicsBindingD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingD3D11KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingD3D11KHR&() {
    return *reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingD3D11KHR
  XrGraphicsBindingD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
  }
  ID3D11Device* device;
};
static_assert(sizeof(XrGraphicsBindingD3D11KHR) == sizeof(GraphicsBindingD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D11KHR pointer to const from a
 * GraphicsBindingD3D11KHR reference to const.
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR const* get(GraphicsBindingD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D11KHR as
 * the address of a raw XrGraphicsBindingD3D11KHR
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR* put(GraphicsBindingD3D11KHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrSwapchainImageD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D11KHR>
 * @xrentity{XrSwapchainImageD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageD3D11KHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageD3D11KHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageD3D11KHR, next_) {}

  //! Default copy constructor
  SwapchainImageD3D11KHR(const SwapchainImageD3D11KHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageD3D11KHR& operator=(const SwapchainImageD3D11KHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageD3D11KHR(const XrSwapchainImageD3D11KHR& rhs) : SwapchainImageD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageD3D11KHR& operator=(const XrSwapchainImageD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageD3D11KHR&() const {
    return *reinterpret_cast<const XrSwapchainImageD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageD3D11KHR&() {
    return *reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageD3D11KHR
  XrSwapchainImageD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
  }
  ID3D11Texture2D* texture;
};
static_assert(sizeof(XrSwapchainImageD3D11KHR) == sizeof(SwapchainImageD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D11KHR pointer to const from a
 * SwapchainImageD3D11KHR reference to const.
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR const* get(SwapchainImageD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D11KHR as the
 * address of a raw XrSwapchainImageD3D11KHR
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR* put(SwapchainImageD3D11KHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D11KHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D11KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageD3D11KHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsRequirementsD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D11KHR>
 * @xrentity{XrGraphicsRequirementsD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsD3D11KHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsD3D11KHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsD3D11KHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsD3D11KHR(const GraphicsRequirementsD3D11KHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsD3D11KHR& operator=(const GraphicsRequirementsD3D11KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsD3D11KHR(const XrGraphicsRequirementsD3D11KHR& rhs)
      : GraphicsRequirementsD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsD3D11KHR& operator=(const XrGraphicsRequirementsD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsD3D11KHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsD3D11KHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D11KHR
  XrGraphicsRequirementsD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
  }
  LUID adapterLuid;
  D3D_FEATURE_LEVEL minFeatureLevel;
};
static_assert(sizeof(XrGraphicsRequirementsD3D11KHR) == sizeof(GraphicsRequirementsD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D11KHR pointer to const from a
 * GraphicsRequirementsD3D11KHR reference to const.
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR const* get(
    GraphicsRequirementsD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D11KHR
 * as the address of a raw XrGraphicsRequirementsD3D11KHR
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR* put(GraphicsRequirementsD3D11KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsBindingD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D12KHR>
 * @xrentity{XrGraphicsBindingD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingD3D12KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingD3D12KHR(ID3D12Device* device_, ID3D12CommandQueue* queue_,
                          const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D12KHR, next_), device{device_}, queue{queue_} {}

  //! Default/empty constructor
  GraphicsBindingD3D12KHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingD3D12KHR, next_), device{nullptr}, queue{nullptr} {}

  //! Default copy constructor
  GraphicsBindingD3D12KHR(const GraphicsBindingD3D12KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingD3D12KHR& operator=(const GraphicsBindingD3D12KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingD3D12KHR(const XrGraphicsBindingD3D12KHR& rhs) : GraphicsBindingD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingD3D12KHR& operator=(const XrGraphicsBindingD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingD3D12KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingD3D12KHR&() {
    return *reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingD3D12KHR
  XrGraphicsBindingD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
  }
  ID3D12Device* device;
  ID3D12CommandQueue* queue;
};
static_assert(sizeof(XrGraphicsBindingD3D12KHR) == sizeof(GraphicsBindingD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D12KHR pointer to const from a
 * GraphicsBindingD3D12KHR reference to const.
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR const* get(GraphicsBindingD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D12KHR as
 * the address of a raw XrGraphicsBindingD3D12KHR
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR* put(GraphicsBindingD3D12KHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrSwapchainImageD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D12KHR>
 * @xrentity{XrSwapchainImageD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageD3D12KHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageD3D12KHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageD3D12KHR, next_) {}

  //! Default copy constructor
  SwapchainImageD3D12KHR(const SwapchainImageD3D12KHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageD3D12KHR& operator=(const SwapchainImageD3D12KHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageD3D12KHR(const XrSwapchainImageD3D12KHR& rhs) : SwapchainImageD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageD3D12KHR& operator=(const XrSwapchainImageD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageD3D12KHR&() const {
    return *reinterpret_cast<const XrSwapchainImageD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageD3D12KHR&() {
    return *reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageD3D12KHR
  XrSwapchainImageD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
  }
  ID3D12Resource* texture;
};
static_assert(sizeof(XrSwapchainImageD3D12KHR) == sizeof(SwapchainImageD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D12KHR pointer to const from a
 * SwapchainImageD3D12KHR reference to const.
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR const* get(SwapchainImageD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D12KHR as the
 * address of a raw XrSwapchainImageD3D12KHR
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR* put(SwapchainImageD3D12KHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D12KHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D12KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageD3D12KHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsRequirementsD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D12KHR>
 * @xrentity{XrGraphicsRequirementsD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsD3D12KHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsD3D12KHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsD3D12KHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsD3D12KHR(const GraphicsRequirementsD3D12KHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsD3D12KHR& operator=(const GraphicsRequirementsD3D12KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsD3D12KHR(const XrGraphicsRequirementsD3D12KHR& rhs)
      : GraphicsRequirementsD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsD3D12KHR& operator=(const XrGraphicsRequirementsD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsD3D12KHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsD3D12KHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D12KHR
  XrGraphicsRequirementsD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
  }
  LUID adapterLuid;
  D3D_FEATURE_LEVEL minFeatureLevel;
};
static_assert(sizeof(XrGraphicsRequirementsD3D12KHR) == sizeof(GraphicsRequirementsD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D12KHR pointer to const from a
 * GraphicsRequirementsD3D12KHR reference to const.
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR const* get(
    GraphicsRequirementsD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D12KHR
 * as the address of a raw XrGraphicsRequirementsD3D12KHR
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR* put(GraphicsRequirementsD3D12KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrVisibilityMaskKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskKHR>
 * @xrentity{XrVisibilityMaskKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VisibilityMaskKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  VisibilityMaskKHR(void* next_ = nullptr)

      : Parent(StructureType::VisibilityMaskKHR, next_) {}

  //! Default copy constructor
  VisibilityMaskKHR(const VisibilityMaskKHR& rhs) = default;
  //! Default copy assignment
  VisibilityMaskKHR& operator=(const VisibilityMaskKHR& rhs) = default;
  //! Copy construct from raw
  VisibilityMaskKHR(const XrVisibilityMaskKHR& rhs) : VisibilityMaskKHR() { *put() = rhs; }
  //! Copy assign from raw
  VisibilityMaskKHR& operator=(const XrVisibilityMaskKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVisibilityMaskKHR&() const {
    return *reinterpret_cast<const XrVisibilityMaskKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVisibilityMaskKHR&() { return *reinterpret_cast<XrVisibilityMaskKHR*>(this); }

  //! Accessor for this as the address of a raw XrVisibilityMaskKHR
  XrVisibilityMaskKHR const* get() const noexcept {
    return reinterpret_cast<XrVisibilityMaskKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVisibilityMaskKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVisibilityMaskKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VisibilityMaskKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVisibilityMaskKHR*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector2f* vertices;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrVisibilityMaskKHR) == sizeof(VisibilityMaskKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVisibilityMaskKHR pointer to const from a
 * VisibilityMaskKHR reference to const.
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisibilityMaskKHR const* get(VisibilityMaskKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VisibilityMaskKHR as the
 * address of a raw XrVisibilityMaskKHR
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisibilityMaskKHR* put(VisibilityMaskKHR& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrEventDataVisibilityMaskChangedKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVisibilityMaskChangedKHR>
 * @xrentity{XrEventDataVisibilityMaskChangedKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVisibilityMaskChangedKHR : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataVisibilityMaskChangedKHR(const Session& session_,
                                    const ViewConfigurationType& viewConfigurationType_,
                                    uint32_t viewIndex_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataVisibilityMaskChangedKHR, next_),
        session{session_},
        viewConfigurationType{viewConfigurationType_},
        viewIndex{viewIndex_} {}

  //! Default/empty constructor
  EventDataVisibilityMaskChangedKHR(const void* next_ = nullptr)

      : Parent(StructureType::EventDataVisibilityMaskChangedKHR, next_),
        session{},
        viewConfigurationType{},
        viewIndex{0} {}

  //! Default copy constructor
  EventDataVisibilityMaskChangedKHR(const EventDataVisibilityMaskChangedKHR& rhs) = default;
  //! Default copy assignment
  EventDataVisibilityMaskChangedKHR& operator=(const EventDataVisibilityMaskChangedKHR& rhs) =
      default;
  //! Copy construct from raw
  EventDataVisibilityMaskChangedKHR(const XrEventDataVisibilityMaskChangedKHR& rhs)
      : EventDataVisibilityMaskChangedKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVisibilityMaskChangedKHR& operator=(const XrEventDataVisibilityMaskChangedKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVisibilityMaskChangedKHR&() const {
    return *reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVisibilityMaskChangedKHR&() {
    return *reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataVisibilityMaskChangedKHR
  XrEventDataVisibilityMaskChangedKHR const* get() const noexcept {
    return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVisibilityMaskChangedKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVisibilityMaskChangedKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVisibilityMaskChangedKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
  }
  Session session;
  ViewConfigurationType viewConfigurationType;
  uint32_t viewIndex;
};
static_assert(sizeof(XrEventDataVisibilityMaskChangedKHR) ==
                  sizeof(EventDataVisibilityMaskChangedKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVisibilityMaskChangedKHR pointer to const from
 * a EventDataVisibilityMaskChangedKHR reference to const.
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR const* get(
    EventDataVisibilityMaskChangedKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVisibilityMaskChangedKHR as the address of a raw XrEventDataVisibilityMaskChangedKHR
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR* put(
    EventDataVisibilityMaskChangedKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataVisibilityMaskChangedKHR as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataVisibilityMaskChangedKHR
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataVisibilityMaskChangedKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_composition_layer_color_scale_bias
/*!
 * C++ projection of XrCompositionLayerColorScaleBiasKHR
 *
 * Provided by the `XR_KHR_composition_layer_color_scale_bias` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerColorScaleBiasKHR>
 * @xrentity{XrCompositionLayerColorScaleBiasKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerColorScaleBiasKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerColorScaleBiasKHR(const Color4f& colorScale_, const Color4f& colorBias_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerColorScaleBiasKHR, next_),
        colorScale{colorScale_},
        colorBias{colorBias_} {}

  //! Default/empty constructor
  CompositionLayerColorScaleBiasKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerColorScaleBiasKHR, next_),
        colorScale{},
        colorBias{} {}

  //! Default copy constructor
  CompositionLayerColorScaleBiasKHR(const CompositionLayerColorScaleBiasKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerColorScaleBiasKHR& operator=(const CompositionLayerColorScaleBiasKHR& rhs) =
      default;
  //! Copy construct from raw
  CompositionLayerColorScaleBiasKHR(const XrCompositionLayerColorScaleBiasKHR& rhs)
      : CompositionLayerColorScaleBiasKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerColorScaleBiasKHR& operator=(const XrCompositionLayerColorScaleBiasKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerColorScaleBiasKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerColorScaleBiasKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerColorScaleBiasKHR&() {
    return *reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerColorScaleBiasKHR
  XrCompositionLayerColorScaleBiasKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerColorScaleBiasKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerColorScaleBiasKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerColorScaleBiasKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
  }
  Color4f colorScale;
  Color4f colorBias;
};
static_assert(sizeof(XrCompositionLayerColorScaleBiasKHR) ==
                  sizeof(CompositionLayerColorScaleBiasKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerColorScaleBiasKHR pointer to const from
 * a CompositionLayerColorScaleBiasKHR reference to const.
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR const* get(
    CompositionLayerColorScaleBiasKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerColorScaleBiasKHR as the address of a raw XrCompositionLayerColorScaleBiasKHR
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR* put(
    CompositionLayerColorScaleBiasKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_composition_layer_color_scale_bias

#ifdef XR_KHR_loader_init
/*!
 * C++ projection of XrLoaderInitInfoBaseHeaderKHR
 *
 * Provided by the `XR_KHR_loader_init` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoBaseHeaderKHR>
 * @xrentity{XrLoaderInitInfoBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS LoaderInitInfoBaseHeaderKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  LoaderInitInfoBaseHeaderKHR(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLoaderInitInfoBaseHeaderKHR&() const {
    return *reinterpret_cast<const XrLoaderInitInfoBaseHeaderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLoaderInitInfoBaseHeaderKHR&() {
    return *reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrLoaderInitInfoBaseHeaderKHR
  XrLoaderInitInfoBaseHeaderKHR const* get() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
  }
};
static_assert(sizeof(XrLoaderInitInfoBaseHeaderKHR) == sizeof(LoaderInitInfoBaseHeaderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoBaseHeaderKHR pointer to const from a
 * LoaderInitInfoBaseHeaderKHR reference to const.
 * @relates LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get(
    LoaderInitInfoBaseHeaderKHR const& s) {
  return s.get();
}

#endif  // XR_KHR_loader_init

#ifdef XR_KHR_loader_init_android
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrLoaderInitInfoAndroidKHR
 *
 * Provided by the `XR_KHR_loader_init_android` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoAndroidKHR>
 * @xrentity{XrLoaderInitInfoAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LoaderInitInfoAndroidKHR : public LoaderInitInfoBaseHeaderKHR {
private:
  using Parent = LoaderInitInfoBaseHeaderKHR;

public:
  //! Constructor initializing all members.
  LoaderInitInfoAndroidKHR(void* XR_MAY_ALIAS applicationVM_,
                           void* XR_MAY_ALIAS applicationContext_, const void* next_ = nullptr)
      : Parent(StructureType::LoaderInitInfoAndroidKHR, next_),
        applicationVM{applicationVM_},
        applicationContext{applicationContext_} {}

  //! Default/empty constructor
  LoaderInitInfoAndroidKHR(const void* next_ = nullptr)

      : Parent(StructureType::LoaderInitInfoAndroidKHR, next_),
        applicationVM{nullptr},
        applicationContext{nullptr} {}

  //! Default copy constructor
  LoaderInitInfoAndroidKHR(const LoaderInitInfoAndroidKHR& rhs) = default;
  //! Default copy assignment
  LoaderInitInfoAndroidKHR& operator=(const LoaderInitInfoAndroidKHR& rhs) = default;
  //! Copy construct from raw
  LoaderInitInfoAndroidKHR(const XrLoaderInitInfoAndroidKHR& rhs) : LoaderInitInfoAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  LoaderInitInfoAndroidKHR& operator=(const XrLoaderInitInfoAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLoaderInitInfoAndroidKHR&() const {
    return *reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLoaderInitInfoAndroidKHR&() {
    return *reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
  }

  //! Accessor for this as a raw, base XrLoaderInitInfoBaseHeaderKHR const pointer
  XrLoaderInitInfoBaseHeaderKHR const* get_base() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
  }
  //! Accessor for this as the address of a raw XrLoaderInitInfoAndroidKHR
  XrLoaderInitInfoAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrLoaderInitInfoAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLoaderInitInfoAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LoaderInitInfoAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
  }
  void* XR_MAY_ALIAS applicationVM;
  void* XR_MAY_ALIAS applicationContext;
};
static_assert(sizeof(XrLoaderInitInfoAndroidKHR) == sizeof(LoaderInitInfoAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoAndroidKHR pointer to const from a
 * LoaderInitInfoAndroidKHR reference to const.
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR const* get(LoaderInitInfoAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LoaderInitInfoAndroidKHR as
 * the address of a raw XrLoaderInitInfoAndroidKHR
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR* put(LoaderInitInfoAndroidKHR& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const LoaderInitInfoAndroidKHR as a raw, pointer
 * to const XrLoaderInitInfoBaseHeaderKHR (the base type)
 * @relates LoaderInitInfoAndroidKHR
 * @relatesalso LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get_base(
    LoaderInitInfoAndroidKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_loader_init_android

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanInstanceCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanInstanceCreateInfoKHR>
 * @xrentity{XrVulkanInstanceCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanInstanceCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanInstanceCreateInfoKHR(const SystemId& systemId_,
                              const VulkanInstanceCreateFlagsKHR& createFlags_,
                              PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,
                              const VkInstanceCreateInfo* vulkanCreateInfo_,
                              const VkAllocationCallbacks* vulkanAllocator_,
                              const void* next_ = nullptr)
      : Parent(StructureType::VulkanInstanceCreateInfoKHR, next_),
        systemId{systemId_},
        createFlags{createFlags_},
        pfnGetInstanceProcAddr{pfnGetInstanceProcAddr_},
        vulkanCreateInfo{vulkanCreateInfo_},
        vulkanAllocator{vulkanAllocator_} {}

  //! Default/empty constructor
  VulkanInstanceCreateInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanInstanceCreateInfoKHR, next_),
        systemId{},
        createFlags{},
        pfnGetInstanceProcAddr{nullptr},
        vulkanCreateInfo{nullptr},
        vulkanAllocator{nullptr} {}

  //! Default copy constructor
  VulkanInstanceCreateInfoKHR(const VulkanInstanceCreateInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanInstanceCreateInfoKHR& operator=(const VulkanInstanceCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanInstanceCreateInfoKHR(const XrVulkanInstanceCreateInfoKHR& rhs)
      : VulkanInstanceCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanInstanceCreateInfoKHR& operator=(const XrVulkanInstanceCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanInstanceCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanInstanceCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanInstanceCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanInstanceCreateInfoKHR
  XrVulkanInstanceCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanInstanceCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanInstanceCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanInstanceCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanInstanceCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
  }
  SystemId systemId;
  VulkanInstanceCreateFlagsKHR createFlags;
  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
  const VkInstanceCreateInfo* vulkanCreateInfo;
  const VkAllocationCallbacks* vulkanAllocator;
};
static_assert(sizeof(XrVulkanInstanceCreateInfoKHR) == sizeof(VulkanInstanceCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanInstanceCreateInfoKHR pointer to const from a
 * VulkanInstanceCreateInfoKHR reference to const.
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR const* get(
    VulkanInstanceCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanInstanceCreateInfoKHR
 * as the address of a raw XrVulkanInstanceCreateInfoKHR
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR* put(VulkanInstanceCreateInfoKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanDeviceCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanDeviceCreateInfoKHR>
 * @xrentity{XrVulkanDeviceCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanDeviceCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanDeviceCreateInfoKHR(const SystemId& systemId_,
                            const VulkanDeviceCreateFlagsKHR& createFlags_,
                            PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,
                            VkPhysicalDevice vulkanPhysicalDevice_,
                            const VkDeviceCreateInfo* vulkanCreateInfo_,
                            const VkAllocationCallbacks* vulkanAllocator_,
                            const void* next_ = nullptr)
      : Parent(StructureType::VulkanDeviceCreateInfoKHR, next_),
        systemId{systemId_},
        createFlags{createFlags_},
        pfnGetInstanceProcAddr{pfnGetInstanceProcAddr_},
        vulkanPhysicalDevice{vulkanPhysicalDevice_},
        vulkanCreateInfo{vulkanCreateInfo_},
        vulkanAllocator{vulkanAllocator_} {}

  //! Default/empty constructor
  VulkanDeviceCreateInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanDeviceCreateInfoKHR, next_),
        systemId{},
        createFlags{},
        pfnGetInstanceProcAddr{nullptr},
        vulkanPhysicalDevice{},
        vulkanCreateInfo{nullptr},
        vulkanAllocator{nullptr} {}

  //! Default copy constructor
  VulkanDeviceCreateInfoKHR(const VulkanDeviceCreateInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanDeviceCreateInfoKHR& operator=(const VulkanDeviceCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanDeviceCreateInfoKHR(const XrVulkanDeviceCreateInfoKHR& rhs) : VulkanDeviceCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanDeviceCreateInfoKHR& operator=(const XrVulkanDeviceCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanDeviceCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanDeviceCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanDeviceCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanDeviceCreateInfoKHR
  XrVulkanDeviceCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanDeviceCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanDeviceCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanDeviceCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanDeviceCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
  }
  SystemId systemId;
  VulkanDeviceCreateFlagsKHR createFlags;
  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
  VkPhysicalDevice vulkanPhysicalDevice;
  const VkDeviceCreateInfo* vulkanCreateInfo;
  const VkAllocationCallbacks* vulkanAllocator;
};
static_assert(sizeof(XrVulkanDeviceCreateInfoKHR) == sizeof(VulkanDeviceCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanDeviceCreateInfoKHR pointer to const from a
 * VulkanDeviceCreateInfoKHR reference to const.
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR const* get(
    VulkanDeviceCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanDeviceCreateInfoKHR as
 * the address of a raw XrVulkanDeviceCreateInfoKHR
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR* put(VulkanDeviceCreateInfoKHR& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanGraphicsDeviceGetInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanGraphicsDeviceGetInfoKHR>
 * @xrentity{XrVulkanGraphicsDeviceGetInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanGraphicsDeviceGetInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanGraphicsDeviceGetInfoKHR(const SystemId& systemId_, VkInstance vulkanInstance_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR, next_),
        systemId{systemId_},
        vulkanInstance{vulkanInstance_} {}

  //! Default/empty constructor
  VulkanGraphicsDeviceGetInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR, next_),
        systemId{},
        vulkanInstance{} {}

  //! Default copy constructor
  VulkanGraphicsDeviceGetInfoKHR(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanGraphicsDeviceGetInfoKHR& operator=(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanGraphicsDeviceGetInfoKHR(const XrVulkanGraphicsDeviceGetInfoKHR& rhs)
      : VulkanGraphicsDeviceGetInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanGraphicsDeviceGetInfoKHR& operator=(const XrVulkanGraphicsDeviceGetInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanGraphicsDeviceGetInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanGraphicsDeviceGetInfoKHR&() {
    return *reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
  XrVulkanGraphicsDeviceGetInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanGraphicsDeviceGetInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanGraphicsDeviceGetInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanGraphicsDeviceGetInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }
  SystemId systemId;
  VkInstance vulkanInstance;
};
static_assert(sizeof(XrVulkanGraphicsDeviceGetInfoKHR) == sizeof(VulkanGraphicsDeviceGetInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanGraphicsDeviceGetInfoKHR pointer to const from a
 * VulkanGraphicsDeviceGetInfoKHR reference to const.
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR const* get(
    VulkanGraphicsDeviceGetInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VulkanGraphicsDeviceGetInfoKHR as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR* put(VulkanGraphicsDeviceGetInfoKHR& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_composition_layer_equirect2
/*!
 * C++ projection of XrCompositionLayerEquirect2KHR
 *
 * Provided by the `XR_KHR_composition_layer_equirect2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirect2KHR>
 * @xrentity{XrCompositionLayerEquirect2KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerEquirect2KHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerEquirect2KHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                               const EyeVisibility& eyeVisibility_,
                               const SwapchainSubImage& subImage_, const Posef& pose_,
                               float radius_, float centralHorizontalAngle_,
                               float upperVerticalAngle_, float lowerVerticalAngle_,
                               const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirect2KHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        centralHorizontalAngle{centralHorizontalAngle_},
        upperVerticalAngle{upperVerticalAngle_},
        lowerVerticalAngle{lowerVerticalAngle_} {}

  //! Default/empty constructor
  CompositionLayerEquirect2KHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerEquirect2KHR, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        radius{0.0f},
        centralHorizontalAngle{0.0f},
        upperVerticalAngle{0.0f},
        lowerVerticalAngle{0.0f} {}

  //! Default copy constructor
  CompositionLayerEquirect2KHR(const CompositionLayerEquirect2KHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerEquirect2KHR& operator=(const CompositionLayerEquirect2KHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerEquirect2KHR(const XrCompositionLayerEquirect2KHR& rhs)
      : CompositionLayerEquirect2KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerEquirect2KHR& operator=(const XrCompositionLayerEquirect2KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerEquirect2KHR&() const {
    return *reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerEquirect2KHR&() {
    return *reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerEquirect2KHR
  XrCompositionLayerEquirect2KHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerEquirect2KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerEquirect2KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerEquirect2KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerEquirect2KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  float centralHorizontalAngle;
  float upperVerticalAngle;
  float lowerVerticalAngle;
};
static_assert(sizeof(XrCompositionLayerEquirect2KHR) == sizeof(CompositionLayerEquirect2KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirect2KHR pointer to const from a
 * CompositionLayerEquirect2KHR reference to const.
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR const* get(
    CompositionLayerEquirect2KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirect2KHR
 * as the address of a raw XrCompositionLayerEquirect2KHR
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR* put(CompositionLayerEquirect2KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirect2KHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirect2KHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerEquirect2KHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_equirect2

#ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationBaseHeaderKHR
 *
 * Provided by the `XR_KHR_binding_modification` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationBaseHeaderKHR>
 * @xrentity{XrBindingModificationBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS BindingModificationBaseHeaderKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  BindingModificationBaseHeaderKHR(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBindingModificationBaseHeaderKHR&() const {
    return *reinterpret_cast<const XrBindingModificationBaseHeaderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBindingModificationBaseHeaderKHR&() {
    return *reinterpret_cast<XrBindingModificationBaseHeaderKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrBindingModificationBaseHeaderKHR
  XrBindingModificationBaseHeaderKHR const* get() const noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
  }
};
static_assert(sizeof(XrBindingModificationBaseHeaderKHR) ==
                  sizeof(BindingModificationBaseHeaderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBindingModificationBaseHeaderKHR pointer to const from a
 * BindingModificationBaseHeaderKHR reference to const.
 * @relates BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get(
    BindingModificationBaseHeaderKHR const& s) {
  return s.get();
}

#endif  // XR_KHR_binding_modification

#ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationsKHR
 *
 * Provided by the `XR_KHR_binding_modification` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationsKHR>
 * @xrentity{XrBindingModificationsKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BindingModificationsKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BindingModificationsKHR(uint32_t bindingModificationCount_,
                          const BindingModificationBaseHeaderKHR* const* bindingModifications_,
                          const void* next_ = nullptr)
      : Parent(StructureType::BindingModificationsKHR, next_),
        bindingModificationCount{bindingModificationCount_},
        bindingModifications{bindingModifications_} {}

  //! Default/empty constructor
  BindingModificationsKHR(const void* next_ = nullptr)

      : Parent(StructureType::BindingModificationsKHR, next_),
        bindingModificationCount{0},
        bindingModifications{nullptr} {}

  //! Default copy constructor
  BindingModificationsKHR(const BindingModificationsKHR& rhs) = default;
  //! Default copy assignment
  BindingModificationsKHR& operator=(const BindingModificationsKHR& rhs) = default;
  //! Copy construct from raw
  BindingModificationsKHR(const XrBindingModificationsKHR& rhs) : BindingModificationsKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BindingModificationsKHR& operator=(const XrBindingModificationsKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBindingModificationsKHR&() const {
    return *reinterpret_cast<const XrBindingModificationsKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBindingModificationsKHR&() {
    return *reinterpret_cast<XrBindingModificationsKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrBindingModificationsKHR
  XrBindingModificationsKHR const* get() const noexcept {
    return reinterpret_cast<XrBindingModificationsKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBindingModificationsKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBindingModificationsKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BindingModificationsKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrBindingModificationsKHR*>(this);
  }
  uint32_t bindingModificationCount;
  const BindingModificationBaseHeaderKHR* const* bindingModifications;
};
static_assert(sizeof(XrBindingModificationsKHR) == sizeof(BindingModificationsKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBindingModificationsKHR pointer to const from a
 * BindingModificationsKHR reference to const.
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationsKHR const* get(BindingModificationsKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BindingModificationsKHR as
 * the address of a raw XrBindingModificationsKHR
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationsKHR* put(BindingModificationsKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_binding_modification

#ifdef XR_EXT_performance_settings
/*!
 * C++ projection of XrEventDataPerfSettingsEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPerfSettingsEXT>
 * @xrentity{XrEventDataPerfSettingsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataPerfSettingsEXT : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataPerfSettingsEXT(const PerfSettingsDomainEXT& domain_,
                           const PerfSettingsSubDomainEXT& subDomain_,
                           const PerfSettingsNotificationLevelEXT& fromLevel_,
                           const PerfSettingsNotificationLevelEXT& toLevel_,
                           const void* next_ = nullptr)
      : Parent(StructureType::EventDataPerfSettingsEXT, next_),
        domain{domain_},
        subDomain{subDomain_},
        fromLevel{fromLevel_},
        toLevel{toLevel_} {}

  //! Default/empty constructor
  EventDataPerfSettingsEXT(const void* next_ = nullptr)

      : Parent(StructureType::EventDataPerfSettingsEXT, next_),
        domain{},
        subDomain{},
        fromLevel{},
        toLevel{} {}

  //! Default copy constructor
  EventDataPerfSettingsEXT(const EventDataPerfSettingsEXT& rhs) = default;
  //! Default copy assignment
  EventDataPerfSettingsEXT& operator=(const EventDataPerfSettingsEXT& rhs) = default;
  //! Copy construct from raw
  EventDataPerfSettingsEXT(const XrEventDataPerfSettingsEXT& rhs) : EventDataPerfSettingsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataPerfSettingsEXT& operator=(const XrEventDataPerfSettingsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataPerfSettingsEXT&() const {
    return *reinterpret_cast<const XrEventDataPerfSettingsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataPerfSettingsEXT&() {
    return *reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataPerfSettingsEXT
  XrEventDataPerfSettingsEXT const* get() const noexcept {
    return reinterpret_cast<XrEventDataPerfSettingsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataPerfSettingsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataPerfSettingsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataPerfSettingsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
  }
  PerfSettingsDomainEXT domain;
  PerfSettingsSubDomainEXT subDomain;
  PerfSettingsNotificationLevelEXT fromLevel;
  PerfSettingsNotificationLevelEXT toLevel;
};
static_assert(sizeof(XrEventDataPerfSettingsEXT) == sizeof(EventDataPerfSettingsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataPerfSettingsEXT pointer to const from a
 * EventDataPerfSettingsEXT reference to const.
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT const* get(EventDataPerfSettingsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataPerfSettingsEXT as
 * the address of a raw XrEventDataPerfSettingsEXT
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT* put(EventDataPerfSettingsEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataPerfSettingsEXT as a raw, pointer
 * to const XrEventDataBaseHeader (the base type)
 * @relates EventDataPerfSettingsEXT
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataPerfSettingsEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsObjectNameInfoEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsObjectNameInfoEXT>
 * @xrentity{XrDebugUtilsObjectNameInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsObjectNameInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsObjectNameInfoEXT(const ObjectType& objectType_, uint64_t objectHandle_,
                              const char* objectName_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsObjectNameInfoEXT, next_),
        objectType{objectType_},
        objectHandle{objectHandle_},
        objectName{objectName_} {}

  //! Default/empty constructor
  DebugUtilsObjectNameInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsObjectNameInfoEXT, next_),
        objectType{},
        objectHandle{0},
        objectName{nullptr} {}

  //! Default copy constructor
  DebugUtilsObjectNameInfoEXT(const DebugUtilsObjectNameInfoEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsObjectNameInfoEXT& operator=(const DebugUtilsObjectNameInfoEXT& rhs) = default;
  //! Copy construct from raw
  DebugUtilsObjectNameInfoEXT(const XrDebugUtilsObjectNameInfoEXT& rhs)
      : DebugUtilsObjectNameInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsObjectNameInfoEXT& operator=(const XrDebugUtilsObjectNameInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsObjectNameInfoEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsObjectNameInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsObjectNameInfoEXT&() {
    return *reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsObjectNameInfoEXT
  XrDebugUtilsObjectNameInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsObjectNameInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsObjectNameInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsObjectNameInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
  }
  ObjectType objectType;
  uint64_t objectHandle;
  const char* objectName;
};
static_assert(sizeof(XrDebugUtilsObjectNameInfoEXT) == sizeof(DebugUtilsObjectNameInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsObjectNameInfoEXT pointer to const from a
 * DebugUtilsObjectNameInfoEXT reference to const.
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT const* get(
    DebugUtilsObjectNameInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsObjectNameInfoEXT
 * as the address of a raw XrDebugUtilsObjectNameInfoEXT
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT* put(DebugUtilsObjectNameInfoEXT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsLabelEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsLabelEXT>
 * @xrentity{XrDebugUtilsLabelEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsLabelEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsLabelEXT(const char* labelName_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsLabelEXT, next_), labelName{labelName_} {}

  //! Default/empty constructor
  DebugUtilsLabelEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsLabelEXT, next_), labelName{nullptr} {}

  //! Default copy constructor
  DebugUtilsLabelEXT(const DebugUtilsLabelEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsLabelEXT& operator=(const DebugUtilsLabelEXT& rhs) = default;
  //! Copy construct from raw
  DebugUtilsLabelEXT(const XrDebugUtilsLabelEXT& rhs) : DebugUtilsLabelEXT() { *put() = rhs; }
  //! Copy assign from raw
  DebugUtilsLabelEXT& operator=(const XrDebugUtilsLabelEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsLabelEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsLabelEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsLabelEXT&() { return *reinterpret_cast<XrDebugUtilsLabelEXT*>(this); }

  //! Accessor for this as the address of a raw XrDebugUtilsLabelEXT
  XrDebugUtilsLabelEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsLabelEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsLabelEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsLabelEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsLabelEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsLabelEXT*>(this);
  }
  const char* labelName;
};
static_assert(sizeof(XrDebugUtilsLabelEXT) == sizeof(DebugUtilsLabelEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsLabelEXT pointer to const from a
 * DebugUtilsLabelEXT reference to const.
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT const* get(DebugUtilsLabelEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsLabelEXT as the
 * address of a raw XrDebugUtilsLabelEXT
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT* put(DebugUtilsLabelEXT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCallbackDataEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCallbackDataEXT>
 * @xrentity{XrDebugUtilsMessengerCallbackDataEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsMessengerCallbackDataEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsMessengerCallbackDataEXT(const char* messageId_, const char* functionName_,
                                     const char* message_, uint32_t objectCount_,
                                     DebugUtilsObjectNameInfoEXT* objects_,
                                     uint32_t sessionLabelCount_,
                                     DebugUtilsLabelEXT* sessionLabels_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCallbackDataEXT, next_),
        messageId{messageId_},
        functionName{functionName_},
        message{message_},
        objectCount{objectCount_},
        objects{objects_},
        sessionLabelCount{sessionLabelCount_},
        sessionLabels{sessionLabels_} {}

  //! Default/empty constructor
  DebugUtilsMessengerCallbackDataEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsMessengerCallbackDataEXT, next_),
        messageId{nullptr},
        functionName{nullptr},
        message{nullptr},
        objectCount{0},
        objects{nullptr},
        sessionLabelCount{0},
        sessionLabels{nullptr} {}

  //! Default copy constructor
  DebugUtilsMessengerCallbackDataEXT(const DebugUtilsMessengerCallbackDataEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsMessengerCallbackDataEXT& operator=(const DebugUtilsMessengerCallbackDataEXT& rhs) =
      default;
  //! Copy construct from raw
  DebugUtilsMessengerCallbackDataEXT(const XrDebugUtilsMessengerCallbackDataEXT& rhs)
      : DebugUtilsMessengerCallbackDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsMessengerCallbackDataEXT& operator=(const XrDebugUtilsMessengerCallbackDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsMessengerCallbackDataEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsMessengerCallbackDataEXT&() {
    return *reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
  XrDebugUtilsMessengerCallbackDataEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsMessengerCallbackDataEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsMessengerCallbackDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsMessengerCallbackDataEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }
  const char* messageId;
  const char* functionName;
  const char* message;
  uint32_t objectCount;
  DebugUtilsObjectNameInfoEXT* objects;
  uint32_t sessionLabelCount;
  DebugUtilsLabelEXT* sessionLabels;
};
static_assert(sizeof(XrDebugUtilsMessengerCallbackDataEXT) ==
                  sizeof(DebugUtilsMessengerCallbackDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCallbackDataEXT pointer to const from
 * a DebugUtilsMessengerCallbackDataEXT reference to const.
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT const* get(
    DebugUtilsMessengerCallbackDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * DebugUtilsMessengerCallbackDataEXT as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT* put(
    DebugUtilsMessengerCallbackDataEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCreateInfoEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCreateInfoEXT>
 * @xrentity{XrDebugUtilsMessengerCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsMessengerCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessageSeverityFlagsEXT& messageSeverities_,
                                   const DebugUtilsMessageTypeFlagsEXT& messageTypes_,
                                   PFN_xrDebugUtilsMessengerCallbackEXT userCallback_,
                                   void* XR_MAY_ALIAS userData_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCreateInfoEXT, next_),
        messageSeverities{messageSeverities_},
        messageTypes{messageTypes_},
        userCallback{userCallback_},
        userData{userData_} {}

  //! Default/empty constructor
  DebugUtilsMessengerCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsMessengerCreateInfoEXT, next_),
        messageSeverities{},
        messageTypes{},
        userCallback{nullptr},
        userData{nullptr} {}

  //! Default copy constructor
  DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessengerCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsMessengerCreateInfoEXT& operator=(const DebugUtilsMessengerCreateInfoEXT& rhs) =
      default;
  //! Copy construct from raw
  DebugUtilsMessengerCreateInfoEXT(const XrDebugUtilsMessengerCreateInfoEXT& rhs)
      : DebugUtilsMessengerCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsMessengerCreateInfoEXT& operator=(const XrDebugUtilsMessengerCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsMessengerCreateInfoEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsMessengerCreateInfoEXT&() {
    return *reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
  XrDebugUtilsMessengerCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsMessengerCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsMessengerCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsMessengerCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }
  DebugUtilsMessageSeverityFlagsEXT messageSeverities;
  DebugUtilsMessageTypeFlagsEXT messageTypes;
  PFN_xrDebugUtilsMessengerCallbackEXT userCallback;
  void* XR_MAY_ALIAS userData;
};
static_assert(sizeof(XrDebugUtilsMessengerCreateInfoEXT) ==
                  sizeof(DebugUtilsMessengerCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCreateInfoEXT pointer to const from a
 * DebugUtilsMessengerCreateInfoEXT reference to const.
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT const* get(
    DebugUtilsMessengerCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * DebugUtilsMessengerCreateInfoEXT as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT* put(
    DebugUtilsMessengerCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrSystemEyeGazeInteractionPropertiesEXT
 *
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEyeGazeInteractionPropertiesEXT>
 * @xrentity{XrSystemEyeGazeInteractionPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemEyeGazeInteractionPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemEyeGazeInteractionPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::SystemEyeGazeInteractionPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemEyeGazeInteractionPropertiesEXT(const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemEyeGazeInteractionPropertiesEXT& operator=(
      const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemEyeGazeInteractionPropertiesEXT(const XrSystemEyeGazeInteractionPropertiesEXT& rhs)
      : SystemEyeGazeInteractionPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemEyeGazeInteractionPropertiesEXT& operator=(
      const XrSystemEyeGazeInteractionPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemEyeGazeInteractionPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemEyeGazeInteractionPropertiesEXT&() {
    return *reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemEyeGazeInteractionPropertiesEXT
  XrSystemEyeGazeInteractionPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemEyeGazeInteractionPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemEyeGazeInteractionPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemEyeGazeInteractionPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }
  Bool32 supportsEyeGazeInteraction;
};
static_assert(sizeof(XrSystemEyeGazeInteractionPropertiesEXT) ==
                  sizeof(SystemEyeGazeInteractionPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemEyeGazeInteractionPropertiesEXT pointer to const
 * from a SystemEyeGazeInteractionPropertiesEXT reference to const.
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT const* get(
    SystemEyeGazeInteractionPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemEyeGazeInteractionPropertiesEXT as the address of a raw
 * XrSystemEyeGazeInteractionPropertiesEXT
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT* put(
    SystemEyeGazeInteractionPropertiesEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_eye_gaze_interaction

#ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrEyeGazeSampleTimeEXT
 *
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazeSampleTimeEXT>
 * @xrentity{XrEyeGazeSampleTimeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EyeGazeSampleTimeEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EyeGazeSampleTimeEXT(void* next_ = nullptr)

      : Parent(StructureType::EyeGazeSampleTimeEXT, next_) {}

  //! Default copy constructor
  EyeGazeSampleTimeEXT(const EyeGazeSampleTimeEXT& rhs) = default;
  //! Default copy assignment
  EyeGazeSampleTimeEXT& operator=(const EyeGazeSampleTimeEXT& rhs) = default;
  //! Copy construct from raw
  EyeGazeSampleTimeEXT(const XrEyeGazeSampleTimeEXT& rhs) : EyeGazeSampleTimeEXT() { *put() = rhs; }
  //! Copy assign from raw
  EyeGazeSampleTimeEXT& operator=(const XrEyeGazeSampleTimeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeGazeSampleTimeEXT&() const {
    return *reinterpret_cast<const XrEyeGazeSampleTimeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeGazeSampleTimeEXT&() { return *reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this); }

  //! Accessor for this as the address of a raw XrEyeGazeSampleTimeEXT
  XrEyeGazeSampleTimeEXT const* get() const noexcept {
    return reinterpret_cast<XrEyeGazeSampleTimeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazeSampleTimeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEyeGazeSampleTimeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EyeGazeSampleTimeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this);
  }
  Time time;
};
static_assert(sizeof(XrEyeGazeSampleTimeEXT) == sizeof(EyeGazeSampleTimeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeGazeSampleTimeEXT pointer to const from a
 * EyeGazeSampleTimeEXT reference to const.
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT const* get(EyeGazeSampleTimeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazeSampleTimeEXT as the
 * address of a raw XrEyeGazeSampleTimeEXT
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT* put(EyeGazeSampleTimeEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_eye_gaze_interaction

#ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrSessionCreateInfoOverlayEXTX
 *
 * Provided by the `XR_EXTX_overlay` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfoOverlayEXTX>
 * @xrentity{XrSessionCreateInfoOverlayEXTX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionCreateInfoOverlayEXTX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionCreateInfoOverlayEXTX(const OverlaySessionCreateFlagsEXTX& createFlags_,
                               uint32_t sessionLayersPlacement_, const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfoOverlayEXTX, next_),
        createFlags{createFlags_},
        sessionLayersPlacement{sessionLayersPlacement_} {}

  //! Default/empty constructor
  SessionCreateInfoOverlayEXTX(const void* next_ = nullptr)

      : Parent(StructureType::SessionCreateInfoOverlayEXTX, next_),
        createFlags{},
        sessionLayersPlacement{0} {}

  //! Default copy constructor
  SessionCreateInfoOverlayEXTX(const SessionCreateInfoOverlayEXTX& rhs) = default;
  //! Default copy assignment
  SessionCreateInfoOverlayEXTX& operator=(const SessionCreateInfoOverlayEXTX& rhs) = default;
  //! Copy construct from raw
  SessionCreateInfoOverlayEXTX(const XrSessionCreateInfoOverlayEXTX& rhs)
      : SessionCreateInfoOverlayEXTX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SessionCreateInfoOverlayEXTX& operator=(const XrSessionCreateInfoOverlayEXTX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionCreateInfoOverlayEXTX&() const {
    return *reinterpret_cast<const XrSessionCreateInfoOverlayEXTX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionCreateInfoOverlayEXTX&() {
    return *reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
  }

  //! Accessor for this as the address of a raw XrSessionCreateInfoOverlayEXTX
  XrSessionCreateInfoOverlayEXTX const* get() const noexcept {
    return reinterpret_cast<XrSessionCreateInfoOverlayEXTX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSessionCreateInfoOverlayEXTX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionCreateInfoOverlayEXTX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionCreateInfoOverlayEXTX{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
  }
  OverlaySessionCreateFlagsEXTX createFlags;
  uint32_t sessionLayersPlacement;
};
static_assert(sizeof(XrSessionCreateInfoOverlayEXTX) == sizeof(SessionCreateInfoOverlayEXTX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionCreateInfoOverlayEXTX pointer to const from a
 * SessionCreateInfoOverlayEXTX reference to const.
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX const* get(
    SessionCreateInfoOverlayEXTX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfoOverlayEXTX
 * as the address of a raw XrSessionCreateInfoOverlayEXTX
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX* put(SessionCreateInfoOverlayEXTX& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXTX_overlay

#ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrEventDataMainSessionVisibilityChangedEXTX
 *
 * Provided by the `XR_EXTX_overlay` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMainSessionVisibilityChangedEXTX>
 * @xrentity{XrEventDataMainSessionVisibilityChangedEXTX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataMainSessionVisibilityChangedEXTX : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataMainSessionVisibilityChangedEXTX(const Bool32& visible_,
                                            const OverlayMainSessionFlagsEXTX& flags_,
                                            const void* next_ = nullptr)
      : Parent(StructureType::EventDataMainSessionVisibilityChangedEXTX, next_),
        visible{visible_},
        flags{flags_} {}

  //! Default/empty constructor
  EventDataMainSessionVisibilityChangedEXTX(const void* next_ = nullptr)

      : Parent(StructureType::EventDataMainSessionVisibilityChangedEXTX, next_),
        visible{false},
        flags{} {}

  //! Default copy constructor
  EventDataMainSessionVisibilityChangedEXTX(const EventDataMainSessionVisibilityChangedEXTX& rhs) =
      default;
  //! Default copy assignment
  EventDataMainSessionVisibilityChangedEXTX& operator=(
      const EventDataMainSessionVisibilityChangedEXTX& rhs) = default;
  //! Copy construct from raw
  EventDataMainSessionVisibilityChangedEXTX(const XrEventDataMainSessionVisibilityChangedEXTX& rhs)
      : EventDataMainSessionVisibilityChangedEXTX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataMainSessionVisibilityChangedEXTX& operator=(
      const XrEventDataMainSessionVisibilityChangedEXTX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataMainSessionVisibilityChangedEXTX&() const {
    return *reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataMainSessionVisibilityChangedEXTX&() {
    return *reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataMainSessionVisibilityChangedEXTX
  XrEventDataMainSessionVisibilityChangedEXTX const* get() const noexcept {
    return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataMainSessionVisibilityChangedEXTX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataMainSessionVisibilityChangedEXTX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataMainSessionVisibilityChangedEXTX{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }
  Bool32 visible;
  OverlayMainSessionFlagsEXTX flags;
};
static_assert(sizeof(XrEventDataMainSessionVisibilityChangedEXTX) ==
                  sizeof(EventDataMainSessionVisibilityChangedEXTX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataMainSessionVisibilityChangedEXTX pointer to
 * const from a EventDataMainSessionVisibilityChangedEXTX reference to const.
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX const* get(
    EventDataMainSessionVisibilityChangedEXTX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataMainSessionVisibilityChangedEXTX as the address of a raw
 * XrEventDataMainSessionVisibilityChangedEXTX
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX* put(
    EventDataMainSessionVisibilityChangedEXTX& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataMainSessionVisibilityChangedEXTX
 * as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataMainSessionVisibilityChangedEXTX const& h) {
  return h.get_base();
}
#endif  // XR_EXTX_overlay

#ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoMSFT(const Space& space_, const Posef& pose_, const Time& time_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoMSFT, next_),
        space{space_},
        pose{pose_},
        time{time_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateInfoMSFT, next_), space{}, pose{}, time{} {}

  //! Default copy constructor
  SpatialAnchorCreateInfoMSFT(const SpatialAnchorCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoMSFT& operator=(const SpatialAnchorCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoMSFT(const XrSpatialAnchorCreateInfoMSFT& rhs)
      : SpatialAnchorCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoMSFT& operator=(const XrSpatialAnchorCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoMSFT
  XrSpatialAnchorCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
  }
  Space space;
  Posef pose;
  Time time;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoMSFT) == sizeof(SpatialAnchorCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoMSFT pointer to const from a
 * SpatialAnchorCreateInfoMSFT reference to const.
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT const* get(
    SpatialAnchorCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoMSFT
 * as the address of a raw XrSpatialAnchorCreateInfoMSFT
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT* put(SpatialAnchorCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorSpaceCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorMSFT& anchor_,
                                   const Posef& poseInAnchorSpace_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT, next_),
        anchor{anchor_},
        poseInAnchorSpace{poseInAnchorSpace_} {}

  //! Default/empty constructor
  SpatialAnchorSpaceCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT, next_),
        anchor{},
        poseInAnchorSpace{} {}

  //! Default copy constructor
  SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorSpaceCreateInfoMSFT& operator=(const SpatialAnchorSpaceCreateInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorSpaceCreateInfoMSFT(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs)
      : SpatialAnchorSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorSpaceCreateInfoMSFT& operator=(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
  XrSpatialAnchorSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }
  SpatialAnchorMSFT anchor;
  Posef poseInAnchorSpace;
};
static_assert(sizeof(XrSpatialAnchorSpaceCreateInfoMSFT) ==
                  sizeof(SpatialAnchorSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorSpaceCreateInfoMSFT pointer to const from a
 * SpatialAnchorSpaceCreateInfoMSFT reference to const.
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT const* get(
    SpatialAnchorSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorSpaceCreateInfoMSFT as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT* put(
    SpatialAnchorSpaceCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_FB_composition_layer_image_layout
/*!
 * C++ projection of XrCompositionLayerImageLayoutFB
 *
 * Provided by the `XR_FB_composition_layer_image_layout` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerImageLayoutFB>
 * @xrentity{XrCompositionLayerImageLayoutFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerImageLayoutFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CompositionLayerImageLayoutFB(void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerImageLayoutFB, next_) {}

  //! Default copy constructor
  CompositionLayerImageLayoutFB(const CompositionLayerImageLayoutFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerImageLayoutFB& operator=(const CompositionLayerImageLayoutFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerImageLayoutFB(const XrCompositionLayerImageLayoutFB& rhs)
      : CompositionLayerImageLayoutFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerImageLayoutFB& operator=(const XrCompositionLayerImageLayoutFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerImageLayoutFB&() const {
    return *reinterpret_cast<const XrCompositionLayerImageLayoutFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerImageLayoutFB&() {
    return *reinterpret_cast<XrCompositionLayerImageLayoutFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerImageLayoutFB
  XrCompositionLayerImageLayoutFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerImageLayoutFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerImageLayoutFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerImageLayoutFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerImageLayoutFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerImageLayoutFB*>(this);
  }
  CompositionLayerImageLayoutFlagsFB flags;
};
static_assert(sizeof(XrCompositionLayerImageLayoutFB) == sizeof(CompositionLayerImageLayoutFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerImageLayoutFB pointer to const from a
 * CompositionLayerImageLayoutFB reference to const.
 * @relates CompositionLayerImageLayoutFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerImageLayoutFB const* get(
    CompositionLayerImageLayoutFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerImageLayoutFB
 * as the address of a raw XrCompositionLayerImageLayoutFB
 * @relates CompositionLayerImageLayoutFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerImageLayoutFB* put(CompositionLayerImageLayoutFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_image_layout

#ifdef XR_FB_composition_layer_alpha_blend
/*!
 * C++ projection of XrCompositionLayerAlphaBlendFB
 *
 * Provided by the `XR_FB_composition_layer_alpha_blend` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerAlphaBlendFB>
 * @xrentity{XrCompositionLayerAlphaBlendFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerAlphaBlendFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CompositionLayerAlphaBlendFB(void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerAlphaBlendFB, next_) {}

  //! Default copy constructor
  CompositionLayerAlphaBlendFB(const CompositionLayerAlphaBlendFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerAlphaBlendFB& operator=(const CompositionLayerAlphaBlendFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerAlphaBlendFB(const XrCompositionLayerAlphaBlendFB& rhs)
      : CompositionLayerAlphaBlendFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerAlphaBlendFB& operator=(const XrCompositionLayerAlphaBlendFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerAlphaBlendFB&() const {
    return *reinterpret_cast<const XrCompositionLayerAlphaBlendFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerAlphaBlendFB&() {
    return *reinterpret_cast<XrCompositionLayerAlphaBlendFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerAlphaBlendFB
  XrCompositionLayerAlphaBlendFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerAlphaBlendFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerAlphaBlendFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerAlphaBlendFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerAlphaBlendFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerAlphaBlendFB*>(this);
  }
  BlendFactorFB srcFactorColor;
  BlendFactorFB dstFactorColor;
  BlendFactorFB srcFactorAlpha;
  BlendFactorFB dstFactorAlpha;
};
static_assert(sizeof(XrCompositionLayerAlphaBlendFB) == sizeof(CompositionLayerAlphaBlendFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerAlphaBlendFB pointer to const from a
 * CompositionLayerAlphaBlendFB reference to const.
 * @relates CompositionLayerAlphaBlendFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerAlphaBlendFB const* get(
    CompositionLayerAlphaBlendFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerAlphaBlendFB
 * as the address of a raw XrCompositionLayerAlphaBlendFB
 * @relates CompositionLayerAlphaBlendFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerAlphaBlendFB* put(CompositionLayerAlphaBlendFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_alpha_blend

#ifdef XR_EXT_view_configuration_depth_range
/*!
 * C++ projection of XrViewConfigurationDepthRangeEXT
 *
 * Provided by the `XR_EXT_view_configuration_depth_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationDepthRangeEXT>
 * @xrentity{XrViewConfigurationDepthRangeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationDepthRangeEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationDepthRangeEXT(void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationDepthRangeEXT, next_) {}

  //! Default copy constructor
  ViewConfigurationDepthRangeEXT(const ViewConfigurationDepthRangeEXT& rhs) = default;
  //! Default copy assignment
  ViewConfigurationDepthRangeEXT& operator=(const ViewConfigurationDepthRangeEXT& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationDepthRangeEXT(const XrViewConfigurationDepthRangeEXT& rhs)
      : ViewConfigurationDepthRangeEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationDepthRangeEXT& operator=(const XrViewConfigurationDepthRangeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationDepthRangeEXT&() const {
    return *reinterpret_cast<const XrViewConfigurationDepthRangeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationDepthRangeEXT&() {
    return *reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationDepthRangeEXT
  XrViewConfigurationDepthRangeEXT const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationDepthRangeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationDepthRangeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationDepthRangeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationDepthRangeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
  }
  float recommendedNearZ;
  float minNearZ;
  float recommendedFarZ;
  float maxFarZ;
};
static_assert(sizeof(XrViewConfigurationDepthRangeEXT) == sizeof(ViewConfigurationDepthRangeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationDepthRangeEXT pointer to const from a
 * ViewConfigurationDepthRangeEXT reference to const.
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT const* get(
    ViewConfigurationDepthRangeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ViewConfigurationDepthRangeEXT as the address of a raw XrViewConfigurationDepthRangeEXT
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT* put(ViewConfigurationDepthRangeEXT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_view_configuration_depth_range

#ifdef XR_MNDX_egl_enable
#if defined(XR_USE_PLATFORM_EGL)
/*!
 * C++ projection of XrGraphicsBindingEGLMNDX
 *
 * Provided by the `XR_MNDX_egl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingEGLMNDX>
 * @xrentity{XrGraphicsBindingEGLMNDX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingEGLMNDX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingEGLMNDX(PFNEGLGETPROCADDRESSPROC getProcAddress_, EGLDisplay display_,
                         EGLConfig config_, EGLContext context_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingEGLMNDX, next_),
        getProcAddress{getProcAddress_},
        display{display_},
        config{config_},
        context{context_} {}

  //! Default/empty constructor
  GraphicsBindingEGLMNDX(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingEGLMNDX, next_),
        getProcAddress{},
        display{},
        config{},
        context{} {}

  //! Default copy constructor
  GraphicsBindingEGLMNDX(const GraphicsBindingEGLMNDX& rhs) = default;
  //! Default copy assignment
  GraphicsBindingEGLMNDX& operator=(const GraphicsBindingEGLMNDX& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingEGLMNDX(const XrGraphicsBindingEGLMNDX& rhs) : GraphicsBindingEGLMNDX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingEGLMNDX& operator=(const XrGraphicsBindingEGLMNDX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingEGLMNDX&() const {
    return *reinterpret_cast<const XrGraphicsBindingEGLMNDX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingEGLMNDX&() {
    return *reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingEGLMNDX
  XrGraphicsBindingEGLMNDX const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingEGLMNDX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingEGLMNDX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingEGLMNDX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingEGLMNDX{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
  }
  PFNEGLGETPROCADDRESSPROC getProcAddress;
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
};
static_assert(sizeof(XrGraphicsBindingEGLMNDX) == sizeof(GraphicsBindingEGLMNDX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingEGLMNDX pointer to const from a
 * GraphicsBindingEGLMNDX reference to const.
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX const* get(GraphicsBindingEGLMNDX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingEGLMNDX as the
 * address of a raw XrGraphicsBindingEGLMNDX
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX* put(GraphicsBindingEGLMNDX& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_EGL)
#endif  // XR_MNDX_egl_enable

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrSystemHandTrackingPropertiesEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingPropertiesEXT>
 * @xrentity{XrSystemHandTrackingPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHandTrackingPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHandTrackingPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::SystemHandTrackingPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemHandTrackingPropertiesEXT(const SystemHandTrackingPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemHandTrackingPropertiesEXT& operator=(const SystemHandTrackingPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemHandTrackingPropertiesEXT(const XrSystemHandTrackingPropertiesEXT& rhs)
      : SystemHandTrackingPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHandTrackingPropertiesEXT& operator=(const XrSystemHandTrackingPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHandTrackingPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemHandTrackingPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHandTrackingPropertiesEXT&() {
    return *reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHandTrackingPropertiesEXT
  XrSystemHandTrackingPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemHandTrackingPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHandTrackingPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHandTrackingPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHandTrackingPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
  }
  Bool32 supportsHandTracking;
};
static_assert(sizeof(XrSystemHandTrackingPropertiesEXT) == sizeof(SystemHandTrackingPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingPropertiesEXT pointer to const from a
 * SystemHandTrackingPropertiesEXT reference to const.
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT const* get(
    SystemHandTrackingPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemHandTrackingPropertiesEXT as the address of a raw XrSystemHandTrackingPropertiesEXT
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT* put(SystemHandTrackingPropertiesEXT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandTrackerCreateInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerCreateInfoEXT>
 * @xrentity{XrHandTrackerCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackerCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandTrackerCreateInfoEXT(const HandEXT& hand_, const HandJointSetEXT& handJointSet_,
                           const void* next_ = nullptr)
      : Parent(StructureType::HandTrackerCreateInfoEXT, next_),
        hand{hand_},
        handJointSet{handJointSet_} {}

  //! Default/empty constructor
  HandTrackerCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandTrackerCreateInfoEXT, next_), hand{}, handJointSet{} {}

  //! Default copy constructor
  HandTrackerCreateInfoEXT(const HandTrackerCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  HandTrackerCreateInfoEXT& operator=(const HandTrackerCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandTrackerCreateInfoEXT(const XrHandTrackerCreateInfoEXT& rhs) : HandTrackerCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackerCreateInfoEXT& operator=(const XrHandTrackerCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackerCreateInfoEXT&() const {
    return *reinterpret_cast<const XrHandTrackerCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackerCreateInfoEXT&() {
    return *reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackerCreateInfoEXT
  XrHandTrackerCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandTrackerCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackerCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackerCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackerCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
  }
  HandEXT hand;
  HandJointSetEXT handJointSet;
};
static_assert(sizeof(XrHandTrackerCreateInfoEXT) == sizeof(HandTrackerCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackerCreateInfoEXT pointer to const from a
 * HandTrackerCreateInfoEXT reference to const.
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT const* get(HandTrackerCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackerCreateInfoEXT as
 * the address of a raw XrHandTrackerCreateInfoEXT
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT* put(HandTrackerCreateInfoEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointsLocateInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsLocateInfoEXT>
 * @xrentity{XrHandJointsLocateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointsLocateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandJointsLocateInfoEXT(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::HandJointsLocateInfoEXT, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  HandJointsLocateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandJointsLocateInfoEXT, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  HandJointsLocateInfoEXT(const HandJointsLocateInfoEXT& rhs) = default;
  //! Default copy assignment
  HandJointsLocateInfoEXT& operator=(const HandJointsLocateInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandJointsLocateInfoEXT(const XrHandJointsLocateInfoEXT& rhs) : HandJointsLocateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointsLocateInfoEXT& operator=(const XrHandJointsLocateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointsLocateInfoEXT&() const {
    return *reinterpret_cast<const XrHandJointsLocateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointsLocateInfoEXT&() {
    return *reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointsLocateInfoEXT
  XrHandJointsLocateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointsLocateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandJointsLocateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointsLocateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointsLocateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrHandJointsLocateInfoEXT) == sizeof(HandJointsLocateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointsLocateInfoEXT pointer to const from a
 * HandJointsLocateInfoEXT reference to const.
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT const* get(HandJointsLocateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsLocateInfoEXT as
 * the address of a raw XrHandJointsLocateInfoEXT
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT* put(HandJointsLocateInfoEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationEXT>
 * @xrentity{XrHandJointLocationEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandJointLocationEXT {
public:
  //! Constructor initializing all members.
  HandJointLocationEXT(const SpaceLocationFlags& locationFlags_, const Posef& pose_, float radius_)
      : locationFlags{locationFlags_}, pose{pose_}, radius{radius_} {}

  //! Default/empty constructor
  HandJointLocationEXT()

      : locationFlags{}, pose{}, radius{0.0f} {}

  //! Default copy constructor
  HandJointLocationEXT(const HandJointLocationEXT& rhs) = default;
  //! Default copy assignment
  HandJointLocationEXT& operator=(const HandJointLocationEXT& rhs) = default;
  //! Copy construct from raw
  HandJointLocationEXT(const XrHandJointLocationEXT& rhs) : HandJointLocationEXT() { *put() = rhs; }
  //! Copy assign from raw
  HandJointLocationEXT& operator=(const XrHandJointLocationEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointLocationEXT&() const {
    return *reinterpret_cast<const XrHandJointLocationEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointLocationEXT&() { return *reinterpret_cast<XrHandJointLocationEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointLocationEXT
  XrHandJointLocationEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointLocationEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandJointLocationEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandJointLocationEXT{};
    }
    return reinterpret_cast<XrHandJointLocationEXT*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
  float radius;
};
static_assert(sizeof(XrHandJointLocationEXT) == sizeof(HandJointLocationEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointLocationEXT pointer to const from a
 * HandJointLocationEXT reference to const.
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationEXT const* get(HandJointLocationEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationEXT as the
 * address of a raw XrHandJointLocationEXT
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationEXT* put(HandJointLocationEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocityEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocityEXT>
 * @xrentity{XrHandJointVelocityEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandJointVelocityEXT {
public:
  //! Constructor initializing all members.
  HandJointVelocityEXT(const SpaceVelocityFlags& velocityFlags_, const Vector3f& linearVelocity_,
                       const Vector3f& angularVelocity_)
      : velocityFlags{velocityFlags_},
        linearVelocity{linearVelocity_},
        angularVelocity{angularVelocity_} {}

  //! Default/empty constructor
  HandJointVelocityEXT()

      : velocityFlags{}, linearVelocity{}, angularVelocity{} {}

  //! Default copy constructor
  HandJointVelocityEXT(const HandJointVelocityEXT& rhs) = default;
  //! Default copy assignment
  HandJointVelocityEXT& operator=(const HandJointVelocityEXT& rhs) = default;
  //! Copy construct from raw
  HandJointVelocityEXT(const XrHandJointVelocityEXT& rhs) : HandJointVelocityEXT() { *put() = rhs; }
  //! Copy assign from raw
  HandJointVelocityEXT& operator=(const XrHandJointVelocityEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointVelocityEXT&() const {
    return *reinterpret_cast<const XrHandJointVelocityEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointVelocityEXT&() { return *reinterpret_cast<XrHandJointVelocityEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointVelocityEXT
  XrHandJointVelocityEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointVelocityEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocityEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandJointVelocityEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandJointVelocityEXT{};
    }
    return reinterpret_cast<XrHandJointVelocityEXT*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrHandJointVelocityEXT) == sizeof(HandJointVelocityEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointVelocityEXT pointer to const from a
 * HandJointVelocityEXT reference to const.
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocityEXT const* get(HandJointVelocityEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocityEXT as the
 * address of a raw XrHandJointVelocityEXT
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocityEXT* put(HandJointVelocityEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationsEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationsEXT>
 * @xrentity{XrHandJointLocationsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointLocationsEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandJointLocationsEXT(void* next_ = nullptr)

      : Parent(StructureType::HandJointLocationsEXT, next_) {}

  //! Default copy constructor
  HandJointLocationsEXT(const HandJointLocationsEXT& rhs) = default;
  //! Default copy assignment
  HandJointLocationsEXT& operator=(const HandJointLocationsEXT& rhs) = default;
  //! Copy construct from raw
  HandJointLocationsEXT(const XrHandJointLocationsEXT& rhs) : HandJointLocationsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointLocationsEXT& operator=(const XrHandJointLocationsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointLocationsEXT&() const {
    return *reinterpret_cast<const XrHandJointLocationsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointLocationsEXT&() { return *reinterpret_cast<XrHandJointLocationsEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointLocationsEXT
  XrHandJointLocationsEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointLocationsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointLocationsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointLocationsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointLocationsEXT*>(this);
  }
  Bool32 isActive;
  uint32_t jointCount;
  HandJointLocationEXT* jointLocations;
};
static_assert(sizeof(XrHandJointLocationsEXT) == sizeof(HandJointLocationsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointLocationsEXT pointer to const from a
 * HandJointLocationsEXT reference to const.
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationsEXT const* get(HandJointLocationsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationsEXT as the
 * address of a raw XrHandJointLocationsEXT
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationsEXT* put(HandJointLocationsEXT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocitiesEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocitiesEXT>
 * @xrentity{XrHandJointVelocitiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointVelocitiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandJointVelocitiesEXT(void* next_ = nullptr)

      : Parent(StructureType::HandJointVelocitiesEXT, next_) {}

  //! Default copy constructor
  HandJointVelocitiesEXT(const HandJointVelocitiesEXT& rhs) = default;
  //! Default copy assignment
  HandJointVelocitiesEXT& operator=(const HandJointVelocitiesEXT& rhs) = default;
  //! Copy construct from raw
  HandJointVelocitiesEXT(const XrHandJointVelocitiesEXT& rhs) : HandJointVelocitiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointVelocitiesEXT& operator=(const XrHandJointVelocitiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointVelocitiesEXT&() const {
    return *reinterpret_cast<const XrHandJointVelocitiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointVelocitiesEXT&() {
    return *reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointVelocitiesEXT
  XrHandJointVelocitiesEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointVelocitiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocitiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointVelocitiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointVelocitiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
  }
  uint32_t jointCount;
  HandJointVelocityEXT* jointVelocities;
};
static_assert(sizeof(XrHandJointVelocitiesEXT) == sizeof(HandJointVelocitiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointVelocitiesEXT pointer to const from a
 * HandJointVelocitiesEXT reference to const.
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT const* get(HandJointVelocitiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocitiesEXT as the
 * address of a raw XrHandJointVelocitiesEXT
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT* put(HandJointVelocitiesEXT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrSystemHandTrackingMeshPropertiesMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingMeshPropertiesMSFT>
 * @xrentity{XrSystemHandTrackingMeshPropertiesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHandTrackingMeshPropertiesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHandTrackingMeshPropertiesMSFT(void* next_ = nullptr)

      : Parent(StructureType::SystemHandTrackingMeshPropertiesMSFT, next_) {}

  //! Default copy constructor
  SystemHandTrackingMeshPropertiesMSFT(const SystemHandTrackingMeshPropertiesMSFT& rhs) = default;
  //! Default copy assignment
  SystemHandTrackingMeshPropertiesMSFT& operator=(const SystemHandTrackingMeshPropertiesMSFT& rhs) =
      default;
  //! Copy construct from raw
  SystemHandTrackingMeshPropertiesMSFT(const XrSystemHandTrackingMeshPropertiesMSFT& rhs)
      : SystemHandTrackingMeshPropertiesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHandTrackingMeshPropertiesMSFT& operator=(
      const XrSystemHandTrackingMeshPropertiesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHandTrackingMeshPropertiesMSFT&() const {
    return *reinterpret_cast<const XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHandTrackingMeshPropertiesMSFT&() {
    return *reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHandTrackingMeshPropertiesMSFT
  XrSystemHandTrackingMeshPropertiesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHandTrackingMeshPropertiesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHandTrackingMeshPropertiesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHandTrackingMeshPropertiesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }
  Bool32 supportsHandTrackingMesh;
  uint32_t maxHandMeshIndexCount;
  uint32_t maxHandMeshVertexCount;
};
static_assert(sizeof(XrSystemHandTrackingMeshPropertiesMSFT) ==
                  sizeof(SystemHandTrackingMeshPropertiesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingMeshPropertiesMSFT pointer to const
 * from a SystemHandTrackingMeshPropertiesMSFT reference to const.
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT const* get(
    SystemHandTrackingMeshPropertiesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemHandTrackingMeshPropertiesMSFT as the address of a raw
 * XrSystemHandTrackingMeshPropertiesMSFT
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT* put(
    SystemHandTrackingMeshPropertiesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshSpaceCreateInfoMSFT>
 * @xrentity{XrHandMeshSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandMeshSpaceCreateInfoMSFT(const HandPoseTypeMSFT& handPoseType_,
                              const Posef& poseInHandMeshSpace_, const void* next_ = nullptr)
      : Parent(StructureType::HandMeshSpaceCreateInfoMSFT, next_),
        handPoseType{handPoseType_},
        poseInHandMeshSpace{poseInHandMeshSpace_} {}

  //! Default/empty constructor
  HandMeshSpaceCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HandMeshSpaceCreateInfoMSFT, next_),
        handPoseType{},
        poseInHandMeshSpace{} {}

  //! Default copy constructor
  HandMeshSpaceCreateInfoMSFT(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshSpaceCreateInfoMSFT& operator=(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshSpaceCreateInfoMSFT(const XrHandMeshSpaceCreateInfoMSFT& rhs)
      : HandMeshSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshSpaceCreateInfoMSFT& operator=(const XrHandMeshSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrHandMeshSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshSpaceCreateInfoMSFT
  XrHandMeshSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
  }
  HandPoseTypeMSFT handPoseType;
  Posef poseInHandMeshSpace;
};
static_assert(sizeof(XrHandMeshSpaceCreateInfoMSFT) == sizeof(HandMeshSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshSpaceCreateInfoMSFT pointer to const from a
 * HandMeshSpaceCreateInfoMSFT reference to const.
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT const* get(
    HandMeshSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshSpaceCreateInfoMSFT
 * as the address of a raw XrHandMeshSpaceCreateInfoMSFT
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT* put(HandMeshSpaceCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshUpdateInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshUpdateInfoMSFT>
 * @xrentity{XrHandMeshUpdateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshUpdateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandMeshUpdateInfoMSFT(const Time& time_, const HandPoseTypeMSFT& handPoseType_,
                         const void* next_ = nullptr)
      : Parent(StructureType::HandMeshUpdateInfoMSFT, next_),
        time{time_},
        handPoseType{handPoseType_} {}

  //! Default/empty constructor
  HandMeshUpdateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HandMeshUpdateInfoMSFT, next_), time{}, handPoseType{} {}

  //! Default copy constructor
  HandMeshUpdateInfoMSFT(const HandMeshUpdateInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshUpdateInfoMSFT& operator=(const HandMeshUpdateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshUpdateInfoMSFT(const XrHandMeshUpdateInfoMSFT& rhs) : HandMeshUpdateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshUpdateInfoMSFT& operator=(const XrHandMeshUpdateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshUpdateInfoMSFT&() const {
    return *reinterpret_cast<const XrHandMeshUpdateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshUpdateInfoMSFT&() {
    return *reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshUpdateInfoMSFT
  XrHandMeshUpdateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshUpdateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshUpdateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshUpdateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshUpdateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
  }
  Time time;
  HandPoseTypeMSFT handPoseType;
};
static_assert(sizeof(XrHandMeshUpdateInfoMSFT) == sizeof(HandMeshUpdateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshUpdateInfoMSFT pointer to const from a
 * HandMeshUpdateInfoMSFT reference to const.
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT const* get(HandMeshUpdateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshUpdateInfoMSFT as the
 * address of a raw XrHandMeshUpdateInfoMSFT
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT* put(HandMeshUpdateInfoMSFT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshIndexBufferMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshIndexBufferMSFT>
 * @xrentity{XrHandMeshIndexBufferMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshIndexBufferMSFT {
public:
  //! Constructor initializing all members.
  HandMeshIndexBufferMSFT(uint32_t indexBufferKey_, uint32_t indexCapacityInput_,
                          uint32_t indexCountOutput_, uint32_t* indices_)
      : indexBufferKey{indexBufferKey_},
        indexCapacityInput{indexCapacityInput_},
        indexCountOutput{indexCountOutput_},
        indices{indices_} {}

  //! Default/empty constructor
  HandMeshIndexBufferMSFT()

      : indexBufferKey{0}, indexCapacityInput{0}, indexCountOutput{0}, indices{nullptr} {}

  //! Default copy constructor
  HandMeshIndexBufferMSFT(const HandMeshIndexBufferMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshIndexBufferMSFT& operator=(const HandMeshIndexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshIndexBufferMSFT(const XrHandMeshIndexBufferMSFT& rhs) : HandMeshIndexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshIndexBufferMSFT& operator=(const XrHandMeshIndexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshIndexBufferMSFT&() const {
    return *reinterpret_cast<const XrHandMeshIndexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshIndexBufferMSFT&() {
    return *reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshIndexBufferMSFT
  XrHandMeshIndexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshIndexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshIndexBufferMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshIndexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshIndexBufferMSFT{};
    }
    return reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
  }
  uint32_t indexBufferKey;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrHandMeshIndexBufferMSFT) == sizeof(HandMeshIndexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshIndexBufferMSFT pointer to const from a
 * HandMeshIndexBufferMSFT reference to const.
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT const* get(HandMeshIndexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshIndexBufferMSFT as
 * the address of a raw XrHandMeshIndexBufferMSFT
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT* put(HandMeshIndexBufferMSFT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexMSFT>
 * @xrentity{XrHandMeshVertexMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshVertexMSFT {
public:
  //! Constructor initializing all members.
  HandMeshVertexMSFT(const Vector3f& position_, const Vector3f& normal_)
      : position{position_}, normal{normal_} {}

  //! Default/empty constructor
  HandMeshVertexMSFT()

      : position{}, normal{} {}

  //! Default copy constructor
  HandMeshVertexMSFT(const HandMeshVertexMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshVertexMSFT& operator=(const HandMeshVertexMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshVertexMSFT(const XrHandMeshVertexMSFT& rhs) : HandMeshVertexMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandMeshVertexMSFT& operator=(const XrHandMeshVertexMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshVertexMSFT&() const {
    return *reinterpret_cast<const XrHandMeshVertexMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshVertexMSFT&() { return *reinterpret_cast<XrHandMeshVertexMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandMeshVertexMSFT
  XrHandMeshVertexMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshVertexMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshVertexMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshVertexMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshVertexMSFT{};
    }
    return reinterpret_cast<XrHandMeshVertexMSFT*>(this);
  }
  Vector3f position;
  Vector3f normal;
};
static_assert(sizeof(XrHandMeshVertexMSFT) == sizeof(HandMeshVertexMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshVertexMSFT pointer to const from a
 * HandMeshVertexMSFT reference to const.
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexMSFT const* get(HandMeshVertexMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexMSFT as the
 * address of a raw XrHandMeshVertexMSFT
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexMSFT* put(HandMeshVertexMSFT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexBufferMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexBufferMSFT>
 * @xrentity{XrHandMeshVertexBufferMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshVertexBufferMSFT {
public:
  //! Constructor initializing all members.
  HandMeshVertexBufferMSFT(const Time& vertexUpdateTime_, uint32_t vertexCapacityInput_,
                           uint32_t vertexCountOutput_, HandMeshVertexMSFT* vertices_)
      : vertexUpdateTime{vertexUpdateTime_},
        vertexCapacityInput{vertexCapacityInput_},
        vertexCountOutput{vertexCountOutput_},
        vertices{vertices_} {}

  //! Default/empty constructor
  HandMeshVertexBufferMSFT()

      : vertexUpdateTime{}, vertexCapacityInput{0}, vertexCountOutput{0}, vertices{nullptr} {}

  //! Default copy constructor
  HandMeshVertexBufferMSFT(const HandMeshVertexBufferMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshVertexBufferMSFT& operator=(const HandMeshVertexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshVertexBufferMSFT(const XrHandMeshVertexBufferMSFT& rhs) : HandMeshVertexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshVertexBufferMSFT& operator=(const XrHandMeshVertexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshVertexBufferMSFT&() const {
    return *reinterpret_cast<const XrHandMeshVertexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshVertexBufferMSFT&() {
    return *reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshVertexBufferMSFT
  XrHandMeshVertexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshVertexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshVertexBufferMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshVertexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshVertexBufferMSFT{};
    }
    return reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
  }
  Time vertexUpdateTime;
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  HandMeshVertexMSFT* vertices;
};
static_assert(sizeof(XrHandMeshVertexBufferMSFT) == sizeof(HandMeshVertexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshVertexBufferMSFT pointer to const from a
 * HandMeshVertexBufferMSFT reference to const.
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT const* get(HandMeshVertexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexBufferMSFT as
 * the address of a raw XrHandMeshVertexBufferMSFT
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT* put(HandMeshVertexBufferMSFT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshMSFT>
 * @xrentity{XrHandMeshMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandMeshMSFT(void* next_ = nullptr)

      : Parent(StructureType::HandMeshMSFT, next_) {}

  //! Default copy constructor
  HandMeshMSFT(const HandMeshMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshMSFT& operator=(const HandMeshMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshMSFT(const XrHandMeshMSFT& rhs) : HandMeshMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandMeshMSFT& operator=(const XrHandMeshMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshMSFT&() const { return *reinterpret_cast<const XrHandMeshMSFT*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshMSFT&() { return *reinterpret_cast<XrHandMeshMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandMeshMSFT
  XrHandMeshMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshMSFT*>(this);
  }
  Bool32 isActive;
  Bool32 indexBufferChanged;
  Bool32 vertexBufferChanged;
  HandMeshIndexBufferMSFT indexBuffer;
  HandMeshVertexBufferMSFT vertexBuffer;
};
static_assert(sizeof(XrHandMeshMSFT) == sizeof(HandMeshMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshMSFT pointer to const from a HandMeshMSFT
 * reference to const.
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshMSFT const* get(HandMeshMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshMSFT as the address
 * of a raw XrHandMeshMSFT
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshMSFT* put(HandMeshMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandPoseTypeInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeInfoMSFT>
 * @xrentity{XrHandPoseTypeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandPoseTypeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandPoseTypeInfoMSFT(const HandPoseTypeMSFT& handPoseType_, const void* next_ = nullptr)
      : Parent(StructureType::HandPoseTypeInfoMSFT, next_), handPoseType{handPoseType_} {}

  //! Default/empty constructor
  HandPoseTypeInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HandPoseTypeInfoMSFT, next_), handPoseType{} {}

  //! Default copy constructor
  HandPoseTypeInfoMSFT(const HandPoseTypeInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandPoseTypeInfoMSFT& operator=(const HandPoseTypeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandPoseTypeInfoMSFT(const XrHandPoseTypeInfoMSFT& rhs) : HandPoseTypeInfoMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandPoseTypeInfoMSFT& operator=(const XrHandPoseTypeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandPoseTypeInfoMSFT&() const {
    return *reinterpret_cast<const XrHandPoseTypeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandPoseTypeInfoMSFT&() { return *reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandPoseTypeInfoMSFT
  XrHandPoseTypeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandPoseTypeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandPoseTypeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandPoseTypeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandPoseTypeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this);
  }
  HandPoseTypeMSFT handPoseType;
};
static_assert(sizeof(XrHandPoseTypeInfoMSFT) == sizeof(HandPoseTypeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandPoseTypeInfoMSFT pointer to const from a
 * HandPoseTypeInfoMSFT reference to const.
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT const* get(HandPoseTypeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandPoseTypeInfoMSFT as the
 * address of a raw XrHandPoseTypeInfoMSFT
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT* put(HandPoseTypeInfoMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSessionBeginInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSessionBeginInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSessionBeginInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationSessionBeginInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      uint32_t viewConfigurationCount_, const ViewConfigurationType* enabledViewConfigurationTypes_,
      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT, next_),
        viewConfigurationCount{viewConfigurationCount_},
        enabledViewConfigurationTypes{enabledViewConfigurationTypes_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationSessionBeginInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT, next_),
        viewConfigurationCount{0},
        enabledViewConfigurationTypes{nullptr} {}

  //! Default copy constructor
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(
      const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs)
      : SecondaryViewConfigurationSessionBeginInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(
      const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationSessionBeginInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationSessionBeginInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT
  XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationSessionBeginInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationSessionBeginInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationSessionBeginInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  const ViewConfigurationType* enabledViewConfigurationTypes;
};
static_assert(sizeof(XrSecondaryViewConfigurationSessionBeginInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationSessionBeginInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT pointer
 * to const from a SecondaryViewConfigurationSessionBeginInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get(
    SecondaryViewConfigurationSessionBeginInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationSessionBeginInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationSessionBeginInfoMSFT
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT* put(
    SecondaryViewConfigurationSessionBeginInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationStateMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SecondaryViewConfigurationStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationStateMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationStateMSFT(const SecondaryViewConfigurationStateMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationStateMSFT& operator=(const SecondaryViewConfigurationStateMSFT& rhs) =
      default;
  //! Copy construct from raw
  SecondaryViewConfigurationStateMSFT(const XrSecondaryViewConfigurationStateMSFT& rhs)
      : SecondaryViewConfigurationStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationStateMSFT& operator=(const XrSecondaryViewConfigurationStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationStateMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationStateMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationStateMSFT
  XrSecondaryViewConfigurationStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Bool32 active;
};
static_assert(sizeof(XrSecondaryViewConfigurationStateMSFT) ==
                  sizeof(SecondaryViewConfigurationStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationStateMSFT pointer to const
 * from a SecondaryViewConfigurationStateMSFT reference to const.
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT const* get(
    SecondaryViewConfigurationStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationStateMSFT as the address of a raw XrSecondaryViewConfigurationStateMSFT
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT* put(
    SecondaryViewConfigurationStateMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameStateMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationFrameStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SecondaryViewConfigurationFrameStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationFrameStateMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationFrameStateMSFT(const SecondaryViewConfigurationFrameStateMSFT& rhs) =
      default;
  //! Default copy assignment
  SecondaryViewConfigurationFrameStateMSFT& operator=(
      const SecondaryViewConfigurationFrameStateMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationFrameStateMSFT(const XrSecondaryViewConfigurationFrameStateMSFT& rhs)
      : SecondaryViewConfigurationFrameStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationFrameStateMSFT& operator=(
      const XrSecondaryViewConfigurationFrameStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationFrameStateMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationFrameStateMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameStateMSFT
  XrSecondaryViewConfigurationFrameStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationFrameStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationFrameStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationFrameStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  SecondaryViewConfigurationStateMSFT* viewConfigurationStates;
};
static_assert(sizeof(XrSecondaryViewConfigurationFrameStateMSFT) ==
                  sizeof(SecondaryViewConfigurationFrameStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameStateMSFT pointer to
 * const from a SecondaryViewConfigurationFrameStateMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT const* get(
    SecondaryViewConfigurationFrameStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationFrameStateMSFT as the address of a raw
 * XrSecondaryViewConfigurationFrameStateMSFT
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT* put(
    SecondaryViewConfigurationFrameStateMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationLayerInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationLayerInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationLayerInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationLayerInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationLayerInfoMSFT(const ViewConfigurationType& viewConfigurationType_,
                                          const EnvironmentBlendMode& environmentBlendMode_,
                                          uint32_t layerCount_,
                                          const CompositionLayerBaseHeader* const* layers_,
                                          const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT, next_),
        viewConfigurationType{viewConfigurationType_},
        environmentBlendMode{environmentBlendMode_},
        layerCount{layerCount_},
        layers{layers_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationLayerInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT, next_),
        viewConfigurationType{},
        environmentBlendMode{},
        layerCount{0},
        layers{nullptr} {}

  //! Default copy constructor
  SecondaryViewConfigurationLayerInfoMSFT(const SecondaryViewConfigurationLayerInfoMSFT& rhs) =
      default;
  //! Default copy assignment
  SecondaryViewConfigurationLayerInfoMSFT& operator=(
      const SecondaryViewConfigurationLayerInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationLayerInfoMSFT(const XrSecondaryViewConfigurationLayerInfoMSFT& rhs)
      : SecondaryViewConfigurationLayerInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationLayerInfoMSFT& operator=(
      const XrSecondaryViewConfigurationLayerInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationLayerInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationLayerInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationLayerInfoMSFT
  XrSecondaryViewConfigurationLayerInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationLayerInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationLayerInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationLayerInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  EnvironmentBlendMode environmentBlendMode;
  uint32_t layerCount;
  const CompositionLayerBaseHeader* const* layers;
};
static_assert(sizeof(XrSecondaryViewConfigurationLayerInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationLayerInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationLayerInfoMSFT pointer to const
 * from a SecondaryViewConfigurationLayerInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT const* get(
    SecondaryViewConfigurationLayerInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationLayerInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationLayerInfoMSFT
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT* put(
    SecondaryViewConfigurationLayerInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameEndInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameEndInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameEndInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationFrameEndInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationFrameEndInfoMSFT(
      uint32_t viewConfigurationCount_,
      const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo_,
      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT, next_),
        viewConfigurationCount{viewConfigurationCount_},
        viewConfigurationLayersInfo{viewConfigurationLayersInfo_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationFrameEndInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT, next_),
        viewConfigurationCount{0},
        viewConfigurationLayersInfo{nullptr} {}

  //! Default copy constructor
  SecondaryViewConfigurationFrameEndInfoMSFT(
      const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationFrameEndInfoMSFT& operator=(
      const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationFrameEndInfoMSFT(
      const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs)
      : SecondaryViewConfigurationFrameEndInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationFrameEndInfoMSFT& operator=(
      const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationFrameEndInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationFrameEndInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameEndInfoMSFT
  XrSecondaryViewConfigurationFrameEndInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationFrameEndInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationFrameEndInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationFrameEndInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo;
};
static_assert(sizeof(XrSecondaryViewConfigurationFrameEndInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationFrameEndInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameEndInfoMSFT pointer to
 * const from a SecondaryViewConfigurationFrameEndInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT const* get(
    SecondaryViewConfigurationFrameEndInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationFrameEndInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationFrameEndInfoMSFT
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT* put(
    SecondaryViewConfigurationFrameEndInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSwapchainCreateInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSwapchainCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationSwapchainCreateInfoMSFT
    : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const ViewConfigurationType& viewConfigurationType_, const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT, next_),
        viewConfigurationType{viewConfigurationType_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT, next_),
        viewConfigurationType{} {}

  //! Default copy constructor
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(
      const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs)
      : SecondaryViewConfigurationSwapchainCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(
      const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationSwapchainCreateInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
  XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationSwapchainCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationSwapchainCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
};
static_assert(sizeof(XrSecondaryViewConfigurationSwapchainCreateInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationSwapchainCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * pointer to const from a SecondaryViewConfigurationSwapchainCreateInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get(
    SecondaryViewConfigurationSwapchainCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationSwapchainCreateInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* put(
    SecondaryViewConfigurationSwapchainCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_EPIC_view_configuration_fov
/*!
 * C++ projection of XrViewConfigurationViewFovEPIC
 *
 * Provided by the `XR_EPIC_view_configuration_fov` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationViewFovEPIC>
 * @xrentity{XrViewConfigurationViewFovEPIC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationViewFovEPIC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewConfigurationViewFovEPIC(const Fovf& recommendedFov_, const Fovf& maxMutableFov_,
                               const void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationViewFovEPIC, next_),
        recommendedFov{recommendedFov_},
        maxMutableFov{maxMutableFov_} {}

  //! Default/empty constructor
  ViewConfigurationViewFovEPIC(const void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationViewFovEPIC, next_),
        recommendedFov{},
        maxMutableFov{} {}

  //! Default copy constructor
  ViewConfigurationViewFovEPIC(const ViewConfigurationViewFovEPIC& rhs) = default;
  //! Default copy assignment
  ViewConfigurationViewFovEPIC& operator=(const ViewConfigurationViewFovEPIC& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationViewFovEPIC(const XrViewConfigurationViewFovEPIC& rhs)
      : ViewConfigurationViewFovEPIC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationViewFovEPIC& operator=(const XrViewConfigurationViewFovEPIC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationViewFovEPIC&() const {
    return *reinterpret_cast<const XrViewConfigurationViewFovEPIC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationViewFovEPIC&() {
    return *reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationViewFovEPIC
  XrViewConfigurationViewFovEPIC const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationViewFovEPIC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationViewFovEPIC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationViewFovEPIC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationViewFovEPIC{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
  }
  Fovf recommendedFov;
  Fovf maxMutableFov;
};
static_assert(sizeof(XrViewConfigurationViewFovEPIC) == sizeof(ViewConfigurationViewFovEPIC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationViewFovEPIC pointer to const from a
 * ViewConfigurationViewFovEPIC reference to const.
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC const* get(
    ViewConfigurationViewFovEPIC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationViewFovEPIC
 * as the address of a raw XrViewConfigurationViewFovEPIC
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC* put(ViewConfigurationViewFovEPIC& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EPIC_view_configuration_fov

#ifdef XR_MSFT_holographic_window_attachment
#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrHolographicWindowAttachmentMSFT
 *
 * Provided by the `XR_MSFT_holographic_window_attachment` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHolographicWindowAttachmentMSFT>
 * @xrentity{XrHolographicWindowAttachmentMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HolographicWindowAttachmentMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HolographicWindowAttachmentMSFT(IUnknown* holographicSpace_, IUnknown* coreWindow_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::HolographicWindowAttachmentMSFT, next_),
        holographicSpace{holographicSpace_},
        coreWindow{coreWindow_} {}

  //! Default/empty constructor
  HolographicWindowAttachmentMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HolographicWindowAttachmentMSFT, next_),
        holographicSpace{nullptr},
        coreWindow{nullptr} {}

  //! Default copy constructor
  HolographicWindowAttachmentMSFT(const HolographicWindowAttachmentMSFT& rhs) = default;
  //! Default copy assignment
  HolographicWindowAttachmentMSFT& operator=(const HolographicWindowAttachmentMSFT& rhs) = default;
  //! Copy construct from raw
  HolographicWindowAttachmentMSFT(const XrHolographicWindowAttachmentMSFT& rhs)
      : HolographicWindowAttachmentMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HolographicWindowAttachmentMSFT& operator=(const XrHolographicWindowAttachmentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHolographicWindowAttachmentMSFT&() const {
    return *reinterpret_cast<const XrHolographicWindowAttachmentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHolographicWindowAttachmentMSFT&() {
    return *reinterpret_cast<XrHolographicWindowAttachmentMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHolographicWindowAttachmentMSFT
  XrHolographicWindowAttachmentMSFT const* get() const noexcept {
    return reinterpret_cast<XrHolographicWindowAttachmentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHolographicWindowAttachmentMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHolographicWindowAttachmentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HolographicWindowAttachmentMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHolographicWindowAttachmentMSFT*>(this);
  }
  IUnknown* holographicSpace;
  IUnknown* coreWindow;
};
static_assert(sizeof(XrHolographicWindowAttachmentMSFT) == sizeof(HolographicWindowAttachmentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHolographicWindowAttachmentMSFT pointer to const from a
 * HolographicWindowAttachmentMSFT reference to const.
 * @relates HolographicWindowAttachmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHolographicWindowAttachmentMSFT const* get(
    HolographicWindowAttachmentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * HolographicWindowAttachmentMSFT as the address of a raw XrHolographicWindowAttachmentMSFT
 * @relates HolographicWindowAttachmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHolographicWindowAttachmentMSFT* put(HolographicWindowAttachmentMSFT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_holographic_window_attachment

#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * C++ projection of XrCompositionLayerReprojectionInfoMSFT
 *
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerReprojectionInfoMSFT>
 * @xrentity{XrCompositionLayerReprojectionInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerReprojectionInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerReprojectionInfoMSFT(const ReprojectionModeMSFT& reprojectionMode_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerReprojectionInfoMSFT, next_),
        reprojectionMode{reprojectionMode_} {}

  //! Default/empty constructor
  CompositionLayerReprojectionInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerReprojectionInfoMSFT, next_), reprojectionMode{} {}

  //! Default copy constructor
  CompositionLayerReprojectionInfoMSFT(const CompositionLayerReprojectionInfoMSFT& rhs) = default;
  //! Default copy assignment
  CompositionLayerReprojectionInfoMSFT& operator=(const CompositionLayerReprojectionInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  CompositionLayerReprojectionInfoMSFT(const XrCompositionLayerReprojectionInfoMSFT& rhs)
      : CompositionLayerReprojectionInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerReprojectionInfoMSFT& operator=(
      const XrCompositionLayerReprojectionInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerReprojectionInfoMSFT&() const {
    return *reinterpret_cast<const XrCompositionLayerReprojectionInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerReprojectionInfoMSFT&() {
    return *reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerReprojectionInfoMSFT
  XrCompositionLayerReprojectionInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerReprojectionInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerReprojectionInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerReprojectionInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT*>(this);
  }
  ReprojectionModeMSFT reprojectionMode;
};
static_assert(sizeof(XrCompositionLayerReprojectionInfoMSFT) ==
                  sizeof(CompositionLayerReprojectionInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerReprojectionInfoMSFT pointer to const
 * from a CompositionLayerReprojectionInfoMSFT reference to const.
 * @relates CompositionLayerReprojectionInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionInfoMSFT const* get(
    CompositionLayerReprojectionInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerReprojectionInfoMSFT as the address of a raw
 * XrCompositionLayerReprojectionInfoMSFT
 * @relates CompositionLayerReprojectionInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionInfoMSFT* put(
    CompositionLayerReprojectionInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * C++ projection of XrCompositionLayerReprojectionPlaneOverrideMSFT
 *
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerReprojectionPlaneOverrideMSFT>
 * @xrentity{XrCompositionLayerReprojectionPlaneOverrideMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerReprojectionPlaneOverrideMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerReprojectionPlaneOverrideMSFT(const Vector3f& position_, const Vector3f& normal_,
                                                const Vector3f& velocity_,
                                                const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerReprojectionPlaneOverrideMSFT, next_),
        position{position_},
        normal{normal_},
        velocity{velocity_} {}

  //! Default/empty constructor
  CompositionLayerReprojectionPlaneOverrideMSFT(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerReprojectionPlaneOverrideMSFT, next_),
        position{},
        normal{},
        velocity{} {}

  //! Default copy constructor
  CompositionLayerReprojectionPlaneOverrideMSFT(
      const CompositionLayerReprojectionPlaneOverrideMSFT& rhs) = default;
  //! Default copy assignment
  CompositionLayerReprojectionPlaneOverrideMSFT& operator=(
      const CompositionLayerReprojectionPlaneOverrideMSFT& rhs) = default;
  //! Copy construct from raw
  CompositionLayerReprojectionPlaneOverrideMSFT(
      const XrCompositionLayerReprojectionPlaneOverrideMSFT& rhs)
      : CompositionLayerReprojectionPlaneOverrideMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerReprojectionPlaneOverrideMSFT& operator=(
      const XrCompositionLayerReprojectionPlaneOverrideMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerReprojectionPlaneOverrideMSFT&() const {
    return *reinterpret_cast<const XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerReprojectionPlaneOverrideMSFT&() {
    return *reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerReprojectionPlaneOverrideMSFT
  XrCompositionLayerReprojectionPlaneOverrideMSFT const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerReprojectionPlaneOverrideMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerReprojectionPlaneOverrideMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerReprojectionPlaneOverrideMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
  }
  Vector3f position;
  Vector3f normal;
  Vector3f velocity;
};
static_assert(sizeof(XrCompositionLayerReprojectionPlaneOverrideMSFT) ==
                  sizeof(CompositionLayerReprojectionPlaneOverrideMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerReprojectionPlaneOverrideMSFT pointer to
 * const from a CompositionLayerReprojectionPlaneOverrideMSFT reference to const.
 * @relates CompositionLayerReprojectionPlaneOverrideMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionPlaneOverrideMSFT const* get(
    CompositionLayerReprojectionPlaneOverrideMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerReprojectionPlaneOverrideMSFT as the address of a raw
 * XrCompositionLayerReprojectionPlaneOverrideMSFT
 * @relates CompositionLayerReprojectionPlaneOverrideMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionPlaneOverrideMSFT* put(
    CompositionLayerReprojectionPlaneOverrideMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_FB_android_surface_swapchain_create
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrAndroidSurfaceSwapchainCreateInfoFB
 *
 * Provided by the `XR_FB_android_surface_swapchain_create` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAndroidSurfaceSwapchainCreateInfoFB>
 * @xrentity{XrAndroidSurfaceSwapchainCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS AndroidSurfaceSwapchainCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  AndroidSurfaceSwapchainCreateInfoFB(const AndroidSurfaceSwapchainFlagsFB& createFlags_,
                                      const void* next_ = nullptr)
      : Parent(StructureType::AndroidSurfaceSwapchainCreateInfoFB, next_),
        createFlags{createFlags_} {}

  //! Default/empty constructor
  AndroidSurfaceSwapchainCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::AndroidSurfaceSwapchainCreateInfoFB, next_), createFlags{} {}

  //! Default copy constructor
  AndroidSurfaceSwapchainCreateInfoFB(const AndroidSurfaceSwapchainCreateInfoFB& rhs) = default;
  //! Default copy assignment
  AndroidSurfaceSwapchainCreateInfoFB& operator=(const AndroidSurfaceSwapchainCreateInfoFB& rhs) =
      default;
  //! Copy construct from raw
  AndroidSurfaceSwapchainCreateInfoFB(const XrAndroidSurfaceSwapchainCreateInfoFB& rhs)
      : AndroidSurfaceSwapchainCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  AndroidSurfaceSwapchainCreateInfoFB& operator=(const XrAndroidSurfaceSwapchainCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrAndroidSurfaceSwapchainCreateInfoFB&() const {
    return *reinterpret_cast<const XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrAndroidSurfaceSwapchainCreateInfoFB&() {
    return *reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB
  XrAndroidSurfaceSwapchainCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrAndroidSurfaceSwapchainCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrAndroidSurfaceSwapchainCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = AndroidSurfaceSwapchainCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
  }
  AndroidSurfaceSwapchainFlagsFB createFlags;
};
static_assert(sizeof(XrAndroidSurfaceSwapchainCreateInfoFB) ==
                  sizeof(AndroidSurfaceSwapchainCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrAndroidSurfaceSwapchainCreateInfoFB pointer to const
 * from a AndroidSurfaceSwapchainCreateInfoFB reference to const.
 * @relates AndroidSurfaceSwapchainCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrAndroidSurfaceSwapchainCreateInfoFB const* get(
    AndroidSurfaceSwapchainCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * AndroidSurfaceSwapchainCreateInfoFB as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB
 * @relates AndroidSurfaceSwapchainCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrAndroidSurfaceSwapchainCreateInfoFB* put(
    AndroidSurfaceSwapchainCreateInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_FB_android_surface_swapchain_create

#ifdef XR_FB_swapchain_update_state
/*!
 * C++ projection of XrSwapchainStateBaseHeaderFB
 *
 * Provided by the `XR_FB_swapchain_update_state` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateBaseHeaderFB>
 * @xrentity{XrSwapchainStateBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SwapchainStateBaseHeaderFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SwapchainStateBaseHeaderFB(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateBaseHeaderFB&() const {
    return *reinterpret_cast<const XrSwapchainStateBaseHeaderFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateBaseHeaderFB&() {
    return *reinterpret_cast<XrSwapchainStateBaseHeaderFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainStateBaseHeaderFB
  XrSwapchainStateBaseHeaderFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
};
static_assert(sizeof(XrSwapchainStateBaseHeaderFB) == sizeof(SwapchainStateBaseHeaderFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateBaseHeaderFB pointer to const from a
 * SwapchainStateBaseHeaderFB reference to const.
 * @relates SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get(
    SwapchainStateBaseHeaderFB const& s) {
  return s.get();
}

#endif  // XR_FB_swapchain_update_state

#ifdef XR_FB_composition_layer_secure_content
/*!
 * C++ projection of XrCompositionLayerSecureContentFB
 *
 * Provided by the `XR_FB_composition_layer_secure_content` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSecureContentFB>
 * @xrentity{XrCompositionLayerSecureContentFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerSecureContentFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerSecureContentFB(const CompositionLayerSecureContentFlagsFB& flags_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerSecureContentFB, next_), flags{flags_} {}

  //! Default/empty constructor
  CompositionLayerSecureContentFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerSecureContentFB, next_), flags{} {}

  //! Default copy constructor
  CompositionLayerSecureContentFB(const CompositionLayerSecureContentFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerSecureContentFB& operator=(const CompositionLayerSecureContentFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerSecureContentFB(const XrCompositionLayerSecureContentFB& rhs)
      : CompositionLayerSecureContentFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerSecureContentFB& operator=(const XrCompositionLayerSecureContentFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerSecureContentFB&() const {
    return *reinterpret_cast<const XrCompositionLayerSecureContentFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerSecureContentFB&() {
    return *reinterpret_cast<XrCompositionLayerSecureContentFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerSecureContentFB
  XrCompositionLayerSecureContentFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerSecureContentFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerSecureContentFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerSecureContentFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerSecureContentFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerSecureContentFB*>(this);
  }
  CompositionLayerSecureContentFlagsFB flags;
};
static_assert(sizeof(XrCompositionLayerSecureContentFB) == sizeof(CompositionLayerSecureContentFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerSecureContentFB pointer to const from a
 * CompositionLayerSecureContentFB reference to const.
 * @relates CompositionLayerSecureContentFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSecureContentFB const* get(
    CompositionLayerSecureContentFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerSecureContentFB as the address of a raw XrCompositionLayerSecureContentFB
 * @relates CompositionLayerSecureContentFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSecureContentFB* put(CompositionLayerSecureContentFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_secure_content

#ifdef XR_VALVE_analog_threshold
/*!
 * C++ projection of XrInteractionProfileAnalogThresholdVALVE
 *
 * Provided by the `XR_VALVE_analog_threshold` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileAnalogThresholdVALVE>
 * @xrentity{XrInteractionProfileAnalogThresholdVALVE}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileAnalogThresholdVALVE
    : public BindingModificationBaseHeaderKHR {
private:
  using Parent = BindingModificationBaseHeaderKHR;

public:
  //! Constructor initializing all members.
  InteractionProfileAnalogThresholdVALVE(const Action& action_, const Path& binding_,
                                         float onThreshold_, float offThreshold_,
                                         const HapticBaseHeader* onHaptic_,
                                         const HapticBaseHeader* offHaptic_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileAnalogThresholdVALVE, next_),
        action{action_},
        binding{binding_},
        onThreshold{onThreshold_},
        offThreshold{offThreshold_},
        onHaptic{onHaptic_},
        offHaptic{offHaptic_} {}

  //! Default/empty constructor
  InteractionProfileAnalogThresholdVALVE(const void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileAnalogThresholdVALVE, next_),
        action{},
        binding{},
        onThreshold{0.0f},
        offThreshold{0.0f},
        onHaptic{nullptr},
        offHaptic{nullptr} {}

  //! Default copy constructor
  InteractionProfileAnalogThresholdVALVE(const InteractionProfileAnalogThresholdVALVE& rhs) =
      default;
  //! Default copy assignment
  InteractionProfileAnalogThresholdVALVE& operator=(
      const InteractionProfileAnalogThresholdVALVE& rhs) = default;
  //! Copy construct from raw
  InteractionProfileAnalogThresholdVALVE(const XrInteractionProfileAnalogThresholdVALVE& rhs)
      : InteractionProfileAnalogThresholdVALVE() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileAnalogThresholdVALVE& operator=(
      const XrInteractionProfileAnalogThresholdVALVE& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileAnalogThresholdVALVE&() const {
    return *reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileAnalogThresholdVALVE&() {
    return *reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
  }

  //! Accessor for this as a raw, base XrBindingModificationBaseHeaderKHR const pointer
  XrBindingModificationBaseHeaderKHR const* get_base() const noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
  }
  //! Accessor for this as the address of a raw XrInteractionProfileAnalogThresholdVALVE
  XrInteractionProfileAnalogThresholdVALVE const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileAnalogThresholdVALVE.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileAnalogThresholdVALVE* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileAnalogThresholdVALVE{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
  }
  Action action;
  Path binding;
  float onThreshold;
  float offThreshold;
  const HapticBaseHeader* onHaptic;
  const HapticBaseHeader* offHaptic;
};
static_assert(sizeof(XrInteractionProfileAnalogThresholdVALVE) ==
                  sizeof(InteractionProfileAnalogThresholdVALVE),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileAnalogThresholdVALVE pointer to const
 * from a InteractionProfileAnalogThresholdVALVE reference to const.
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE const* get(
    InteractionProfileAnalogThresholdVALVE const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileAnalogThresholdVALVE as the address of a raw
 * XrInteractionProfileAnalogThresholdVALVE
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE* put(
    InteractionProfileAnalogThresholdVALVE& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const InteractionProfileAnalogThresholdVALVE as
 * a raw, pointer to const XrBindingModificationBaseHeaderKHR (the base type)
 * @relates InteractionProfileAnalogThresholdVALVE
 * @relatesalso BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get_base(
    InteractionProfileAnalogThresholdVALVE const& h) {
  return h.get_base();
}
#endif  // XR_VALVE_analog_threshold

#ifdef XR_EXT_hand_joints_motion_range
/*!
 * C++ projection of XrHandJointsMotionRangeInfoEXT
 *
 * Provided by the `XR_EXT_hand_joints_motion_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsMotionRangeInfoEXT>
 * @xrentity{XrHandJointsMotionRangeInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointsMotionRangeInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandJointsMotionRangeInfoEXT(const HandJointsMotionRangeEXT& handJointsMotionRange_,
                               const void* next_ = nullptr)
      : Parent(StructureType::HandJointsMotionRangeInfoEXT, next_),
        handJointsMotionRange{handJointsMotionRange_} {}

  //! Default/empty constructor
  HandJointsMotionRangeInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandJointsMotionRangeInfoEXT, next_), handJointsMotionRange{} {}

  //! Default copy constructor
  HandJointsMotionRangeInfoEXT(const HandJointsMotionRangeInfoEXT& rhs) = default;
  //! Default copy assignment
  HandJointsMotionRangeInfoEXT& operator=(const HandJointsMotionRangeInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandJointsMotionRangeInfoEXT(const XrHandJointsMotionRangeInfoEXT& rhs)
      : HandJointsMotionRangeInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointsMotionRangeInfoEXT& operator=(const XrHandJointsMotionRangeInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointsMotionRangeInfoEXT&() const {
    return *reinterpret_cast<const XrHandJointsMotionRangeInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointsMotionRangeInfoEXT&() {
    return *reinterpret_cast<XrHandJointsMotionRangeInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointsMotionRangeInfoEXT
  XrHandJointsMotionRangeInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointsMotionRangeInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandJointsMotionRangeInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointsMotionRangeInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointsMotionRangeInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointsMotionRangeInfoEXT*>(this);
  }
  HandJointsMotionRangeEXT handJointsMotionRange;
};
static_assert(sizeof(XrHandJointsMotionRangeInfoEXT) == sizeof(HandJointsMotionRangeInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointsMotionRangeInfoEXT pointer to const from a
 * HandJointsMotionRangeInfoEXT reference to const.
 * @relates HandJointsMotionRangeInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsMotionRangeInfoEXT const* get(
    HandJointsMotionRangeInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsMotionRangeInfoEXT
 * as the address of a raw XrHandJointsMotionRangeInfoEXT
 * @relates HandJointsMotionRangeInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsMotionRangeInfoEXT* put(HandJointsMotionRangeInfoEXT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_joints_motion_range

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrUuidMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUuidMSFT>
 * @xrentity{XrUuidMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS UuidMSFT {
public:
  //! Constructor initializing all members.
  UuidMSFT(uint8_t bytes_[16]) { memcpy(bytes, bytes_, sizeof(bytes)); }

  //! Default/empty constructor
  UuidMSFT()

      : bytes{0} {}

  //! Default copy constructor
  UuidMSFT(const UuidMSFT& rhs) = default;
  //! Default copy assignment
  UuidMSFT& operator=(const UuidMSFT& rhs) = default;
  //! Copy construct from raw
  UuidMSFT(const XrUuidMSFT& rhs) : UuidMSFT() { *put() = rhs; }
  //! Copy assign from raw
  UuidMSFT& operator=(const XrUuidMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrUuidMSFT&() const { return *reinterpret_cast<const XrUuidMSFT*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrUuidMSFT&() { return *reinterpret_cast<XrUuidMSFT*>(this); }

  //! Accessor for this as the address of a raw XrUuidMSFT
  XrUuidMSFT const* get() const noexcept { return reinterpret_cast<XrUuidMSFT const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrUuidMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrUuidMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = UuidMSFT{};
    }
    return reinterpret_cast<XrUuidMSFT*>(this);
  }
  uint8_t bytes[16];
};
static_assert(sizeof(XrUuidMSFT) == sizeof(UuidMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrUuidMSFT pointer to const from a UuidMSFT reference to
 * const.
 * @relates UuidMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuidMSFT const* get(UuidMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing UuidMSFT as the address of a
 * raw XrUuidMSFT
 * @relates UuidMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuidMSFT* put(UuidMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObserverCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObserverCreateInfoMSFT>
 * @xrentity{XrSceneObserverCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneObserverCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SceneObserverCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneObserverCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SceneObserverCreateInfoMSFT(const SceneObserverCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneObserverCreateInfoMSFT& operator=(const SceneObserverCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObserverCreateInfoMSFT(const XrSceneObserverCreateInfoMSFT& rhs)
      : SceneObserverCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneObserverCreateInfoMSFT& operator=(const XrSceneObserverCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObserverCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneObserverCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObserverCreateInfoMSFT&() {
    return *reinterpret_cast<XrSceneObserverCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneObserverCreateInfoMSFT
  XrSceneObserverCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObserverCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneObserverCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneObserverCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneObserverCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneObserverCreateInfoMSFT*>(this);
  }
};
static_assert(sizeof(XrSceneObserverCreateInfoMSFT) == sizeof(SceneObserverCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObserverCreateInfoMSFT pointer to const from a
 * SceneObserverCreateInfoMSFT reference to const.
 * @relates SceneObserverCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObserverCreateInfoMSFT const* get(
    SceneObserverCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneObserverCreateInfoMSFT
 * as the address of a raw XrSceneObserverCreateInfoMSFT
 * @relates SceneObserverCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObserverCreateInfoMSFT* put(SceneObserverCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneCreateInfoMSFT>
 * @xrentity{XrSceneCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SceneCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SceneCreateInfoMSFT(const SceneCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneCreateInfoMSFT& operator=(const SceneCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneCreateInfoMSFT(const XrSceneCreateInfoMSFT& rhs) : SceneCreateInfoMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneCreateInfoMSFT& operator=(const XrSceneCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneCreateInfoMSFT&() { return *reinterpret_cast<XrSceneCreateInfoMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneCreateInfoMSFT
  XrSceneCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneCreateInfoMSFT*>(this);
  }
};
static_assert(sizeof(XrSceneCreateInfoMSFT) == sizeof(SceneCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneCreateInfoMSFT pointer to const from a
 * SceneCreateInfoMSFT reference to const.
 * @relates SceneCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCreateInfoMSFT const* get(SceneCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneCreateInfoMSFT as the
 * address of a raw XrSceneCreateInfoMSFT
 * @relates SceneCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCreateInfoMSFT* put(SceneCreateInfoMSFT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneSphereBoundMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneSphereBoundMSFT>
 * @xrentity{XrSceneSphereBoundMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneSphereBoundMSFT {
public:
  //! Constructor initializing all members.
  SceneSphereBoundMSFT(const Vector3f& center_, float radius_) : center{center_}, radius{radius_} {}

  //! Default/empty constructor
  SceneSphereBoundMSFT()

      : center{}, radius{0.0f} {}

  //! Default copy constructor
  SceneSphereBoundMSFT(const SceneSphereBoundMSFT& rhs) = default;
  //! Default copy assignment
  SceneSphereBoundMSFT& operator=(const SceneSphereBoundMSFT& rhs) = default;
  //! Copy construct from raw
  SceneSphereBoundMSFT(const XrSceneSphereBoundMSFT& rhs) : SceneSphereBoundMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneSphereBoundMSFT& operator=(const XrSceneSphereBoundMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneSphereBoundMSFT&() const {
    return *reinterpret_cast<const XrSceneSphereBoundMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneSphereBoundMSFT&() { return *reinterpret_cast<XrSceneSphereBoundMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneSphereBoundMSFT
  XrSceneSphereBoundMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneSphereBoundMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneSphereBoundMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneSphereBoundMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneSphereBoundMSFT{};
    }
    return reinterpret_cast<XrSceneSphereBoundMSFT*>(this);
  }
  Vector3f center;
  float radius;
};
static_assert(sizeof(XrSceneSphereBoundMSFT) == sizeof(SceneSphereBoundMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneSphereBoundMSFT pointer to const from a
 * SceneSphereBoundMSFT reference to const.
 * @relates SceneSphereBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneSphereBoundMSFT const* get(SceneSphereBoundMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneSphereBoundMSFT as the
 * address of a raw XrSceneSphereBoundMSFT
 * @relates SceneSphereBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneSphereBoundMSFT* put(SceneSphereBoundMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneOrientedBoxBoundMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneOrientedBoxBoundMSFT>
 * @xrentity{XrSceneOrientedBoxBoundMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneOrientedBoxBoundMSFT {
public:
  //! Constructor initializing all members.
  SceneOrientedBoxBoundMSFT(const Posef& pose_, const Vector3f& extents_)
      : pose{pose_}, extents{extents_} {}

  //! Default/empty constructor
  SceneOrientedBoxBoundMSFT()

      : pose{}, extents{} {}

  //! Default copy constructor
  SceneOrientedBoxBoundMSFT(const SceneOrientedBoxBoundMSFT& rhs) = default;
  //! Default copy assignment
  SceneOrientedBoxBoundMSFT& operator=(const SceneOrientedBoxBoundMSFT& rhs) = default;
  //! Copy construct from raw
  SceneOrientedBoxBoundMSFT(const XrSceneOrientedBoxBoundMSFT& rhs) : SceneOrientedBoxBoundMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneOrientedBoxBoundMSFT& operator=(const XrSceneOrientedBoxBoundMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneOrientedBoxBoundMSFT&() const {
    return *reinterpret_cast<const XrSceneOrientedBoxBoundMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneOrientedBoxBoundMSFT&() {
    return *reinterpret_cast<XrSceneOrientedBoxBoundMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneOrientedBoxBoundMSFT
  XrSceneOrientedBoxBoundMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneOrientedBoxBoundMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneOrientedBoxBoundMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneOrientedBoxBoundMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneOrientedBoxBoundMSFT{};
    }
    return reinterpret_cast<XrSceneOrientedBoxBoundMSFT*>(this);
  }
  Posef pose;
  Vector3f extents;
};
static_assert(sizeof(XrSceneOrientedBoxBoundMSFT) == sizeof(SceneOrientedBoxBoundMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneOrientedBoxBoundMSFT pointer to const from a
 * SceneOrientedBoxBoundMSFT reference to const.
 * @relates SceneOrientedBoxBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneOrientedBoxBoundMSFT const* get(
    SceneOrientedBoxBoundMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneOrientedBoxBoundMSFT as
 * the address of a raw XrSceneOrientedBoxBoundMSFT
 * @relates SceneOrientedBoxBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneOrientedBoxBoundMSFT* put(SceneOrientedBoxBoundMSFT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneFrustumBoundMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneFrustumBoundMSFT>
 * @xrentity{XrSceneFrustumBoundMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneFrustumBoundMSFT {
public:
  //! Constructor initializing all members.
  SceneFrustumBoundMSFT(const Posef& pose_, const Fovf& fov_, float farDistance_)
      : pose{pose_}, fov{fov_}, farDistance{farDistance_} {}

  //! Default/empty constructor
  SceneFrustumBoundMSFT()

      : pose{}, fov{}, farDistance{0.0f} {}

  //! Default copy constructor
  SceneFrustumBoundMSFT(const SceneFrustumBoundMSFT& rhs) = default;
  //! Default copy assignment
  SceneFrustumBoundMSFT& operator=(const SceneFrustumBoundMSFT& rhs) = default;
  //! Copy construct from raw
  SceneFrustumBoundMSFT(const XrSceneFrustumBoundMSFT& rhs) : SceneFrustumBoundMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneFrustumBoundMSFT& operator=(const XrSceneFrustumBoundMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneFrustumBoundMSFT&() const {
    return *reinterpret_cast<const XrSceneFrustumBoundMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneFrustumBoundMSFT&() { return *reinterpret_cast<XrSceneFrustumBoundMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneFrustumBoundMSFT
  XrSceneFrustumBoundMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneFrustumBoundMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneFrustumBoundMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneFrustumBoundMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneFrustumBoundMSFT{};
    }
    return reinterpret_cast<XrSceneFrustumBoundMSFT*>(this);
  }
  Posef pose;
  Fovf fov;
  float farDistance;
};
static_assert(sizeof(XrSceneFrustumBoundMSFT) == sizeof(SceneFrustumBoundMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneFrustumBoundMSFT pointer to const from a
 * SceneFrustumBoundMSFT reference to const.
 * @relates SceneFrustumBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneFrustumBoundMSFT const* get(SceneFrustumBoundMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneFrustumBoundMSFT as the
 * address of a raw XrSceneFrustumBoundMSFT
 * @relates SceneFrustumBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneFrustumBoundMSFT* put(SceneFrustumBoundMSFT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneBoundsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneBoundsMSFT>
 * @xrentity{XrSceneBoundsMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneBoundsMSFT {
public:
  //! Constructor initializing all members.
  SceneBoundsMSFT(const Space& space_, const Time& time_, uint32_t sphereCount_,
                  const SceneSphereBoundMSFT* spheres_, uint32_t boxCount_,
                  const SceneOrientedBoxBoundMSFT* boxes_, uint32_t frustumCount_,
                  const SceneFrustumBoundMSFT* frustums_)
      : space{space_},
        time{time_},
        sphereCount{sphereCount_},
        spheres{spheres_},
        boxCount{boxCount_},
        boxes{boxes_},
        frustumCount{frustumCount_},
        frustums{frustums_} {}

  //! Default/empty constructor
  SceneBoundsMSFT()

      : space{},
        time{},
        sphereCount{0},
        spheres{nullptr},
        boxCount{0},
        boxes{nullptr},
        frustumCount{0},
        frustums{nullptr} {}

  //! Default copy constructor
  SceneBoundsMSFT(const SceneBoundsMSFT& rhs) = default;
  //! Default copy assignment
  SceneBoundsMSFT& operator=(const SceneBoundsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneBoundsMSFT(const XrSceneBoundsMSFT& rhs) : SceneBoundsMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneBoundsMSFT& operator=(const XrSceneBoundsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneBoundsMSFT&() const {
    return *reinterpret_cast<const XrSceneBoundsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneBoundsMSFT&() { return *reinterpret_cast<XrSceneBoundsMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneBoundsMSFT
  XrSceneBoundsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneBoundsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneBoundsMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneBoundsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneBoundsMSFT{};
    }
    return reinterpret_cast<XrSceneBoundsMSFT*>(this);
  }
  Space space;
  Time time;
  uint32_t sphereCount;
  const SceneSphereBoundMSFT* spheres;
  uint32_t boxCount;
  const SceneOrientedBoxBoundMSFT* boxes;
  uint32_t frustumCount;
  const SceneFrustumBoundMSFT* frustums;
};
static_assert(sizeof(XrSceneBoundsMSFT) == sizeof(SceneBoundsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneBoundsMSFT pointer to const from a SceneBoundsMSFT
 * reference to const.
 * @relates SceneBoundsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneBoundsMSFT const* get(SceneBoundsMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneBoundsMSFT as the
 * address of a raw XrSceneBoundsMSFT
 * @relates SceneBoundsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneBoundsMSFT* put(SceneBoundsMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrNewSceneComputeInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrNewSceneComputeInfoMSFT>
 * @xrentity{XrNewSceneComputeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS NewSceneComputeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  NewSceneComputeInfoMSFT(uint32_t requestedFeatureCount_,
                          const SceneComputeFeatureMSFT* requestedFeatures_,
                          const SceneComputeConsistencyMSFT& consistency_,
                          const SceneBoundsMSFT& bounds_, const void* next_ = nullptr)
      : Parent(StructureType::NewSceneComputeInfoMSFT, next_),
        requestedFeatureCount{requestedFeatureCount_},
        requestedFeatures{requestedFeatures_},
        consistency{consistency_},
        bounds{bounds_} {}

  //! Default/empty constructor
  NewSceneComputeInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::NewSceneComputeInfoMSFT, next_),
        requestedFeatureCount{0},
        requestedFeatures{nullptr},
        consistency{},
        bounds{} {}

  //! Default copy constructor
  NewSceneComputeInfoMSFT(const NewSceneComputeInfoMSFT& rhs) = default;
  //! Default copy assignment
  NewSceneComputeInfoMSFT& operator=(const NewSceneComputeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  NewSceneComputeInfoMSFT(const XrNewSceneComputeInfoMSFT& rhs) : NewSceneComputeInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  NewSceneComputeInfoMSFT& operator=(const XrNewSceneComputeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrNewSceneComputeInfoMSFT&() const {
    return *reinterpret_cast<const XrNewSceneComputeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrNewSceneComputeInfoMSFT&() {
    return *reinterpret_cast<XrNewSceneComputeInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrNewSceneComputeInfoMSFT
  XrNewSceneComputeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrNewSceneComputeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrNewSceneComputeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrNewSceneComputeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = NewSceneComputeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrNewSceneComputeInfoMSFT*>(this);
  }
  uint32_t requestedFeatureCount;
  const SceneComputeFeatureMSFT* requestedFeatures;
  SceneComputeConsistencyMSFT consistency;
  SceneBoundsMSFT bounds;
};
static_assert(sizeof(XrNewSceneComputeInfoMSFT) == sizeof(NewSceneComputeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrNewSceneComputeInfoMSFT pointer to const from a
 * NewSceneComputeInfoMSFT reference to const.
 * @relates NewSceneComputeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNewSceneComputeInfoMSFT const* get(NewSceneComputeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing NewSceneComputeInfoMSFT as
 * the address of a raw XrNewSceneComputeInfoMSFT
 * @relates NewSceneComputeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNewSceneComputeInfoMSFT* put(NewSceneComputeInfoMSFT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrVisualMeshComputeLodInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisualMeshComputeLodInfoMSFT>
 * @xrentity{XrVisualMeshComputeLodInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VisualMeshComputeLodInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VisualMeshComputeLodInfoMSFT(const MeshComputeLodMSFT& lod_, const void* next_ = nullptr)
      : Parent(StructureType::VisualMeshComputeLodInfoMSFT, next_), lod{lod_} {}

  //! Default/empty constructor
  VisualMeshComputeLodInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::VisualMeshComputeLodInfoMSFT, next_), lod{} {}

  //! Default copy constructor
  VisualMeshComputeLodInfoMSFT(const VisualMeshComputeLodInfoMSFT& rhs) = default;
  //! Default copy assignment
  VisualMeshComputeLodInfoMSFT& operator=(const VisualMeshComputeLodInfoMSFT& rhs) = default;
  //! Copy construct from raw
  VisualMeshComputeLodInfoMSFT(const XrVisualMeshComputeLodInfoMSFT& rhs)
      : VisualMeshComputeLodInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VisualMeshComputeLodInfoMSFT& operator=(const XrVisualMeshComputeLodInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVisualMeshComputeLodInfoMSFT&() const {
    return *reinterpret_cast<const XrVisualMeshComputeLodInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVisualMeshComputeLodInfoMSFT&() {
    return *reinterpret_cast<XrVisualMeshComputeLodInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrVisualMeshComputeLodInfoMSFT
  XrVisualMeshComputeLodInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrVisualMeshComputeLodInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVisualMeshComputeLodInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVisualMeshComputeLodInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VisualMeshComputeLodInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrVisualMeshComputeLodInfoMSFT*>(this);
  }
  MeshComputeLodMSFT lod;
};
static_assert(sizeof(XrVisualMeshComputeLodInfoMSFT) == sizeof(VisualMeshComputeLodInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVisualMeshComputeLodInfoMSFT pointer to const from a
 * VisualMeshComputeLodInfoMSFT reference to const.
 * @relates VisualMeshComputeLodInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisualMeshComputeLodInfoMSFT const* get(
    VisualMeshComputeLodInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VisualMeshComputeLodInfoMSFT
 * as the address of a raw XrVisualMeshComputeLodInfoMSFT
 * @relates VisualMeshComputeLodInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisualMeshComputeLodInfoMSFT* put(VisualMeshComputeLodInfoMSFT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentMSFT>
 * @xrentity{XrSceneComponentMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneComponentMSFT {
public:
  //! Constructor initializing all members.
  SceneComponentMSFT(const SceneComponentTypeMSFT& componentType_, const UuidMSFT& id_,
                     const UuidMSFT& parentId_, const Time& updateTime_)
      : componentType{componentType_}, id{id_}, parentId{parentId_}, updateTime{updateTime_} {}

  //! Default/empty constructor
  SceneComponentMSFT()

      : componentType{}, id{}, parentId{}, updateTime{} {}

  //! Default copy constructor
  SceneComponentMSFT(const SceneComponentMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentMSFT& operator=(const SceneComponentMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentMSFT(const XrSceneComponentMSFT& rhs) : SceneComponentMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneComponentMSFT& operator=(const XrSceneComponentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentMSFT&() { return *reinterpret_cast<XrSceneComponentMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneComponentMSFT
  XrSceneComponentMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneComponentMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneComponentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneComponentMSFT{};
    }
    return reinterpret_cast<XrSceneComponentMSFT*>(this);
  }
  SceneComponentTypeMSFT componentType;
  UuidMSFT id;
  UuidMSFT parentId;
  Time updateTime;
};
static_assert(sizeof(XrSceneComponentMSFT) == sizeof(SceneComponentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentMSFT pointer to const from a
 * SceneComponentMSFT reference to const.
 * @relates SceneComponentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentMSFT const* get(SceneComponentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentMSFT as the
 * address of a raw XrSceneComponentMSFT
 * @relates SceneComponentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentMSFT* put(SceneComponentMSFT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentsMSFT>
 * @xrentity{XrSceneComponentsMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentsMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneComponentsMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneComponentsMSFT, next_) {}

  //! Default copy constructor
  SceneComponentsMSFT(const SceneComponentsMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentsMSFT& operator=(const SceneComponentsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentsMSFT(const XrSceneComponentsMSFT& rhs) : SceneComponentsMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneComponentsMSFT& operator=(const XrSceneComponentsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentsMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentsMSFT&() { return *reinterpret_cast<XrSceneComponentsMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneComponentsMSFT
  XrSceneComponentsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneComponentsMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentsMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentsMSFT*>(this);
  }
  uint32_t componentCapacityInput;
  uint32_t componentCountOutput;
  SceneComponentMSFT* components;
};
static_assert(sizeof(XrSceneComponentsMSFT) == sizeof(SceneComponentsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentsMSFT pointer to const from a
 * SceneComponentsMSFT reference to const.
 * @relates SceneComponentsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsMSFT const* get(SceneComponentsMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentsMSFT as the
 * address of a raw XrSceneComponentsMSFT
 * @relates SceneComponentsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsMSFT* put(SceneComponentsMSFT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentsGetInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentsGetInfoMSFT>
 * @xrentity{XrSceneComponentsGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentsGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneComponentsGetInfoMSFT(const SceneComponentTypeMSFT& componentType_,
                             const void* next_ = nullptr)
      : Parent(StructureType::SceneComponentsGetInfoMSFT, next_), componentType{componentType_} {}

  //! Default/empty constructor
  SceneComponentsGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneComponentsGetInfoMSFT, next_), componentType{} {}

  //! Default copy constructor
  SceneComponentsGetInfoMSFT(const SceneComponentsGetInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentsGetInfoMSFT& operator=(const SceneComponentsGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentsGetInfoMSFT(const XrSceneComponentsGetInfoMSFT& rhs)
      : SceneComponentsGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentsGetInfoMSFT& operator=(const XrSceneComponentsGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentsGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentsGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentsGetInfoMSFT&() {
    return *reinterpret_cast<XrSceneComponentsGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentsGetInfoMSFT
  XrSceneComponentsGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentsGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentsGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentsGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentsGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentsGetInfoMSFT*>(this);
  }
  SceneComponentTypeMSFT componentType;
};
static_assert(sizeof(XrSceneComponentsGetInfoMSFT) == sizeof(SceneComponentsGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentsGetInfoMSFT pointer to const from a
 * SceneComponentsGetInfoMSFT reference to const.
 * @relates SceneComponentsGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsGetInfoMSFT const* get(
    SceneComponentsGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentsGetInfoMSFT as
 * the address of a raw XrSceneComponentsGetInfoMSFT
 * @relates SceneComponentsGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsGetInfoMSFT* put(SceneComponentsGetInfoMSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentLocationMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentLocationMSFT>
 * @xrentity{XrSceneComponentLocationMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneComponentLocationMSFT {
public:
  //! Constructor initializing all members.
  SceneComponentLocationMSFT(const SpaceLocationFlags& flags_, const Posef& pose_)
      : flags{flags_}, pose{pose_} {}

  //! Default/empty constructor
  SceneComponentLocationMSFT()

      : flags{}, pose{} {}

  //! Default copy constructor
  SceneComponentLocationMSFT(const SceneComponentLocationMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentLocationMSFT& operator=(const SceneComponentLocationMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentLocationMSFT(const XrSceneComponentLocationMSFT& rhs)
      : SceneComponentLocationMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentLocationMSFT& operator=(const XrSceneComponentLocationMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentLocationMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentLocationMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentLocationMSFT&() {
    return *reinterpret_cast<XrSceneComponentLocationMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentLocationMSFT
  XrSceneComponentLocationMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentLocationMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentLocationMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneComponentLocationMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneComponentLocationMSFT{};
    }
    return reinterpret_cast<XrSceneComponentLocationMSFT*>(this);
  }
  SpaceLocationFlags flags;
  Posef pose;
};
static_assert(sizeof(XrSceneComponentLocationMSFT) == sizeof(SceneComponentLocationMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentLocationMSFT pointer to const from a
 * SceneComponentLocationMSFT reference to const.
 * @relates SceneComponentLocationMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationMSFT const* get(
    SceneComponentLocationMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentLocationMSFT as
 * the address of a raw XrSceneComponentLocationMSFT
 * @relates SceneComponentLocationMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationMSFT* put(SceneComponentLocationMSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentLocationsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentLocationsMSFT>
 * @xrentity{XrSceneComponentLocationsMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentLocationsMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneComponentLocationsMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneComponentLocationsMSFT, next_) {}

  //! Default copy constructor
  SceneComponentLocationsMSFT(const SceneComponentLocationsMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentLocationsMSFT& operator=(const SceneComponentLocationsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentLocationsMSFT(const XrSceneComponentLocationsMSFT& rhs)
      : SceneComponentLocationsMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentLocationsMSFT& operator=(const XrSceneComponentLocationsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentLocationsMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentLocationsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentLocationsMSFT&() {
    return *reinterpret_cast<XrSceneComponentLocationsMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentLocationsMSFT
  XrSceneComponentLocationsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentLocationsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentLocationsMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentLocationsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentLocationsMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentLocationsMSFT*>(this);
  }
  uint32_t locationCount;
  SceneComponentLocationMSFT* locations;
};
static_assert(sizeof(XrSceneComponentLocationsMSFT) == sizeof(SceneComponentLocationsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentLocationsMSFT pointer to const from a
 * SceneComponentLocationsMSFT reference to const.
 * @relates SceneComponentLocationsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationsMSFT const* get(
    SceneComponentLocationsMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentLocationsMSFT
 * as the address of a raw XrSceneComponentLocationsMSFT
 * @relates SceneComponentLocationsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationsMSFT* put(SceneComponentLocationsMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentsLocateInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentsLocateInfoMSFT>
 * @xrentity{XrSceneComponentsLocateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentsLocateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneComponentsLocateInfoMSFT(const Space& baseSpace_, const Time& time_,
                                uint32_t componentIdCount_, const UuidMSFT* componentIds_,
                                const void* next_ = nullptr)
      : Parent(StructureType::SceneComponentsLocateInfoMSFT, next_),
        baseSpace{baseSpace_},
        time{time_},
        componentIdCount{componentIdCount_},
        componentIds{componentIds_} {}

  //! Default/empty constructor
  SceneComponentsLocateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneComponentsLocateInfoMSFT, next_),
        baseSpace{},
        time{},
        componentIdCount{0},
        componentIds{nullptr} {}

  //! Default copy constructor
  SceneComponentsLocateInfoMSFT(const SceneComponentsLocateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentsLocateInfoMSFT& operator=(const SceneComponentsLocateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentsLocateInfoMSFT(const XrSceneComponentsLocateInfoMSFT& rhs)
      : SceneComponentsLocateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentsLocateInfoMSFT& operator=(const XrSceneComponentsLocateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentsLocateInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentsLocateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentsLocateInfoMSFT&() {
    return *reinterpret_cast<XrSceneComponentsLocateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentsLocateInfoMSFT
  XrSceneComponentsLocateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentsLocateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentsLocateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentsLocateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentsLocateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentsLocateInfoMSFT*>(this);
  }
  Space baseSpace;
  Time time;
  uint32_t componentIdCount;
  const UuidMSFT* componentIds;
};
static_assert(sizeof(XrSceneComponentsLocateInfoMSFT) == sizeof(SceneComponentsLocateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentsLocateInfoMSFT pointer to const from a
 * SceneComponentsLocateInfoMSFT reference to const.
 * @relates SceneComponentsLocateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsLocateInfoMSFT const* get(
    SceneComponentsLocateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentsLocateInfoMSFT
 * as the address of a raw XrSceneComponentsLocateInfoMSFT
 * @relates SceneComponentsLocateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsLocateInfoMSFT* put(SceneComponentsLocateInfoMSFT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObjectMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectMSFT>
 * @xrentity{XrSceneObjectMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneObjectMSFT {
public:
  //! Constructor initializing all members.
  SceneObjectMSFT(const SceneObjectTypeMSFT& objectType_) : objectType{objectType_} {}

  //! Default/empty constructor
  SceneObjectMSFT()

      : objectType{} {}

  //! Default copy constructor
  SceneObjectMSFT(const SceneObjectMSFT& rhs) = default;
  //! Default copy assignment
  SceneObjectMSFT& operator=(const SceneObjectMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObjectMSFT(const XrSceneObjectMSFT& rhs) : SceneObjectMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneObjectMSFT& operator=(const XrSceneObjectMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObjectMSFT&() const {
    return *reinterpret_cast<const XrSceneObjectMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObjectMSFT&() { return *reinterpret_cast<XrSceneObjectMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneObjectMSFT
  XrSceneObjectMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObjectMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneObjectMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneObjectMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneObjectMSFT{};
    }
    return reinterpret_cast<XrSceneObjectMSFT*>(this);
  }
  SceneObjectTypeMSFT objectType;
};
static_assert(sizeof(XrSceneObjectMSFT) == sizeof(SceneObjectMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObjectMSFT pointer to const from a SceneObjectMSFT
 * reference to const.
 * @relates SceneObjectMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectMSFT const* get(SceneObjectMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneObjectMSFT as the
 * address of a raw XrSceneObjectMSFT
 * @relates SceneObjectMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectMSFT* put(SceneObjectMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObjectsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectsMSFT>
 * @xrentity{XrSceneObjectsMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneObjectsMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneObjectsMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneObjectsMSFT, next_) {}

  //! Default copy constructor
  SceneObjectsMSFT(const SceneObjectsMSFT& rhs) = default;
  //! Default copy assignment
  SceneObjectsMSFT& operator=(const SceneObjectsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObjectsMSFT(const XrSceneObjectsMSFT& rhs) : SceneObjectsMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneObjectsMSFT& operator=(const XrSceneObjectsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObjectsMSFT&() const {
    return *reinterpret_cast<const XrSceneObjectsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObjectsMSFT&() { return *reinterpret_cast<XrSceneObjectsMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneObjectsMSFT
  XrSceneObjectsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObjectsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneObjectsMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneObjectsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneObjectsMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneObjectsMSFT*>(this);
  }
  uint32_t sceneObjectCount;
  SceneObjectMSFT* sceneObjects;
};
static_assert(sizeof(XrSceneObjectsMSFT) == sizeof(SceneObjectsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObjectsMSFT pointer to const from a
 * SceneObjectsMSFT reference to const.
 * @relates SceneObjectsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectsMSFT const* get(SceneObjectsMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneObjectsMSFT as the
 * address of a raw XrSceneObjectsMSFT
 * @relates SceneObjectsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectsMSFT* put(SceneObjectsMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentParentFilterInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentParentFilterInfoMSFT>
 * @xrentity{XrSceneComponentParentFilterInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentParentFilterInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneComponentParentFilterInfoMSFT(const UuidMSFT& parentId_, const void* next_ = nullptr)
      : Parent(StructureType::SceneComponentParentFilterInfoMSFT, next_), parentId{parentId_} {}

  //! Default/empty constructor
  SceneComponentParentFilterInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneComponentParentFilterInfoMSFT, next_), parentId{} {}

  //! Default copy constructor
  SceneComponentParentFilterInfoMSFT(const SceneComponentParentFilterInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentParentFilterInfoMSFT& operator=(const SceneComponentParentFilterInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SceneComponentParentFilterInfoMSFT(const XrSceneComponentParentFilterInfoMSFT& rhs)
      : SceneComponentParentFilterInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentParentFilterInfoMSFT& operator=(const XrSceneComponentParentFilterInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentParentFilterInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentParentFilterInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentParentFilterInfoMSFT&() {
    return *reinterpret_cast<XrSceneComponentParentFilterInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentParentFilterInfoMSFT
  XrSceneComponentParentFilterInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentParentFilterInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentParentFilterInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentParentFilterInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentParentFilterInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentParentFilterInfoMSFT*>(this);
  }
  UuidMSFT parentId;
};
static_assert(sizeof(XrSceneComponentParentFilterInfoMSFT) ==
                  sizeof(SceneComponentParentFilterInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentParentFilterInfoMSFT pointer to const from
 * a SceneComponentParentFilterInfoMSFT reference to const.
 * @relates SceneComponentParentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentParentFilterInfoMSFT const* get(
    SceneComponentParentFilterInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SceneComponentParentFilterInfoMSFT as the address of a raw XrSceneComponentParentFilterInfoMSFT
 * @relates SceneComponentParentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentParentFilterInfoMSFT* put(
    SceneComponentParentFilterInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObjectTypesFilterInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectTypesFilterInfoMSFT>
 * @xrentity{XrSceneObjectTypesFilterInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneObjectTypesFilterInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneObjectTypesFilterInfoMSFT(uint32_t objectTypeCount_, const SceneObjectTypeMSFT* objectTypes_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::SceneObjectTypesFilterInfoMSFT, next_),
        objectTypeCount{objectTypeCount_},
        objectTypes{objectTypes_} {}

  //! Default/empty constructor
  SceneObjectTypesFilterInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneObjectTypesFilterInfoMSFT, next_),
        objectTypeCount{0},
        objectTypes{nullptr} {}

  //! Default copy constructor
  SceneObjectTypesFilterInfoMSFT(const SceneObjectTypesFilterInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneObjectTypesFilterInfoMSFT& operator=(const SceneObjectTypesFilterInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObjectTypesFilterInfoMSFT(const XrSceneObjectTypesFilterInfoMSFT& rhs)
      : SceneObjectTypesFilterInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneObjectTypesFilterInfoMSFT& operator=(const XrSceneObjectTypesFilterInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObjectTypesFilterInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneObjectTypesFilterInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObjectTypesFilterInfoMSFT&() {
    return *reinterpret_cast<XrSceneObjectTypesFilterInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneObjectTypesFilterInfoMSFT
  XrSceneObjectTypesFilterInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObjectTypesFilterInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneObjectTypesFilterInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneObjectTypesFilterInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneObjectTypesFilterInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneObjectTypesFilterInfoMSFT*>(this);
  }
  uint32_t objectTypeCount;
  const SceneObjectTypeMSFT* objectTypes;
};
static_assert(sizeof(XrSceneObjectTypesFilterInfoMSFT) == sizeof(SceneObjectTypesFilterInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObjectTypesFilterInfoMSFT pointer to const from a
 * SceneObjectTypesFilterInfoMSFT reference to const.
 * @relates SceneObjectTypesFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectTypesFilterInfoMSFT const* get(
    SceneObjectTypesFilterInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SceneObjectTypesFilterInfoMSFT as the address of a raw XrSceneObjectTypesFilterInfoMSFT
 * @relates SceneObjectTypesFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectTypesFilterInfoMSFT* put(SceneObjectTypesFilterInfoMSFT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrScenePlaneMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlaneMSFT>
 * @xrentity{XrScenePlaneMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ScenePlaneMSFT {
public:
  //! Constructor initializing all members.
  ScenePlaneMSFT(const ScenePlaneAlignmentTypeMSFT& alignment_, const Extent2Df& size_,
                 uint64_t meshBufferId_, const Bool32& supportsIndicesUint16_)
      : alignment{alignment_},
        size{size_},
        meshBufferId{meshBufferId_},
        supportsIndicesUint16{supportsIndicesUint16_} {}

  //! Default/empty constructor
  ScenePlaneMSFT()

      : alignment{}, size{}, meshBufferId{0}, supportsIndicesUint16{false} {}

  //! Default copy constructor
  ScenePlaneMSFT(const ScenePlaneMSFT& rhs) = default;
  //! Default copy assignment
  ScenePlaneMSFT& operator=(const ScenePlaneMSFT& rhs) = default;
  //! Copy construct from raw
  ScenePlaneMSFT(const XrScenePlaneMSFT& rhs) : ScenePlaneMSFT() { *put() = rhs; }
  //! Copy assign from raw
  ScenePlaneMSFT& operator=(const XrScenePlaneMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrScenePlaneMSFT&() const {
    return *reinterpret_cast<const XrScenePlaneMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrScenePlaneMSFT&() { return *reinterpret_cast<XrScenePlaneMSFT*>(this); }

  //! Accessor for this as the address of a raw XrScenePlaneMSFT
  XrScenePlaneMSFT const* get() const noexcept {
    return reinterpret_cast<XrScenePlaneMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrScenePlaneMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrScenePlaneMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = ScenePlaneMSFT{};
    }
    return reinterpret_cast<XrScenePlaneMSFT*>(this);
  }
  ScenePlaneAlignmentTypeMSFT alignment;
  Extent2Df size;
  uint64_t meshBufferId;
  Bool32 supportsIndicesUint16;
};
static_assert(sizeof(XrScenePlaneMSFT) == sizeof(ScenePlaneMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrScenePlaneMSFT pointer to const from a ScenePlaneMSFT
 * reference to const.
 * @relates ScenePlaneMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneMSFT const* get(ScenePlaneMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ScenePlaneMSFT as the address
 * of a raw XrScenePlaneMSFT
 * @relates ScenePlaneMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneMSFT* put(ScenePlaneMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrScenePlanesMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlanesMSFT>
 * @xrentity{XrScenePlanesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ScenePlanesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ScenePlanesMSFT(void* next_ = nullptr)

      : Parent(StructureType::ScenePlanesMSFT, next_) {}

  //! Default copy constructor
  ScenePlanesMSFT(const ScenePlanesMSFT& rhs) = default;
  //! Default copy assignment
  ScenePlanesMSFT& operator=(const ScenePlanesMSFT& rhs) = default;
  //! Copy construct from raw
  ScenePlanesMSFT(const XrScenePlanesMSFT& rhs) : ScenePlanesMSFT() { *put() = rhs; }
  //! Copy assign from raw
  ScenePlanesMSFT& operator=(const XrScenePlanesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrScenePlanesMSFT&() const {
    return *reinterpret_cast<const XrScenePlanesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrScenePlanesMSFT&() { return *reinterpret_cast<XrScenePlanesMSFT*>(this); }

  //! Accessor for this as the address of a raw XrScenePlanesMSFT
  XrScenePlanesMSFT const* get() const noexcept {
    return reinterpret_cast<XrScenePlanesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrScenePlanesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrScenePlanesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ScenePlanesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrScenePlanesMSFT*>(this);
  }
  uint32_t scenePlaneCount;
  ScenePlaneMSFT* scenePlanes;
};
static_assert(sizeof(XrScenePlanesMSFT) == sizeof(ScenePlanesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrScenePlanesMSFT pointer to const from a ScenePlanesMSFT
 * reference to const.
 * @relates ScenePlanesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlanesMSFT const* get(ScenePlanesMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ScenePlanesMSFT as the
 * address of a raw XrScenePlanesMSFT
 * @relates ScenePlanesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlanesMSFT* put(ScenePlanesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrScenePlaneAlignmentFilterInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlaneAlignmentFilterInfoMSFT>
 * @xrentity{XrScenePlaneAlignmentFilterInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ScenePlaneAlignmentFilterInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ScenePlaneAlignmentFilterInfoMSFT(uint32_t alignmentCount_,
                                    const ScenePlaneAlignmentTypeMSFT* alignments_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::ScenePlaneAlignmentFilterInfoMSFT, next_),
        alignmentCount{alignmentCount_},
        alignments{alignments_} {}

  //! Default/empty constructor
  ScenePlaneAlignmentFilterInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::ScenePlaneAlignmentFilterInfoMSFT, next_),
        alignmentCount{0},
        alignments{nullptr} {}

  //! Default copy constructor
  ScenePlaneAlignmentFilterInfoMSFT(const ScenePlaneAlignmentFilterInfoMSFT& rhs) = default;
  //! Default copy assignment
  ScenePlaneAlignmentFilterInfoMSFT& operator=(const ScenePlaneAlignmentFilterInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  ScenePlaneAlignmentFilterInfoMSFT(const XrScenePlaneAlignmentFilterInfoMSFT& rhs)
      : ScenePlaneAlignmentFilterInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ScenePlaneAlignmentFilterInfoMSFT& operator=(const XrScenePlaneAlignmentFilterInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrScenePlaneAlignmentFilterInfoMSFT&() const {
    return *reinterpret_cast<const XrScenePlaneAlignmentFilterInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrScenePlaneAlignmentFilterInfoMSFT&() {
    return *reinterpret_cast<XrScenePlaneAlignmentFilterInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrScenePlaneAlignmentFilterInfoMSFT
  XrScenePlaneAlignmentFilterInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrScenePlaneAlignmentFilterInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrScenePlaneAlignmentFilterInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrScenePlaneAlignmentFilterInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ScenePlaneAlignmentFilterInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrScenePlaneAlignmentFilterInfoMSFT*>(this);
  }
  uint32_t alignmentCount;
  const ScenePlaneAlignmentTypeMSFT* alignments;
};
static_assert(sizeof(XrScenePlaneAlignmentFilterInfoMSFT) ==
                  sizeof(ScenePlaneAlignmentFilterInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrScenePlaneAlignmentFilterInfoMSFT pointer to const from
 * a ScenePlaneAlignmentFilterInfoMSFT reference to const.
 * @relates ScenePlaneAlignmentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneAlignmentFilterInfoMSFT const* get(
    ScenePlaneAlignmentFilterInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ScenePlaneAlignmentFilterInfoMSFT as the address of a raw XrScenePlaneAlignmentFilterInfoMSFT
 * @relates ScenePlaneAlignmentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneAlignmentFilterInfoMSFT* put(
    ScenePlaneAlignmentFilterInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshMSFT>
 * @xrentity{XrSceneMeshMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneMeshMSFT {
public:
  //! Constructor initializing all members.
  SceneMeshMSFT(uint64_t meshBufferId_, const Bool32& supportsIndicesUint16_)
      : meshBufferId{meshBufferId_}, supportsIndicesUint16{supportsIndicesUint16_} {}

  //! Default/empty constructor
  SceneMeshMSFT()

      : meshBufferId{0}, supportsIndicesUint16{false} {}

  //! Default copy constructor
  SceneMeshMSFT(const SceneMeshMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshMSFT& operator=(const SceneMeshMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshMSFT(const XrSceneMeshMSFT& rhs) : SceneMeshMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMeshMSFT& operator=(const XrSceneMeshMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshMSFT&() { return *reinterpret_cast<XrSceneMeshMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMeshMSFT
  XrSceneMeshMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMeshMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneMeshMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneMeshMSFT{};
    }
    return reinterpret_cast<XrSceneMeshMSFT*>(this);
  }
  uint64_t meshBufferId;
  Bool32 supportsIndicesUint16;
};
static_assert(sizeof(XrSceneMeshMSFT) == sizeof(SceneMeshMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshMSFT pointer to const from a SceneMeshMSFT
 * reference to const.
 * @relates SceneMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshMSFT const* get(SceneMeshMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshMSFT as the address
 * of a raw XrSceneMeshMSFT
 * @relates SceneMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshMSFT* put(SceneMeshMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshesMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshesMSFT>
 * @xrentity{XrSceneMeshesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshesMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshesMSFT, next_) {}

  //! Default copy constructor
  SceneMeshesMSFT(const SceneMeshesMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshesMSFT& operator=(const SceneMeshesMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshesMSFT(const XrSceneMeshesMSFT& rhs) : SceneMeshesMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMeshesMSFT& operator=(const XrSceneMeshesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshesMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshesMSFT&() { return *reinterpret_cast<XrSceneMeshesMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMeshesMSFT
  XrSceneMeshesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMeshesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshesMSFT*>(this);
  }
  uint32_t sceneMeshCount;
  SceneMeshMSFT* sceneMeshes;
};
static_assert(sizeof(XrSceneMeshesMSFT) == sizeof(SceneMeshesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshesMSFT pointer to const from a SceneMeshesMSFT
 * reference to const.
 * @relates SceneMeshesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshesMSFT const* get(SceneMeshesMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshesMSFT as the
 * address of a raw XrSceneMeshesMSFT
 * @relates SceneMeshesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshesMSFT* put(SceneMeshesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshBuffersGetInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshBuffersGetInfoMSFT>
 * @xrentity{XrSceneMeshBuffersGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshBuffersGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneMeshBuffersGetInfoMSFT(uint64_t meshBufferId_, const void* next_ = nullptr)
      : Parent(StructureType::SceneMeshBuffersGetInfoMSFT, next_), meshBufferId{meshBufferId_} {}

  //! Default/empty constructor
  SceneMeshBuffersGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneMeshBuffersGetInfoMSFT, next_), meshBufferId{0} {}

  //! Default copy constructor
  SceneMeshBuffersGetInfoMSFT(const SceneMeshBuffersGetInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshBuffersGetInfoMSFT& operator=(const SceneMeshBuffersGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshBuffersGetInfoMSFT(const XrSceneMeshBuffersGetInfoMSFT& rhs)
      : SceneMeshBuffersGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshBuffersGetInfoMSFT& operator=(const XrSceneMeshBuffersGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshBuffersGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshBuffersGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshBuffersGetInfoMSFT&() {
    return *reinterpret_cast<XrSceneMeshBuffersGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshBuffersGetInfoMSFT
  XrSceneMeshBuffersGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshBuffersGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshBuffersGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshBuffersGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshBuffersGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshBuffersGetInfoMSFT*>(this);
  }
  uint64_t meshBufferId;
};
static_assert(sizeof(XrSceneMeshBuffersGetInfoMSFT) == sizeof(SceneMeshBuffersGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshBuffersGetInfoMSFT pointer to const from a
 * SceneMeshBuffersGetInfoMSFT reference to const.
 * @relates SceneMeshBuffersGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersGetInfoMSFT const* get(
    SceneMeshBuffersGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshBuffersGetInfoMSFT
 * as the address of a raw XrSceneMeshBuffersGetInfoMSFT
 * @relates SceneMeshBuffersGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersGetInfoMSFT* put(SceneMeshBuffersGetInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshBuffersMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshBuffersMSFT>
 * @xrentity{XrSceneMeshBuffersMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshBuffersMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshBuffersMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshBuffersMSFT, next_) {}

  //! Default copy constructor
  SceneMeshBuffersMSFT(const SceneMeshBuffersMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshBuffersMSFT& operator=(const SceneMeshBuffersMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshBuffersMSFT(const XrSceneMeshBuffersMSFT& rhs) : SceneMeshBuffersMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMeshBuffersMSFT& operator=(const XrSceneMeshBuffersMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshBuffersMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshBuffersMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshBuffersMSFT&() { return *reinterpret_cast<XrSceneMeshBuffersMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMeshBuffersMSFT
  XrSceneMeshBuffersMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshBuffersMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMeshBuffersMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshBuffersMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshBuffersMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshBuffersMSFT*>(this);
  }
};
static_assert(sizeof(XrSceneMeshBuffersMSFT) == sizeof(SceneMeshBuffersMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshBuffersMSFT pointer to const from a
 * SceneMeshBuffersMSFT reference to const.
 * @relates SceneMeshBuffersMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersMSFT const* get(SceneMeshBuffersMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshBuffersMSFT as the
 * address of a raw XrSceneMeshBuffersMSFT
 * @relates SceneMeshBuffersMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersMSFT* put(SceneMeshBuffersMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshVertexBufferMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshVertexBufferMSFT>
 * @xrentity{XrSceneMeshVertexBufferMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshVertexBufferMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshVertexBufferMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshVertexBufferMSFT, next_) {}

  //! Default copy constructor
  SceneMeshVertexBufferMSFT(const SceneMeshVertexBufferMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshVertexBufferMSFT& operator=(const SceneMeshVertexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshVertexBufferMSFT(const XrSceneMeshVertexBufferMSFT& rhs) : SceneMeshVertexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshVertexBufferMSFT& operator=(const XrSceneMeshVertexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshVertexBufferMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshVertexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshVertexBufferMSFT&() {
    return *reinterpret_cast<XrSceneMeshVertexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshVertexBufferMSFT
  XrSceneMeshVertexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshVertexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshVertexBufferMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshVertexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshVertexBufferMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshVertexBufferMSFT*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector3f* vertices;
};
static_assert(sizeof(XrSceneMeshVertexBufferMSFT) == sizeof(SceneMeshVertexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshVertexBufferMSFT pointer to const from a
 * SceneMeshVertexBufferMSFT reference to const.
 * @relates SceneMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshVertexBufferMSFT const* get(
    SceneMeshVertexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshVertexBufferMSFT as
 * the address of a raw XrSceneMeshVertexBufferMSFT
 * @relates SceneMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshVertexBufferMSFT* put(SceneMeshVertexBufferMSFT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshIndicesUint32MSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshIndicesUint32MSFT>
 * @xrentity{XrSceneMeshIndicesUint32MSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshIndicesUint32MSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshIndicesUint32MSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshIndicesUint32MSFT, next_) {}

  //! Default copy constructor
  SceneMeshIndicesUint32MSFT(const SceneMeshIndicesUint32MSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshIndicesUint32MSFT& operator=(const SceneMeshIndicesUint32MSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshIndicesUint32MSFT(const XrSceneMeshIndicesUint32MSFT& rhs)
      : SceneMeshIndicesUint32MSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshIndicesUint32MSFT& operator=(const XrSceneMeshIndicesUint32MSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshIndicesUint32MSFT&() const {
    return *reinterpret_cast<const XrSceneMeshIndicesUint32MSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshIndicesUint32MSFT&() {
    return *reinterpret_cast<XrSceneMeshIndicesUint32MSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshIndicesUint32MSFT
  XrSceneMeshIndicesUint32MSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshIndicesUint32MSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshIndicesUint32MSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshIndicesUint32MSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshIndicesUint32MSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshIndicesUint32MSFT*>(this);
  }
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrSceneMeshIndicesUint32MSFT) == sizeof(SceneMeshIndicesUint32MSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshIndicesUint32MSFT pointer to const from a
 * SceneMeshIndicesUint32MSFT reference to const.
 * @relates SceneMeshIndicesUint32MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint32MSFT const* get(
    SceneMeshIndicesUint32MSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshIndicesUint32MSFT as
 * the address of a raw XrSceneMeshIndicesUint32MSFT
 * @relates SceneMeshIndicesUint32MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint32MSFT* put(SceneMeshIndicesUint32MSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshIndicesUint16MSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshIndicesUint16MSFT>
 * @xrentity{XrSceneMeshIndicesUint16MSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshIndicesUint16MSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshIndicesUint16MSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshIndicesUint16MSFT, next_) {}

  //! Default copy constructor
  SceneMeshIndicesUint16MSFT(const SceneMeshIndicesUint16MSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshIndicesUint16MSFT& operator=(const SceneMeshIndicesUint16MSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshIndicesUint16MSFT(const XrSceneMeshIndicesUint16MSFT& rhs)
      : SceneMeshIndicesUint16MSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshIndicesUint16MSFT& operator=(const XrSceneMeshIndicesUint16MSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshIndicesUint16MSFT&() const {
    return *reinterpret_cast<const XrSceneMeshIndicesUint16MSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshIndicesUint16MSFT&() {
    return *reinterpret_cast<XrSceneMeshIndicesUint16MSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshIndicesUint16MSFT
  XrSceneMeshIndicesUint16MSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshIndicesUint16MSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshIndicesUint16MSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshIndicesUint16MSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshIndicesUint16MSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshIndicesUint16MSFT*>(this);
  }
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint16_t* indices;
};
static_assert(sizeof(XrSceneMeshIndicesUint16MSFT) == sizeof(SceneMeshIndicesUint16MSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshIndicesUint16MSFT pointer to const from a
 * SceneMeshIndicesUint16MSFT reference to const.
 * @relates SceneMeshIndicesUint16MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint16MSFT const* get(
    SceneMeshIndicesUint16MSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshIndicesUint16MSFT as
 * the address of a raw XrSceneMeshIndicesUint16MSFT
 * @relates SceneMeshIndicesUint16MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint16MSFT* put(SceneMeshIndicesUint16MSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding_serialization
/*!
 * C++ projection of XrSerializedSceneFragmentDataGetInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding_serialization` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSerializedSceneFragmentDataGetInfoMSFT>
 * @xrentity{XrSerializedSceneFragmentDataGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SerializedSceneFragmentDataGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SerializedSceneFragmentDataGetInfoMSFT(const UuidMSFT& sceneFragmentId_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::SerializedSceneFragmentDataGetInfoMSFT, next_),
        sceneFragmentId{sceneFragmentId_} {}

  //! Default/empty constructor
  SerializedSceneFragmentDataGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SerializedSceneFragmentDataGetInfoMSFT, next_), sceneFragmentId{} {}

  //! Default copy constructor
  SerializedSceneFragmentDataGetInfoMSFT(const SerializedSceneFragmentDataGetInfoMSFT& rhs) =
      default;
  //! Default copy assignment
  SerializedSceneFragmentDataGetInfoMSFT& operator=(
      const SerializedSceneFragmentDataGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SerializedSceneFragmentDataGetInfoMSFT(const XrSerializedSceneFragmentDataGetInfoMSFT& rhs)
      : SerializedSceneFragmentDataGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SerializedSceneFragmentDataGetInfoMSFT& operator=(
      const XrSerializedSceneFragmentDataGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSerializedSceneFragmentDataGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSerializedSceneFragmentDataGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSerializedSceneFragmentDataGetInfoMSFT&() {
    return *reinterpret_cast<XrSerializedSceneFragmentDataGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSerializedSceneFragmentDataGetInfoMSFT
  XrSerializedSceneFragmentDataGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSerializedSceneFragmentDataGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSerializedSceneFragmentDataGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSerializedSceneFragmentDataGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SerializedSceneFragmentDataGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSerializedSceneFragmentDataGetInfoMSFT*>(this);
  }
  UuidMSFT sceneFragmentId;
};
static_assert(sizeof(XrSerializedSceneFragmentDataGetInfoMSFT) ==
                  sizeof(SerializedSceneFragmentDataGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSerializedSceneFragmentDataGetInfoMSFT pointer to const
 * from a SerializedSceneFragmentDataGetInfoMSFT reference to const.
 * @relates SerializedSceneFragmentDataGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSerializedSceneFragmentDataGetInfoMSFT const* get(
    SerializedSceneFragmentDataGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SerializedSceneFragmentDataGetInfoMSFT as the address of a raw
 * XrSerializedSceneFragmentDataGetInfoMSFT
 * @relates SerializedSceneFragmentDataGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSerializedSceneFragmentDataGetInfoMSFT* put(
    SerializedSceneFragmentDataGetInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_MSFT_scene_understanding_serialization
/*!
 * C++ projection of XrDeserializeSceneFragmentMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding_serialization` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDeserializeSceneFragmentMSFT>
 * @xrentity{XrDeserializeSceneFragmentMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS DeserializeSceneFragmentMSFT {
public:
  //! Constructor initializing all members.
  DeserializeSceneFragmentMSFT(uint32_t bufferSize_, const uint8_t* buffer_)
      : bufferSize{bufferSize_}, buffer{buffer_} {}

  //! Default/empty constructor
  DeserializeSceneFragmentMSFT()

      : bufferSize{0}, buffer{nullptr} {}

  //! Default copy constructor
  DeserializeSceneFragmentMSFT(const DeserializeSceneFragmentMSFT& rhs) = default;
  //! Default copy assignment
  DeserializeSceneFragmentMSFT& operator=(const DeserializeSceneFragmentMSFT& rhs) = default;
  //! Copy construct from raw
  DeserializeSceneFragmentMSFT(const XrDeserializeSceneFragmentMSFT& rhs)
      : DeserializeSceneFragmentMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DeserializeSceneFragmentMSFT& operator=(const XrDeserializeSceneFragmentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDeserializeSceneFragmentMSFT&() const {
    return *reinterpret_cast<const XrDeserializeSceneFragmentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDeserializeSceneFragmentMSFT&() {
    return *reinterpret_cast<XrDeserializeSceneFragmentMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrDeserializeSceneFragmentMSFT
  XrDeserializeSceneFragmentMSFT const* get() const noexcept {
    return reinterpret_cast<XrDeserializeSceneFragmentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDeserializeSceneFragmentMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrDeserializeSceneFragmentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = DeserializeSceneFragmentMSFT{};
    }
    return reinterpret_cast<XrDeserializeSceneFragmentMSFT*>(this);
  }
  uint32_t bufferSize;
  const uint8_t* buffer;
};
static_assert(sizeof(XrDeserializeSceneFragmentMSFT) == sizeof(DeserializeSceneFragmentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDeserializeSceneFragmentMSFT pointer to const from a
 * DeserializeSceneFragmentMSFT reference to const.
 * @relates DeserializeSceneFragmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDeserializeSceneFragmentMSFT const* get(
    DeserializeSceneFragmentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DeserializeSceneFragmentMSFT
 * as the address of a raw XrDeserializeSceneFragmentMSFT
 * @relates DeserializeSceneFragmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDeserializeSceneFragmentMSFT* put(DeserializeSceneFragmentMSFT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_MSFT_scene_understanding_serialization
/*!
 * C++ projection of XrSceneDeserializeInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding_serialization` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneDeserializeInfoMSFT>
 * @xrentity{XrSceneDeserializeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneDeserializeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneDeserializeInfoMSFT(uint32_t fragmentCount_, const DeserializeSceneFragmentMSFT* fragments_,
                           const void* next_ = nullptr)
      : Parent(StructureType::SceneDeserializeInfoMSFT, next_),
        fragmentCount{fragmentCount_},
        fragments{fragments_} {}

  //! Default/empty constructor
  SceneDeserializeInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneDeserializeInfoMSFT, next_),
        fragmentCount{0},
        fragments{nullptr} {}

  //! Default copy constructor
  SceneDeserializeInfoMSFT(const SceneDeserializeInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneDeserializeInfoMSFT& operator=(const SceneDeserializeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneDeserializeInfoMSFT(const XrSceneDeserializeInfoMSFT& rhs) : SceneDeserializeInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneDeserializeInfoMSFT& operator=(const XrSceneDeserializeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneDeserializeInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneDeserializeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneDeserializeInfoMSFT&() {
    return *reinterpret_cast<XrSceneDeserializeInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneDeserializeInfoMSFT
  XrSceneDeserializeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneDeserializeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneDeserializeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneDeserializeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneDeserializeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneDeserializeInfoMSFT*>(this);
  }
  uint32_t fragmentCount;
  const DeserializeSceneFragmentMSFT* fragments;
};
static_assert(sizeof(XrSceneDeserializeInfoMSFT) == sizeof(SceneDeserializeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneDeserializeInfoMSFT pointer to const from a
 * SceneDeserializeInfoMSFT reference to const.
 * @relates SceneDeserializeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneDeserializeInfoMSFT const* get(SceneDeserializeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneDeserializeInfoMSFT as
 * the address of a raw XrSceneDeserializeInfoMSFT
 * @relates SceneDeserializeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneDeserializeInfoMSFT* put(SceneDeserializeInfoMSFT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_FB_display_refresh_rate
/*!
 * C++ projection of XrEventDataDisplayRefreshRateChangedFB
 *
 * Provided by the `XR_FB_display_refresh_rate` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataDisplayRefreshRateChangedFB>
 * @xrentity{XrEventDataDisplayRefreshRateChangedFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataDisplayRefreshRateChangedFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataDisplayRefreshRateChangedFB(float fromDisplayRefreshRate_, float toDisplayRefreshRate_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::EventDataDisplayRefreshRateChangedFB, next_),
        fromDisplayRefreshRate{fromDisplayRefreshRate_},
        toDisplayRefreshRate{toDisplayRefreshRate_} {}

  //! Default/empty constructor
  EventDataDisplayRefreshRateChangedFB(const void* next_ = nullptr)

      : Parent(StructureType::EventDataDisplayRefreshRateChangedFB, next_),
        fromDisplayRefreshRate{0.0f},
        toDisplayRefreshRate{0.0f} {}

  //! Default copy constructor
  EventDataDisplayRefreshRateChangedFB(const EventDataDisplayRefreshRateChangedFB& rhs) = default;
  //! Default copy assignment
  EventDataDisplayRefreshRateChangedFB& operator=(const EventDataDisplayRefreshRateChangedFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataDisplayRefreshRateChangedFB(const XrEventDataDisplayRefreshRateChangedFB& rhs)
      : EventDataDisplayRefreshRateChangedFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataDisplayRefreshRateChangedFB& operator=(
      const XrEventDataDisplayRefreshRateChangedFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataDisplayRefreshRateChangedFB&() const {
    return *reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataDisplayRefreshRateChangedFB&() {
    return *reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataDisplayRefreshRateChangedFB
  XrEventDataDisplayRefreshRateChangedFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataDisplayRefreshRateChangedFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataDisplayRefreshRateChangedFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataDisplayRefreshRateChangedFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
  }
  float fromDisplayRefreshRate;
  float toDisplayRefreshRate;
};
static_assert(sizeof(XrEventDataDisplayRefreshRateChangedFB) ==
                  sizeof(EventDataDisplayRefreshRateChangedFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataDisplayRefreshRateChangedFB pointer to const
 * from a EventDataDisplayRefreshRateChangedFB reference to const.
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB const* get(
    EventDataDisplayRefreshRateChangedFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataDisplayRefreshRateChangedFB as the address of a raw
 * XrEventDataDisplayRefreshRateChangedFB
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB* put(
    EventDataDisplayRefreshRateChangedFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataDisplayRefreshRateChangedFB as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataDisplayRefreshRateChangedFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataDisplayRefreshRateChangedFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_display_refresh_rate

#ifdef XR_HTCX_vive_tracker_interaction
/*!
 * C++ projection of XrViveTrackerPathsHTCX
 *
 * Provided by the `XR_HTCX_vive_tracker_interaction` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViveTrackerPathsHTCX>
 * @xrentity{XrViveTrackerPathsHTCX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViveTrackerPathsHTCX : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViveTrackerPathsHTCX(void* next_ = nullptr)

      : Parent(StructureType::ViveTrackerPathsHTCX, next_) {}

  //! Default copy constructor
  ViveTrackerPathsHTCX(const ViveTrackerPathsHTCX& rhs) = default;
  //! Default copy assignment
  ViveTrackerPathsHTCX& operator=(const ViveTrackerPathsHTCX& rhs) = default;
  //! Copy construct from raw
  ViveTrackerPathsHTCX(const XrViveTrackerPathsHTCX& rhs) : ViveTrackerPathsHTCX() { *put() = rhs; }
  //! Copy assign from raw
  ViveTrackerPathsHTCX& operator=(const XrViveTrackerPathsHTCX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViveTrackerPathsHTCX&() const {
    return *reinterpret_cast<const XrViveTrackerPathsHTCX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViveTrackerPathsHTCX&() { return *reinterpret_cast<XrViveTrackerPathsHTCX*>(this); }

  //! Accessor for this as the address of a raw XrViveTrackerPathsHTCX
  XrViveTrackerPathsHTCX const* get() const noexcept {
    return reinterpret_cast<XrViveTrackerPathsHTCX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViveTrackerPathsHTCX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViveTrackerPathsHTCX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViveTrackerPathsHTCX{};
      next = oldNext;
    }
    return reinterpret_cast<XrViveTrackerPathsHTCX*>(this);
  }
  Path persistentPath;
  Path rolePath;
};
static_assert(sizeof(XrViveTrackerPathsHTCX) == sizeof(ViveTrackerPathsHTCX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViveTrackerPathsHTCX pointer to const from a
 * ViveTrackerPathsHTCX reference to const.
 * @relates ViveTrackerPathsHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViveTrackerPathsHTCX const* get(ViveTrackerPathsHTCX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViveTrackerPathsHTCX as the
 * address of a raw XrViveTrackerPathsHTCX
 * @relates ViveTrackerPathsHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViveTrackerPathsHTCX* put(ViveTrackerPathsHTCX& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_HTCX_vive_tracker_interaction
/*!
 * C++ projection of XrEventDataViveTrackerConnectedHTCX
 *
 * Provided by the `XR_HTCX_vive_tracker_interaction` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataViveTrackerConnectedHTCX>
 * @xrentity{XrEventDataViveTrackerConnectedHTCX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataViveTrackerConnectedHTCX : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataViveTrackerConnectedHTCX(ViveTrackerPathsHTCX* paths_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataViveTrackerConnectedHTCX, next_), paths{paths_} {}

  //! Default/empty constructor
  EventDataViveTrackerConnectedHTCX(const void* next_ = nullptr)

      : Parent(StructureType::EventDataViveTrackerConnectedHTCX, next_), paths{nullptr} {}

  //! Default copy constructor
  EventDataViveTrackerConnectedHTCX(const EventDataViveTrackerConnectedHTCX& rhs) = default;
  //! Default copy assignment
  EventDataViveTrackerConnectedHTCX& operator=(const EventDataViveTrackerConnectedHTCX& rhs) =
      default;
  //! Copy construct from raw
  EventDataViveTrackerConnectedHTCX(const XrEventDataViveTrackerConnectedHTCX& rhs)
      : EventDataViveTrackerConnectedHTCX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataViveTrackerConnectedHTCX& operator=(const XrEventDataViveTrackerConnectedHTCX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataViveTrackerConnectedHTCX&() const {
    return *reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataViveTrackerConnectedHTCX&() {
    return *reinterpret_cast<XrEventDataViveTrackerConnectedHTCX*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataViveTrackerConnectedHTCX
  XrEventDataViveTrackerConnectedHTCX const* get() const noexcept {
    return reinterpret_cast<XrEventDataViveTrackerConnectedHTCX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataViveTrackerConnectedHTCX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataViveTrackerConnectedHTCX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataViveTrackerConnectedHTCX{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataViveTrackerConnectedHTCX*>(this);
  }
  ViveTrackerPathsHTCX* paths;
};
static_assert(sizeof(XrEventDataViveTrackerConnectedHTCX) ==
                  sizeof(EventDataViveTrackerConnectedHTCX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataViveTrackerConnectedHTCX pointer to const from
 * a EventDataViveTrackerConnectedHTCX reference to const.
 * @relates EventDataViveTrackerConnectedHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataViveTrackerConnectedHTCX const* get(
    EventDataViveTrackerConnectedHTCX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataViveTrackerConnectedHTCX as the address of a raw XrEventDataViveTrackerConnectedHTCX
 * @relates EventDataViveTrackerConnectedHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataViveTrackerConnectedHTCX* put(
    EventDataViveTrackerConnectedHTCX& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataViveTrackerConnectedHTCX as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataViveTrackerConnectedHTCX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataViveTrackerConnectedHTCX const& h) {
  return h.get_base();
}
#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrSystemFacialTrackingPropertiesHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFacialTrackingPropertiesHTC>
 * @xrentity{XrSystemFacialTrackingPropertiesHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFacialTrackingPropertiesHTC : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFacialTrackingPropertiesHTC(void* next_ = nullptr)

      : Parent(StructureType::SystemFacialTrackingPropertiesHTC, next_) {}

  //! Default copy constructor
  SystemFacialTrackingPropertiesHTC(const SystemFacialTrackingPropertiesHTC& rhs) = default;
  //! Default copy assignment
  SystemFacialTrackingPropertiesHTC& operator=(const SystemFacialTrackingPropertiesHTC& rhs) =
      default;
  //! Copy construct from raw
  SystemFacialTrackingPropertiesHTC(const XrSystemFacialTrackingPropertiesHTC& rhs)
      : SystemFacialTrackingPropertiesHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFacialTrackingPropertiesHTC& operator=(const XrSystemFacialTrackingPropertiesHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFacialTrackingPropertiesHTC&() const {
    return *reinterpret_cast<const XrSystemFacialTrackingPropertiesHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFacialTrackingPropertiesHTC&() {
    return *reinterpret_cast<XrSystemFacialTrackingPropertiesHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFacialTrackingPropertiesHTC
  XrSystemFacialTrackingPropertiesHTC const* get() const noexcept {
    return reinterpret_cast<XrSystemFacialTrackingPropertiesHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFacialTrackingPropertiesHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFacialTrackingPropertiesHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFacialTrackingPropertiesHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFacialTrackingPropertiesHTC*>(this);
  }
  Bool32 supportEyeFacialTracking;
  Bool32 supportLipFacialTracking;
};
static_assert(sizeof(XrSystemFacialTrackingPropertiesHTC) ==
                  sizeof(SystemFacialTrackingPropertiesHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFacialTrackingPropertiesHTC pointer to const from
 * a SystemFacialTrackingPropertiesHTC reference to const.
 * @relates SystemFacialTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFacialTrackingPropertiesHTC const* get(
    SystemFacialTrackingPropertiesHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFacialTrackingPropertiesHTC as the address of a raw XrSystemFacialTrackingPropertiesHTC
 * @relates SystemFacialTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFacialTrackingPropertiesHTC* put(
    SystemFacialTrackingPropertiesHTC& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrFacialExpressionsHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionsHTC>
 * @xrentity{XrFacialExpressionsHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialExpressionsHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FacialExpressionsHTC(const Bool32& isActive_, const Time& sampleTime_, uint32_t expressionCount_,
                       float* expressionWeightings_, const void* next_ = nullptr)
      : Parent(StructureType::FacialExpressionsHTC, next_),
        isActive{isActive_},
        sampleTime{sampleTime_},
        expressionCount{expressionCount_},
        expressionWeightings{expressionWeightings_} {}

  //! Default/empty constructor
  FacialExpressionsHTC(const void* next_ = nullptr)

      : Parent(StructureType::FacialExpressionsHTC, next_),
        isActive{false},
        sampleTime{},
        expressionCount{0},
        expressionWeightings{nullptr} {}

  //! Default copy constructor
  FacialExpressionsHTC(const FacialExpressionsHTC& rhs) = default;
  //! Default copy assignment
  FacialExpressionsHTC& operator=(const FacialExpressionsHTC& rhs) = default;
  //! Copy construct from raw
  FacialExpressionsHTC(const XrFacialExpressionsHTC& rhs) : FacialExpressionsHTC() { *put() = rhs; }
  //! Copy assign from raw
  FacialExpressionsHTC& operator=(const XrFacialExpressionsHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialExpressionsHTC&() const {
    return *reinterpret_cast<const XrFacialExpressionsHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialExpressionsHTC&() { return *reinterpret_cast<XrFacialExpressionsHTC*>(this); }

  //! Accessor for this as the address of a raw XrFacialExpressionsHTC
  XrFacialExpressionsHTC const* get() const noexcept {
    return reinterpret_cast<XrFacialExpressionsHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFacialExpressionsHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialExpressionsHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialExpressionsHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialExpressionsHTC*>(this);
  }
  Bool32 isActive;
  Time sampleTime;
  uint32_t expressionCount;
  float* expressionWeightings;
};
static_assert(sizeof(XrFacialExpressionsHTC) == sizeof(FacialExpressionsHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialExpressionsHTC pointer to const from a
 * FacialExpressionsHTC reference to const.
 * @relates FacialExpressionsHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionsHTC const* get(FacialExpressionsHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FacialExpressionsHTC as the
 * address of a raw XrFacialExpressionsHTC
 * @relates FacialExpressionsHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionsHTC* put(FacialExpressionsHTC& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrFacialTrackerCreateInfoHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackerCreateInfoHTC>
 * @xrentity{XrFacialTrackerCreateInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialTrackerCreateInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FacialTrackerCreateInfoHTC(const FacialTrackingTypeHTC& facialTrackingType_,
                             const void* next_ = nullptr)
      : Parent(StructureType::FacialTrackerCreateInfoHTC, next_),
        facialTrackingType{facialTrackingType_} {}

  //! Default/empty constructor
  FacialTrackerCreateInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::FacialTrackerCreateInfoHTC, next_), facialTrackingType{} {}

  //! Default copy constructor
  FacialTrackerCreateInfoHTC(const FacialTrackerCreateInfoHTC& rhs) = default;
  //! Default copy assignment
  FacialTrackerCreateInfoHTC& operator=(const FacialTrackerCreateInfoHTC& rhs) = default;
  //! Copy construct from raw
  FacialTrackerCreateInfoHTC(const XrFacialTrackerCreateInfoHTC& rhs)
      : FacialTrackerCreateInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FacialTrackerCreateInfoHTC& operator=(const XrFacialTrackerCreateInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialTrackerCreateInfoHTC&() const {
    return *reinterpret_cast<const XrFacialTrackerCreateInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialTrackerCreateInfoHTC&() {
    return *reinterpret_cast<XrFacialTrackerCreateInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrFacialTrackerCreateInfoHTC
  XrFacialTrackerCreateInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrFacialTrackerCreateInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFacialTrackerCreateInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialTrackerCreateInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialTrackerCreateInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialTrackerCreateInfoHTC*>(this);
  }
  FacialTrackingTypeHTC facialTrackingType;
};
static_assert(sizeof(XrFacialTrackerCreateInfoHTC) == sizeof(FacialTrackerCreateInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialTrackerCreateInfoHTC pointer to const from a
 * FacialTrackerCreateInfoHTC reference to const.
 * @relates FacialTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialTrackerCreateInfoHTC const* get(
    FacialTrackerCreateInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FacialTrackerCreateInfoHTC as
 * the address of a raw XrFacialTrackerCreateInfoHTC
 * @relates FacialTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialTrackerCreateInfoHTC* put(FacialTrackerCreateInfoHTC& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space
/*!
 * C++ projection of XrSystemColorSpacePropertiesFB
 *
 * Provided by the `XR_FB_color_space` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemColorSpacePropertiesFB>
 * @xrentity{XrSystemColorSpacePropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemColorSpacePropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemColorSpacePropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemColorSpacePropertiesFB, next_) {}

  //! Default copy constructor
  SystemColorSpacePropertiesFB(const SystemColorSpacePropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemColorSpacePropertiesFB& operator=(const SystemColorSpacePropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemColorSpacePropertiesFB(const XrSystemColorSpacePropertiesFB& rhs)
      : SystemColorSpacePropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemColorSpacePropertiesFB& operator=(const XrSystemColorSpacePropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemColorSpacePropertiesFB&() const {
    return *reinterpret_cast<const XrSystemColorSpacePropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemColorSpacePropertiesFB&() {
    return *reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemColorSpacePropertiesFB
  XrSystemColorSpacePropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemColorSpacePropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemColorSpacePropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemColorSpacePropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemColorSpacePropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
  }
  ColorSpaceFB colorSpace;
};
static_assert(sizeof(XrSystemColorSpacePropertiesFB) == sizeof(SystemColorSpacePropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemColorSpacePropertiesFB pointer to const from a
 * SystemColorSpacePropertiesFB reference to const.
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB const* get(
    SystemColorSpacePropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemColorSpacePropertiesFB
 * as the address of a raw XrSystemColorSpacePropertiesFB
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB* put(SystemColorSpacePropertiesFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_color_space

#ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrVector4sFB
 *
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4sFB>
 * @xrentity{XrVector4sFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector4sFB {
public:
  //! Constructor initializing all members.
  Vector4sFB(int16_t x_, int16_t y_, int16_t z_, int16_t w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Vector4sFB()

      : x{0}, y{0}, z{0}, w{0} {}

  //! Default copy constructor
  Vector4sFB(const Vector4sFB& rhs) = default;
  //! Default copy assignment
  Vector4sFB& operator=(const Vector4sFB& rhs) = default;
  //! Copy construct from raw
  Vector4sFB(const XrVector4sFB& rhs) : Vector4sFB() { *put() = rhs; }
  //! Copy assign from raw
  Vector4sFB& operator=(const XrVector4sFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector4sFB&() const { return *reinterpret_cast<const XrVector4sFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector4sFB&() { return *reinterpret_cast<XrVector4sFB*>(this); }

  //! Accessor for this as the address of a raw XrVector4sFB
  XrVector4sFB const* get() const noexcept { return reinterpret_cast<XrVector4sFB const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector4sFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector4sFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector4sFB{};
    }
    return reinterpret_cast<XrVector4sFB*>(this);
  }
  int16_t x;
  int16_t y;
  int16_t z;
  int16_t w;
};
static_assert(sizeof(XrVector4sFB) == sizeof(Vector4sFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector4sFB pointer to const from a Vector4sFB reference
 * to const.
 * @relates Vector4sFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4sFB const* get(Vector4sFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4sFB as the address of
 * a raw XrVector4sFB
 * @relates Vector4sFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4sFB* put(Vector4sFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrHandTrackingMeshFB
 *
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingMeshFB>
 * @xrentity{XrHandTrackingMeshFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingMeshFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingMeshFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingMeshFB, next_) {}

  //! Default copy constructor
  HandTrackingMeshFB(const HandTrackingMeshFB& rhs) = default;
  //! Default copy assignment
  HandTrackingMeshFB& operator=(const HandTrackingMeshFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingMeshFB(const XrHandTrackingMeshFB& rhs) : HandTrackingMeshFB() { *put() = rhs; }
  //! Copy assign from raw
  HandTrackingMeshFB& operator=(const XrHandTrackingMeshFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingMeshFB&() const {
    return *reinterpret_cast<const XrHandTrackingMeshFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingMeshFB&() { return *reinterpret_cast<XrHandTrackingMeshFB*>(this); }

  //! Accessor for this as the address of a raw XrHandTrackingMeshFB
  XrHandTrackingMeshFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingMeshFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingMeshFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingMeshFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingMeshFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingMeshFB*>(this);
  }
  uint32_t jointCapacityInput;
  uint32_t jointCountOutput;
  Posef* jointBindPoses;
  float* jointRadii;
  HandJointEXT* jointParents;
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector3f* vertexPositions;
  Vector3f* vertexNormals;
  Vector2f* vertexUVs;
  Vector4sFB* vertexBlendIndices;
  Vector4f* vertexBlendWeights;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  int16_t* indices;
};
static_assert(sizeof(XrHandTrackingMeshFB) == sizeof(HandTrackingMeshFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingMeshFB pointer to const from a
 * HandTrackingMeshFB reference to const.
 * @relates HandTrackingMeshFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingMeshFB const* get(HandTrackingMeshFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingMeshFB as the
 * address of a raw XrHandTrackingMeshFB
 * @relates HandTrackingMeshFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingMeshFB* put(HandTrackingMeshFB& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrHandTrackingScaleFB
 *
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingScaleFB>
 * @xrentity{XrHandTrackingScaleFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingScaleFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingScaleFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingScaleFB, next_) {}

  //! Default copy constructor
  HandTrackingScaleFB(const HandTrackingScaleFB& rhs) = default;
  //! Default copy assignment
  HandTrackingScaleFB& operator=(const HandTrackingScaleFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingScaleFB(const XrHandTrackingScaleFB& rhs) : HandTrackingScaleFB() { *put() = rhs; }
  //! Copy assign from raw
  HandTrackingScaleFB& operator=(const XrHandTrackingScaleFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingScaleFB&() const {
    return *reinterpret_cast<const XrHandTrackingScaleFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingScaleFB&() { return *reinterpret_cast<XrHandTrackingScaleFB*>(this); }

  //! Accessor for this as the address of a raw XrHandTrackingScaleFB
  XrHandTrackingScaleFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingScaleFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingScaleFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingScaleFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingScaleFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingScaleFB*>(this);
  }
  float sensorOutput;
  float currentOutput;
  Bool32 overrideHandScale;
  float overrideValueInput;
};
static_assert(sizeof(XrHandTrackingScaleFB) == sizeof(HandTrackingScaleFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingScaleFB pointer to const from a
 * HandTrackingScaleFB reference to const.
 * @relates HandTrackingScaleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingScaleFB const* get(HandTrackingScaleFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingScaleFB as the
 * address of a raw XrHandTrackingScaleFB
 * @relates HandTrackingScaleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingScaleFB* put(HandTrackingScaleFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_aim
/*!
 * C++ projection of XrHandTrackingAimStateFB
 *
 * Provided by the `XR_FB_hand_tracking_aim` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingAimStateFB>
 * @xrentity{XrHandTrackingAimStateFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingAimStateFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingAimStateFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingAimStateFB, next_) {}

  //! Default copy constructor
  HandTrackingAimStateFB(const HandTrackingAimStateFB& rhs) = default;
  //! Default copy assignment
  HandTrackingAimStateFB& operator=(const HandTrackingAimStateFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingAimStateFB(const XrHandTrackingAimStateFB& rhs) : HandTrackingAimStateFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackingAimStateFB& operator=(const XrHandTrackingAimStateFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingAimStateFB&() const {
    return *reinterpret_cast<const XrHandTrackingAimStateFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingAimStateFB&() {
    return *reinterpret_cast<XrHandTrackingAimStateFB*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackingAimStateFB
  XrHandTrackingAimStateFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingAimStateFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingAimStateFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingAimStateFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingAimStateFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingAimStateFB*>(this);
  }
  HandTrackingAimFlagsFB status;
  Posef aimPose;
  float pinchStrengthIndex;
  float pinchStrengthMiddle;
  float pinchStrengthRing;
  float pinchStrengthLittle;
};
static_assert(sizeof(XrHandTrackingAimStateFB) == sizeof(HandTrackingAimStateFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingAimStateFB pointer to const from a
 * HandTrackingAimStateFB reference to const.
 * @relates HandTrackingAimStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingAimStateFB const* get(HandTrackingAimStateFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingAimStateFB as the
 * address of a raw XrHandTrackingAimStateFB
 * @relates HandTrackingAimStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingAimStateFB* put(HandTrackingAimStateFB& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_aim

#ifdef XR_FB_hand_tracking_capsules
/*!
 * C++ projection of XrHandCapsuleFB
 *
 * Provided by the `XR_FB_hand_tracking_capsules` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandCapsuleFB>
 * @xrentity{XrHandCapsuleFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandCapsuleFB {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandCapsuleFB()

  {}

  //! Default copy constructor
  HandCapsuleFB(const HandCapsuleFB& rhs) = default;
  //! Default copy assignment
  HandCapsuleFB& operator=(const HandCapsuleFB& rhs) = default;
  //! Copy construct from raw
  HandCapsuleFB(const XrHandCapsuleFB& rhs) : HandCapsuleFB() { *put() = rhs; }
  //! Copy assign from raw
  HandCapsuleFB& operator=(const XrHandCapsuleFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandCapsuleFB&() const {
    return *reinterpret_cast<const XrHandCapsuleFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandCapsuleFB&() { return *reinterpret_cast<XrHandCapsuleFB*>(this); }

  //! Accessor for this as the address of a raw XrHandCapsuleFB
  XrHandCapsuleFB const* get() const noexcept {
    return reinterpret_cast<XrHandCapsuleFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandCapsuleFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandCapsuleFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandCapsuleFB{};
    }
    return reinterpret_cast<XrHandCapsuleFB*>(this);
  }
  Vector3f points[XR_FB_HAND_TRACKING_CAPSULE_POINT_COUNT];
  float radius;
  HandJointEXT joint;
};
static_assert(sizeof(XrHandCapsuleFB) == sizeof(HandCapsuleFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandCapsuleFB pointer to const from a HandCapsuleFB
 * reference to const.
 * @relates HandCapsuleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandCapsuleFB const* get(HandCapsuleFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandCapsuleFB as the address
 * of a raw XrHandCapsuleFB
 * @relates HandCapsuleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandCapsuleFB* put(HandCapsuleFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_capsules

#ifdef XR_FB_hand_tracking_capsules
/*!
 * C++ projection of XrHandTrackingCapsulesStateFB
 *
 * Provided by the `XR_FB_hand_tracking_capsules` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingCapsulesStateFB>
 * @xrentity{XrHandTrackingCapsulesStateFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingCapsulesStateFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingCapsulesStateFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingCapsulesStateFB, next_) {}

  //! Default copy constructor
  HandTrackingCapsulesStateFB(const HandTrackingCapsulesStateFB& rhs) = default;
  //! Default copy assignment
  HandTrackingCapsulesStateFB& operator=(const HandTrackingCapsulesStateFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingCapsulesStateFB(const XrHandTrackingCapsulesStateFB& rhs)
      : HandTrackingCapsulesStateFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackingCapsulesStateFB& operator=(const XrHandTrackingCapsulesStateFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingCapsulesStateFB&() const {
    return *reinterpret_cast<const XrHandTrackingCapsulesStateFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingCapsulesStateFB&() {
    return *reinterpret_cast<XrHandTrackingCapsulesStateFB*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackingCapsulesStateFB
  XrHandTrackingCapsulesStateFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingCapsulesStateFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackingCapsulesStateFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingCapsulesStateFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingCapsulesStateFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingCapsulesStateFB*>(this);
  }
  HandCapsuleFB capsules[XR_FB_HAND_TRACKING_CAPSULE_COUNT];
};
static_assert(sizeof(XrHandTrackingCapsulesStateFB) == sizeof(HandTrackingCapsulesStateFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingCapsulesStateFB pointer to const from a
 * HandTrackingCapsulesStateFB reference to const.
 * @relates HandTrackingCapsulesStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingCapsulesStateFB const* get(
    HandTrackingCapsulesStateFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingCapsulesStateFB
 * as the address of a raw XrHandTrackingCapsulesStateFB
 * @relates HandTrackingCapsulesStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingCapsulesStateFB* put(HandTrackingCapsulesStateFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_capsules

#ifdef XR_FB_foveation
/*!
 * C++ projection of XrFoveationProfileCreateInfoFB
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationProfileCreateInfoFB>
 * @xrentity{XrFoveationProfileCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationProfileCreateInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveationProfileCreateInfoFB(void* next_ = nullptr)

      : Parent(StructureType::FoveationProfileCreateInfoFB, next_) {}

  //! Default copy constructor
  FoveationProfileCreateInfoFB(const FoveationProfileCreateInfoFB& rhs) = default;
  //! Default copy assignment
  FoveationProfileCreateInfoFB& operator=(const FoveationProfileCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  FoveationProfileCreateInfoFB(const XrFoveationProfileCreateInfoFB& rhs)
      : FoveationProfileCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationProfileCreateInfoFB& operator=(const XrFoveationProfileCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationProfileCreateInfoFB&() const {
    return *reinterpret_cast<const XrFoveationProfileCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationProfileCreateInfoFB&() {
    return *reinterpret_cast<XrFoveationProfileCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationProfileCreateInfoFB
  XrFoveationProfileCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrFoveationProfileCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationProfileCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationProfileCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationProfileCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationProfileCreateInfoFB*>(this);
  }
};
static_assert(sizeof(XrFoveationProfileCreateInfoFB) == sizeof(FoveationProfileCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationProfileCreateInfoFB pointer to const from a
 * FoveationProfileCreateInfoFB reference to const.
 * @relates FoveationProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationProfileCreateInfoFB const* get(
    FoveationProfileCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationProfileCreateInfoFB
 * as the address of a raw XrFoveationProfileCreateInfoFB
 * @relates FoveationProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationProfileCreateInfoFB* put(FoveationProfileCreateInfoFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_foveation

#ifdef XR_FB_foveation
/*!
 * C++ projection of XrSwapchainCreateInfoFoveationFB
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfoFoveationFB>
 * @xrentity{XrSwapchainCreateInfoFoveationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainCreateInfoFoveationFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainCreateInfoFoveationFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainCreateInfoFoveationFB, next_) {}

  //! Default copy constructor
  SwapchainCreateInfoFoveationFB(const SwapchainCreateInfoFoveationFB& rhs) = default;
  //! Default copy assignment
  SwapchainCreateInfoFoveationFB& operator=(const SwapchainCreateInfoFoveationFB& rhs) = default;
  //! Copy construct from raw
  SwapchainCreateInfoFoveationFB(const XrSwapchainCreateInfoFoveationFB& rhs)
      : SwapchainCreateInfoFoveationFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainCreateInfoFoveationFB& operator=(const XrSwapchainCreateInfoFoveationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainCreateInfoFoveationFB&() const {
    return *reinterpret_cast<const XrSwapchainCreateInfoFoveationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainCreateInfoFoveationFB&() {
    return *reinterpret_cast<XrSwapchainCreateInfoFoveationFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainCreateInfoFoveationFB
  XrSwapchainCreateInfoFoveationFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainCreateInfoFoveationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainCreateInfoFoveationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainCreateInfoFoveationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainCreateInfoFoveationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainCreateInfoFoveationFB*>(this);
  }
  SwapchainCreateFoveationFlagsFB flags;
};
static_assert(sizeof(XrSwapchainCreateInfoFoveationFB) == sizeof(SwapchainCreateInfoFoveationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfoFoveationFB pointer to const from a
 * SwapchainCreateInfoFoveationFB reference to const.
 * @relates SwapchainCreateInfoFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfoFoveationFB const* get(
    SwapchainCreateInfoFoveationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainCreateInfoFoveationFB as the address of a raw XrSwapchainCreateInfoFoveationFB
 * @relates SwapchainCreateInfoFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfoFoveationFB* put(SwapchainCreateInfoFoveationFB& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_foveation

#ifdef XR_FB_foveation
/*!
 * C++ projection of XrSwapchainStateFoveationFB
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateFoveationFB>
 * @xrentity{XrSwapchainStateFoveationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateFoveationFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateFoveationFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateFoveationFB, next_) {}

  //! Default copy constructor
  SwapchainStateFoveationFB(const SwapchainStateFoveationFB& rhs) = default;
  //! Default copy assignment
  SwapchainStateFoveationFB& operator=(const SwapchainStateFoveationFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateFoveationFB(const XrSwapchainStateFoveationFB& rhs) : SwapchainStateFoveationFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateFoveationFB& operator=(const XrSwapchainStateFoveationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateFoveationFB&() const {
    return *reinterpret_cast<const XrSwapchainStateFoveationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateFoveationFB&() {
    return *reinterpret_cast<XrSwapchainStateFoveationFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateFoveationFB
  XrSwapchainStateFoveationFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateFoveationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateFoveationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateFoveationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateFoveationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateFoveationFB*>(this);
  }
  SwapchainStateFoveationFlagsFB flags;
  FoveationProfileFB profile;
};
static_assert(sizeof(XrSwapchainStateFoveationFB) == sizeof(SwapchainStateFoveationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateFoveationFB pointer to const from a
 * SwapchainStateFoveationFB reference to const.
 * @relates SwapchainStateFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateFoveationFB const* get(
    SwapchainStateFoveationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateFoveationFB as
 * the address of a raw XrSwapchainStateFoveationFB
 * @relates SwapchainStateFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateFoveationFB* put(SwapchainStateFoveationFB& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateFoveationFB as a raw,
 * pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateFoveationFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateFoveationFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_foveation

#ifdef XR_FB_foveation_configuration
/*!
 * C++ projection of XrFoveationLevelProfileCreateInfoFB
 *
 * Provided by the `XR_FB_foveation_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelProfileCreateInfoFB>
 * @xrentity{XrFoveationLevelProfileCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationLevelProfileCreateInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveationLevelProfileCreateInfoFB(void* next_ = nullptr)

      : Parent(StructureType::FoveationLevelProfileCreateInfoFB, next_) {}

  //! Default copy constructor
  FoveationLevelProfileCreateInfoFB(const FoveationLevelProfileCreateInfoFB& rhs) = default;
  //! Default copy assignment
  FoveationLevelProfileCreateInfoFB& operator=(const FoveationLevelProfileCreateInfoFB& rhs) =
      default;
  //! Copy construct from raw
  FoveationLevelProfileCreateInfoFB(const XrFoveationLevelProfileCreateInfoFB& rhs)
      : FoveationLevelProfileCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationLevelProfileCreateInfoFB& operator=(const XrFoveationLevelProfileCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationLevelProfileCreateInfoFB&() const {
    return *reinterpret_cast<const XrFoveationLevelProfileCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationLevelProfileCreateInfoFB&() {
    return *reinterpret_cast<XrFoveationLevelProfileCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationLevelProfileCreateInfoFB
  XrFoveationLevelProfileCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrFoveationLevelProfileCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationLevelProfileCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationLevelProfileCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationLevelProfileCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationLevelProfileCreateInfoFB*>(this);
  }
  FoveationLevelFB level;
  float verticalOffset;
  FoveationDynamicFB dynamic;
};
static_assert(sizeof(XrFoveationLevelProfileCreateInfoFB) ==
                  sizeof(FoveationLevelProfileCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationLevelProfileCreateInfoFB pointer to const from
 * a FoveationLevelProfileCreateInfoFB reference to const.
 * @relates FoveationLevelProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationLevelProfileCreateInfoFB const* get(
    FoveationLevelProfileCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FoveationLevelProfileCreateInfoFB as the address of a raw XrFoveationLevelProfileCreateInfoFB
 * @relates FoveationLevelProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationLevelProfileCreateInfoFB* put(
    FoveationLevelProfileCreateInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_foveation_configuration

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrSystemKeyboardTrackingPropertiesFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemKeyboardTrackingPropertiesFB>
 * @xrentity{XrSystemKeyboardTrackingPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemKeyboardTrackingPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemKeyboardTrackingPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemKeyboardTrackingPropertiesFB, next_) {}

  //! Default copy constructor
  SystemKeyboardTrackingPropertiesFB(const SystemKeyboardTrackingPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemKeyboardTrackingPropertiesFB& operator=(const SystemKeyboardTrackingPropertiesFB& rhs) =
      default;
  //! Copy construct from raw
  SystemKeyboardTrackingPropertiesFB(const XrSystemKeyboardTrackingPropertiesFB& rhs)
      : SystemKeyboardTrackingPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemKeyboardTrackingPropertiesFB& operator=(const XrSystemKeyboardTrackingPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemKeyboardTrackingPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemKeyboardTrackingPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemKeyboardTrackingPropertiesFB&() {
    return *reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemKeyboardTrackingPropertiesFB
  XrSystemKeyboardTrackingPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemKeyboardTrackingPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemKeyboardTrackingPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemKeyboardTrackingPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB*>(this);
  }
  Bool32 supportsKeyboardTracking;
};
static_assert(sizeof(XrSystemKeyboardTrackingPropertiesFB) ==
                  sizeof(SystemKeyboardTrackingPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemKeyboardTrackingPropertiesFB pointer to const from
 * a SystemKeyboardTrackingPropertiesFB reference to const.
 * @relates SystemKeyboardTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemKeyboardTrackingPropertiesFB const* get(
    SystemKeyboardTrackingPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemKeyboardTrackingPropertiesFB as the address of a raw XrSystemKeyboardTrackingPropertiesFB
 * @relates SystemKeyboardTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemKeyboardTrackingPropertiesFB* put(
    SystemKeyboardTrackingPropertiesFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardTrackingDescriptionFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardTrackingDescriptionFB>
 * @xrentity{XrKeyboardTrackingDescriptionFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS KeyboardTrackingDescriptionFB {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  KeyboardTrackingDescriptionFB()

  {}

  //! Default copy constructor
  KeyboardTrackingDescriptionFB(const KeyboardTrackingDescriptionFB& rhs) = default;
  //! Default copy assignment
  KeyboardTrackingDescriptionFB& operator=(const KeyboardTrackingDescriptionFB& rhs) = default;
  //! Copy construct from raw
  KeyboardTrackingDescriptionFB(const XrKeyboardTrackingDescriptionFB& rhs)
      : KeyboardTrackingDescriptionFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  KeyboardTrackingDescriptionFB& operator=(const XrKeyboardTrackingDescriptionFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrKeyboardTrackingDescriptionFB&() const {
    return *reinterpret_cast<const XrKeyboardTrackingDescriptionFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrKeyboardTrackingDescriptionFB&() {
    return *reinterpret_cast<XrKeyboardTrackingDescriptionFB*>(this);
  }

  //! Accessor for this as the address of a raw XrKeyboardTrackingDescriptionFB
  XrKeyboardTrackingDescriptionFB const* get() const noexcept {
    return reinterpret_cast<XrKeyboardTrackingDescriptionFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrKeyboardTrackingDescriptionFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrKeyboardTrackingDescriptionFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = KeyboardTrackingDescriptionFB{};
    }
    return reinterpret_cast<XrKeyboardTrackingDescriptionFB*>(this);
  }
  uint64_t trackedKeyboardId;
  Vector3f size;
  KeyboardTrackingFlagsFB flags;
  char name[XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB];
};
static_assert(sizeof(XrKeyboardTrackingDescriptionFB) == sizeof(KeyboardTrackingDescriptionFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrKeyboardTrackingDescriptionFB pointer to const from a
 * KeyboardTrackingDescriptionFB reference to const.
 * @relates KeyboardTrackingDescriptionFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingDescriptionFB const* get(
    KeyboardTrackingDescriptionFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardTrackingDescriptionFB
 * as the address of a raw XrKeyboardTrackingDescriptionFB
 * @relates KeyboardTrackingDescriptionFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingDescriptionFB* put(KeyboardTrackingDescriptionFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardSpaceCreateInfoFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardSpaceCreateInfoFB>
 * @xrentity{XrKeyboardSpaceCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS KeyboardSpaceCreateInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  KeyboardSpaceCreateInfoFB(void* next_ = nullptr)

      : Parent(StructureType::KeyboardSpaceCreateInfoFB, next_) {}

  //! Default copy constructor
  KeyboardSpaceCreateInfoFB(const KeyboardSpaceCreateInfoFB& rhs) = default;
  //! Default copy assignment
  KeyboardSpaceCreateInfoFB& operator=(const KeyboardSpaceCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  KeyboardSpaceCreateInfoFB(const XrKeyboardSpaceCreateInfoFB& rhs) : KeyboardSpaceCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  KeyboardSpaceCreateInfoFB& operator=(const XrKeyboardSpaceCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrKeyboardSpaceCreateInfoFB&() const {
    return *reinterpret_cast<const XrKeyboardSpaceCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrKeyboardSpaceCreateInfoFB&() {
    return *reinterpret_cast<XrKeyboardSpaceCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrKeyboardSpaceCreateInfoFB
  XrKeyboardSpaceCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrKeyboardSpaceCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrKeyboardSpaceCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrKeyboardSpaceCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = KeyboardSpaceCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrKeyboardSpaceCreateInfoFB*>(this);
  }
  uint64_t trackedKeyboardId;
};
static_assert(sizeof(XrKeyboardSpaceCreateInfoFB) == sizeof(KeyboardSpaceCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrKeyboardSpaceCreateInfoFB pointer to const from a
 * KeyboardSpaceCreateInfoFB reference to const.
 * @relates KeyboardSpaceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardSpaceCreateInfoFB const* get(
    KeyboardSpaceCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardSpaceCreateInfoFB as
 * the address of a raw XrKeyboardSpaceCreateInfoFB
 * @relates KeyboardSpaceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardSpaceCreateInfoFB* put(KeyboardSpaceCreateInfoFB& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardTrackingQueryFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardTrackingQueryFB>
 * @xrentity{XrKeyboardTrackingQueryFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS KeyboardTrackingQueryFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  KeyboardTrackingQueryFB(void* next_ = nullptr)

      : Parent(StructureType::KeyboardTrackingQueryFB, next_) {}

  //! Default copy constructor
  KeyboardTrackingQueryFB(const KeyboardTrackingQueryFB& rhs) = default;
  //! Default copy assignment
  KeyboardTrackingQueryFB& operator=(const KeyboardTrackingQueryFB& rhs) = default;
  //! Copy construct from raw
  KeyboardTrackingQueryFB(const XrKeyboardTrackingQueryFB& rhs) : KeyboardTrackingQueryFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  KeyboardTrackingQueryFB& operator=(const XrKeyboardTrackingQueryFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrKeyboardTrackingQueryFB&() const {
    return *reinterpret_cast<const XrKeyboardTrackingQueryFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrKeyboardTrackingQueryFB&() {
    return *reinterpret_cast<XrKeyboardTrackingQueryFB*>(this);
  }

  //! Accessor for this as the address of a raw XrKeyboardTrackingQueryFB
  XrKeyboardTrackingQueryFB const* get() const noexcept {
    return reinterpret_cast<XrKeyboardTrackingQueryFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrKeyboardTrackingQueryFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrKeyboardTrackingQueryFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = KeyboardTrackingQueryFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrKeyboardTrackingQueryFB*>(this);
  }
  KeyboardTrackingQueryFlagsFB flags;
};
static_assert(sizeof(XrKeyboardTrackingQueryFB) == sizeof(KeyboardTrackingQueryFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrKeyboardTrackingQueryFB pointer to const from a
 * KeyboardTrackingQueryFB reference to const.
 * @relates KeyboardTrackingQueryFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingQueryFB const* get(KeyboardTrackingQueryFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardTrackingQueryFB as
 * the address of a raw XrKeyboardTrackingQueryFB
 * @relates KeyboardTrackingQueryFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingQueryFB* put(KeyboardTrackingQueryFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_triangle_mesh
/*!
 * C++ projection of XrTriangleMeshCreateInfoFB
 *
 * Provided by the `XR_FB_triangle_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTriangleMeshCreateInfoFB>
 * @xrentity{XrTriangleMeshCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS TriangleMeshCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  TriangleMeshCreateInfoFB(const TriangleMeshFlagsFB& flags_, const WindingOrderFB& windingOrder_,
                           uint32_t vertexCount_, const Vector3f* vertexBuffer_,
                           uint32_t triangleCount_, const uint32_t* indexBuffer_,
                           const void* next_ = nullptr)
      : Parent(StructureType::TriangleMeshCreateInfoFB, next_),
        flags{flags_},
        windingOrder{windingOrder_},
        vertexCount{vertexCount_},
        vertexBuffer{vertexBuffer_},
        triangleCount{triangleCount_},
        indexBuffer{indexBuffer_} {}

  //! Default/empty constructor
  TriangleMeshCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::TriangleMeshCreateInfoFB, next_),
        flags{},
        windingOrder{},
        vertexCount{0},
        vertexBuffer{nullptr},
        triangleCount{0},
        indexBuffer{nullptr} {}

  //! Default copy constructor
  TriangleMeshCreateInfoFB(const TriangleMeshCreateInfoFB& rhs) = default;
  //! Default copy assignment
  TriangleMeshCreateInfoFB& operator=(const TriangleMeshCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  TriangleMeshCreateInfoFB(const XrTriangleMeshCreateInfoFB& rhs) : TriangleMeshCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  TriangleMeshCreateInfoFB& operator=(const XrTriangleMeshCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrTriangleMeshCreateInfoFB&() const {
    return *reinterpret_cast<const XrTriangleMeshCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrTriangleMeshCreateInfoFB&() {
    return *reinterpret_cast<XrTriangleMeshCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrTriangleMeshCreateInfoFB
  XrTriangleMeshCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrTriangleMeshCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrTriangleMeshCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrTriangleMeshCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = TriangleMeshCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrTriangleMeshCreateInfoFB*>(this);
  }
  TriangleMeshFlagsFB flags;
  WindingOrderFB windingOrder;
  uint32_t vertexCount;
  const Vector3f* vertexBuffer;
  uint32_t triangleCount;
  const uint32_t* indexBuffer;
};
static_assert(sizeof(XrTriangleMeshCreateInfoFB) == sizeof(TriangleMeshCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrTriangleMeshCreateInfoFB pointer to const from a
 * TriangleMeshCreateInfoFB reference to const.
 * @relates TriangleMeshCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrTriangleMeshCreateInfoFB const* get(TriangleMeshCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing TriangleMeshCreateInfoFB as
 * the address of a raw XrTriangleMeshCreateInfoFB
 * @relates TriangleMeshCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrTriangleMeshCreateInfoFB* put(TriangleMeshCreateInfoFB& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrSystemPassthroughPropertiesFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughPropertiesFB>
 * @xrentity{XrSystemPassthroughPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemPassthroughPropertiesFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SystemPassthroughPropertiesFB(const Bool32& supportsPassthrough_, const void* next_ = nullptr)
      : Parent(StructureType::SystemPassthroughPropertiesFB, next_),
        supportsPassthrough{supportsPassthrough_} {}

  //! Default/empty constructor
  SystemPassthroughPropertiesFB(const void* next_ = nullptr)

      : Parent(StructureType::SystemPassthroughPropertiesFB, next_), supportsPassthrough{false} {}

  //! Default copy constructor
  SystemPassthroughPropertiesFB(const SystemPassthroughPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemPassthroughPropertiesFB& operator=(const SystemPassthroughPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemPassthroughPropertiesFB(const XrSystemPassthroughPropertiesFB& rhs)
      : SystemPassthroughPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemPassthroughPropertiesFB& operator=(const XrSystemPassthroughPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemPassthroughPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemPassthroughPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemPassthroughPropertiesFB&() {
    return *reinterpret_cast<XrSystemPassthroughPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemPassthroughPropertiesFB
  XrSystemPassthroughPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemPassthroughPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemPassthroughPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemPassthroughPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemPassthroughPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemPassthroughPropertiesFB*>(this);
  }
  Bool32 supportsPassthrough;
};
static_assert(sizeof(XrSystemPassthroughPropertiesFB) == sizeof(SystemPassthroughPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemPassthroughPropertiesFB pointer to const from a
 * SystemPassthroughPropertiesFB reference to const.
 * @relates SystemPassthroughPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughPropertiesFB const* get(
    SystemPassthroughPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemPassthroughPropertiesFB
 * as the address of a raw XrSystemPassthroughPropertiesFB
 * @relates SystemPassthroughPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughPropertiesFB* put(SystemPassthroughPropertiesFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughCreateInfoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughCreateInfoFB>
 * @xrentity{XrPassthroughCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughCreateInfoFB(const PassthroughFlagsFB& flags_, const void* next_ = nullptr)
      : Parent(StructureType::PassthroughCreateInfoFB, next_), flags{flags_} {}

  //! Default/empty constructor
  PassthroughCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughCreateInfoFB, next_), flags{} {}

  //! Default copy constructor
  PassthroughCreateInfoFB(const PassthroughCreateInfoFB& rhs) = default;
  //! Default copy assignment
  PassthroughCreateInfoFB& operator=(const PassthroughCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  PassthroughCreateInfoFB(const XrPassthroughCreateInfoFB& rhs) : PassthroughCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughCreateInfoFB& operator=(const XrPassthroughCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughCreateInfoFB&() const {
    return *reinterpret_cast<const XrPassthroughCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughCreateInfoFB&() {
    return *reinterpret_cast<XrPassthroughCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughCreateInfoFB
  XrPassthroughCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughCreateInfoFB*>(this);
  }
  PassthroughFlagsFB flags;
};
static_assert(sizeof(XrPassthroughCreateInfoFB) == sizeof(PassthroughCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughCreateInfoFB pointer to const from a
 * PassthroughCreateInfoFB reference to const.
 * @relates PassthroughCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughCreateInfoFB const* get(PassthroughCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughCreateInfoFB as
 * the address of a raw XrPassthroughCreateInfoFB
 * @relates PassthroughCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughCreateInfoFB* put(PassthroughCreateInfoFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughLayerCreateInfoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerCreateInfoFB>
 * @xrentity{XrPassthroughLayerCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughLayerCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughLayerCreateInfoFB(const PassthroughFB& passthrough_, const PassthroughFlagsFB& flags_,
                               const PassthroughLayerPurposeFB& purpose_,
                               const void* next_ = nullptr)
      : Parent(StructureType::PassthroughLayerCreateInfoFB, next_),
        passthrough{passthrough_},
        flags{flags_},
        purpose{purpose_} {}

  //! Default/empty constructor
  PassthroughLayerCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughLayerCreateInfoFB, next_),
        passthrough{},
        flags{},
        purpose{} {}

  //! Default copy constructor
  PassthroughLayerCreateInfoFB(const PassthroughLayerCreateInfoFB& rhs) = default;
  //! Default copy assignment
  PassthroughLayerCreateInfoFB& operator=(const PassthroughLayerCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  PassthroughLayerCreateInfoFB(const XrPassthroughLayerCreateInfoFB& rhs)
      : PassthroughLayerCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughLayerCreateInfoFB& operator=(const XrPassthroughLayerCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughLayerCreateInfoFB&() const {
    return *reinterpret_cast<const XrPassthroughLayerCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughLayerCreateInfoFB&() {
    return *reinterpret_cast<XrPassthroughLayerCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughLayerCreateInfoFB
  XrPassthroughLayerCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughLayerCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughLayerCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughLayerCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughLayerCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughLayerCreateInfoFB*>(this);
  }
  PassthroughFB passthrough;
  PassthroughFlagsFB flags;
  PassthroughLayerPurposeFB purpose;
};
static_assert(sizeof(XrPassthroughLayerCreateInfoFB) == sizeof(PassthroughLayerCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughLayerCreateInfoFB pointer to const from a
 * PassthroughLayerCreateInfoFB reference to const.
 * @relates PassthroughLayerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughLayerCreateInfoFB const* get(
    PassthroughLayerCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughLayerCreateInfoFB
 * as the address of a raw XrPassthroughLayerCreateInfoFB
 * @relates PassthroughLayerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughLayerCreateInfoFB* put(PassthroughLayerCreateInfoFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrCompositionLayerPassthroughFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerPassthroughFB>
 * @xrentity{XrCompositionLayerPassthroughFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerPassthroughFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerPassthroughFB(const CompositionLayerFlags& flags_, const Space& space_,
                                const PassthroughLayerFB& layerHandle_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerPassthroughFB, next_),
        flags{flags_},
        space{space_},
        layerHandle{layerHandle_} {}

  //! Default/empty constructor
  CompositionLayerPassthroughFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerPassthroughFB, next_),
        flags{},
        space{},
        layerHandle{} {}

  //! Default copy constructor
  CompositionLayerPassthroughFB(const CompositionLayerPassthroughFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerPassthroughFB& operator=(const CompositionLayerPassthroughFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerPassthroughFB(const XrCompositionLayerPassthroughFB& rhs)
      : CompositionLayerPassthroughFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerPassthroughFB& operator=(const XrCompositionLayerPassthroughFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerPassthroughFB&() const {
    return *reinterpret_cast<const XrCompositionLayerPassthroughFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerPassthroughFB&() {
    return *reinterpret_cast<XrCompositionLayerPassthroughFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerPassthroughFB
  XrCompositionLayerPassthroughFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerPassthroughFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerPassthroughFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerPassthroughFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerPassthroughFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerPassthroughFB*>(this);
  }
  CompositionLayerFlags flags;
  Space space;
  PassthroughLayerFB layerHandle;
};
static_assert(sizeof(XrCompositionLayerPassthroughFB) == sizeof(CompositionLayerPassthroughFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerPassthroughFB pointer to const from a
 * CompositionLayerPassthroughFB reference to const.
 * @relates CompositionLayerPassthroughFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerPassthroughFB const* get(
    CompositionLayerPassthroughFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerPassthroughFB
 * as the address of a raw XrCompositionLayerPassthroughFB
 * @relates CompositionLayerPassthroughFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerPassthroughFB* put(CompositionLayerPassthroughFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrGeometryInstanceCreateInfoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceCreateInfoFB>
 * @xrentity{XrGeometryInstanceCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GeometryInstanceCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GeometryInstanceCreateInfoFB(const PassthroughLayerFB& layer_, const TriangleMeshFB& mesh_,
                               const Space& baseSpace_, const Posef& pose_, const Vector3f& scale_,
                               const void* next_ = nullptr)
      : Parent(StructureType::GeometryInstanceCreateInfoFB, next_),
        layer{layer_},
        mesh{mesh_},
        baseSpace{baseSpace_},
        pose{pose_},
        scale{scale_} {}

  //! Default/empty constructor
  GeometryInstanceCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::GeometryInstanceCreateInfoFB, next_),
        layer{},
        mesh{},
        baseSpace{},
        pose{},
        scale{} {}

  //! Default copy constructor
  GeometryInstanceCreateInfoFB(const GeometryInstanceCreateInfoFB& rhs) = default;
  //! Default copy assignment
  GeometryInstanceCreateInfoFB& operator=(const GeometryInstanceCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  GeometryInstanceCreateInfoFB(const XrGeometryInstanceCreateInfoFB& rhs)
      : GeometryInstanceCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GeometryInstanceCreateInfoFB& operator=(const XrGeometryInstanceCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGeometryInstanceCreateInfoFB&() const {
    return *reinterpret_cast<const XrGeometryInstanceCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGeometryInstanceCreateInfoFB&() {
    return *reinterpret_cast<XrGeometryInstanceCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrGeometryInstanceCreateInfoFB
  XrGeometryInstanceCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrGeometryInstanceCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGeometryInstanceCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGeometryInstanceCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GeometryInstanceCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrGeometryInstanceCreateInfoFB*>(this);
  }
  PassthroughLayerFB layer;
  TriangleMeshFB mesh;
  Space baseSpace;
  Posef pose;
  Vector3f scale;
};
static_assert(sizeof(XrGeometryInstanceCreateInfoFB) == sizeof(GeometryInstanceCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGeometryInstanceCreateInfoFB pointer to const from a
 * GeometryInstanceCreateInfoFB reference to const.
 * @relates GeometryInstanceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceCreateInfoFB const* get(
    GeometryInstanceCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GeometryInstanceCreateInfoFB
 * as the address of a raw XrGeometryInstanceCreateInfoFB
 * @relates GeometryInstanceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceCreateInfoFB* put(GeometryInstanceCreateInfoFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrGeometryInstanceTransformFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceTransformFB>
 * @xrentity{XrGeometryInstanceTransformFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GeometryInstanceTransformFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GeometryInstanceTransformFB(const Space& baseSpace_, const Time& time_, const Posef& pose_,
                              const Vector3f& scale_, const void* next_ = nullptr)
      : Parent(StructureType::GeometryInstanceTransformFB, next_),
        baseSpace{baseSpace_},
        time{time_},
        pose{pose_},
        scale{scale_} {}

  //! Default/empty constructor
  GeometryInstanceTransformFB(const void* next_ = nullptr)

      : Parent(StructureType::GeometryInstanceTransformFB, next_),
        baseSpace{},
        time{},
        pose{},
        scale{} {}

  //! Default copy constructor
  GeometryInstanceTransformFB(const GeometryInstanceTransformFB& rhs) = default;
  //! Default copy assignment
  GeometryInstanceTransformFB& operator=(const GeometryInstanceTransformFB& rhs) = default;
  //! Copy construct from raw
  GeometryInstanceTransformFB(const XrGeometryInstanceTransformFB& rhs)
      : GeometryInstanceTransformFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GeometryInstanceTransformFB& operator=(const XrGeometryInstanceTransformFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGeometryInstanceTransformFB&() const {
    return *reinterpret_cast<const XrGeometryInstanceTransformFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGeometryInstanceTransformFB&() {
    return *reinterpret_cast<XrGeometryInstanceTransformFB*>(this);
  }

  //! Accessor for this as the address of a raw XrGeometryInstanceTransformFB
  XrGeometryInstanceTransformFB const* get() const noexcept {
    return reinterpret_cast<XrGeometryInstanceTransformFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGeometryInstanceTransformFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGeometryInstanceTransformFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GeometryInstanceTransformFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrGeometryInstanceTransformFB*>(this);
  }
  Space baseSpace;
  Time time;
  Posef pose;
  Vector3f scale;
};
static_assert(sizeof(XrGeometryInstanceTransformFB) == sizeof(GeometryInstanceTransformFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGeometryInstanceTransformFB pointer to const from a
 * GeometryInstanceTransformFB reference to const.
 * @relates GeometryInstanceTransformFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceTransformFB const* get(
    GeometryInstanceTransformFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GeometryInstanceTransformFB
 * as the address of a raw XrGeometryInstanceTransformFB
 * @relates GeometryInstanceTransformFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceTransformFB* put(GeometryInstanceTransformFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughStyleFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughStyleFB>
 * @xrentity{XrPassthroughStyleFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughStyleFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughStyleFB(float textureOpacityFactor_, const Color4f& edgeColor_,
                     const void* next_ = nullptr)
      : Parent(StructureType::PassthroughStyleFB, next_),
        textureOpacityFactor{textureOpacityFactor_},
        edgeColor{edgeColor_} {}

  //! Default/empty constructor
  PassthroughStyleFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughStyleFB, next_), textureOpacityFactor{0.0f}, edgeColor{} {}

  //! Default copy constructor
  PassthroughStyleFB(const PassthroughStyleFB& rhs) = default;
  //! Default copy assignment
  PassthroughStyleFB& operator=(const PassthroughStyleFB& rhs) = default;
  //! Copy construct from raw
  PassthroughStyleFB(const XrPassthroughStyleFB& rhs) : PassthroughStyleFB() { *put() = rhs; }
  //! Copy assign from raw
  PassthroughStyleFB& operator=(const XrPassthroughStyleFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughStyleFB&() const {
    return *reinterpret_cast<const XrPassthroughStyleFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughStyleFB&() { return *reinterpret_cast<XrPassthroughStyleFB*>(this); }

  //! Accessor for this as the address of a raw XrPassthroughStyleFB
  XrPassthroughStyleFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughStyleFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughStyleFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughStyleFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughStyleFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughStyleFB*>(this);
  }
  float textureOpacityFactor;
  Color4f edgeColor;
};
static_assert(sizeof(XrPassthroughStyleFB) == sizeof(PassthroughStyleFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughStyleFB pointer to const from a
 * PassthroughStyleFB reference to const.
 * @relates PassthroughStyleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughStyleFB const* get(PassthroughStyleFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughStyleFB as the
 * address of a raw XrPassthroughStyleFB
 * @relates PassthroughStyleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughStyleFB* put(PassthroughStyleFB& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughColorMapMonoToMonoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapMonoToMonoFB>
 * @xrentity{XrPassthroughColorMapMonoToMonoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorMapMonoToMonoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorMapMonoToMonoFB(uint8_t textureColorMap_[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB],
                                  const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorMapMonoToMonoFB, next_) {
    memcpy(textureColorMap, textureColorMap_, sizeof(textureColorMap));
  }

  //! Default/empty constructor
  PassthroughColorMapMonoToMonoFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorMapMonoToMonoFB, next_), textureColorMap{0} {}

  //! Default copy constructor
  PassthroughColorMapMonoToMonoFB(const PassthroughColorMapMonoToMonoFB& rhs) = default;
  //! Default copy assignment
  PassthroughColorMapMonoToMonoFB& operator=(const PassthroughColorMapMonoToMonoFB& rhs) = default;
  //! Copy construct from raw
  PassthroughColorMapMonoToMonoFB(const XrPassthroughColorMapMonoToMonoFB& rhs)
      : PassthroughColorMapMonoToMonoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorMapMonoToMonoFB& operator=(const XrPassthroughColorMapMonoToMonoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorMapMonoToMonoFB&() const {
    return *reinterpret_cast<const XrPassthroughColorMapMonoToMonoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorMapMonoToMonoFB&() {
    return *reinterpret_cast<XrPassthroughColorMapMonoToMonoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorMapMonoToMonoFB
  XrPassthroughColorMapMonoToMonoFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorMapMonoToMonoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorMapMonoToMonoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorMapMonoToMonoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorMapMonoToMonoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorMapMonoToMonoFB*>(this);
  }
  uint8_t textureColorMap[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB];
};
static_assert(sizeof(XrPassthroughColorMapMonoToMonoFB) == sizeof(PassthroughColorMapMonoToMonoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapMonoToMonoFB pointer to const from a
 * PassthroughColorMapMonoToMonoFB reference to const.
 * @relates PassthroughColorMapMonoToMonoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToMonoFB const* get(
    PassthroughColorMapMonoToMonoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughColorMapMonoToMonoFB as the address of a raw XrPassthroughColorMapMonoToMonoFB
 * @relates PassthroughColorMapMonoToMonoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToMonoFB* put(PassthroughColorMapMonoToMonoFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrEventDataPassthroughStateChangedFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPassthroughStateChangedFB>
 * @xrentity{XrEventDataPassthroughStateChangedFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataPassthroughStateChangedFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EventDataPassthroughStateChangedFB(const PassthroughStateChangedFlagsFB& flags_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::EventDataPassthroughStateChangedFB, next_), flags{flags_} {}

  //! Default/empty constructor
  EventDataPassthroughStateChangedFB(const void* next_ = nullptr)

      : Parent(StructureType::EventDataPassthroughStateChangedFB, next_), flags{} {}

  //! Default copy constructor
  EventDataPassthroughStateChangedFB(const EventDataPassthroughStateChangedFB& rhs) = default;
  //! Default copy assignment
  EventDataPassthroughStateChangedFB& operator=(const EventDataPassthroughStateChangedFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataPassthroughStateChangedFB(const XrEventDataPassthroughStateChangedFB& rhs)
      : EventDataPassthroughStateChangedFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataPassthroughStateChangedFB& operator=(const XrEventDataPassthroughStateChangedFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataPassthroughStateChangedFB&() const {
    return *reinterpret_cast<const XrEventDataPassthroughStateChangedFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataPassthroughStateChangedFB&() {
    return *reinterpret_cast<XrEventDataPassthroughStateChangedFB*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataPassthroughStateChangedFB
  XrEventDataPassthroughStateChangedFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataPassthroughStateChangedFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataPassthroughStateChangedFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataPassthroughStateChangedFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataPassthroughStateChangedFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataPassthroughStateChangedFB*>(this);
  }
  PassthroughStateChangedFlagsFB flags;
};
static_assert(sizeof(XrEventDataPassthroughStateChangedFB) ==
                  sizeof(EventDataPassthroughStateChangedFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataPassthroughStateChangedFB pointer to const from
 * a EventDataPassthroughStateChangedFB reference to const.
 * @relates EventDataPassthroughStateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPassthroughStateChangedFB const* get(
    EventDataPassthroughStateChangedFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataPassthroughStateChangedFB as the address of a raw XrEventDataPassthroughStateChangedFB
 * @relates EventDataPassthroughStateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPassthroughStateChangedFB* put(
    EventDataPassthroughStateChangedFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelPathInfoFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPathInfoFB>
 * @xrentity{XrRenderModelPathInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelPathInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelPathInfoFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelPathInfoFB, next_) {}

  //! Default copy constructor
  RenderModelPathInfoFB(const RenderModelPathInfoFB& rhs) = default;
  //! Default copy assignment
  RenderModelPathInfoFB& operator=(const RenderModelPathInfoFB& rhs) = default;
  //! Copy construct from raw
  RenderModelPathInfoFB(const XrRenderModelPathInfoFB& rhs) : RenderModelPathInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelPathInfoFB& operator=(const XrRenderModelPathInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelPathInfoFB&() const {
    return *reinterpret_cast<const XrRenderModelPathInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelPathInfoFB&() { return *reinterpret_cast<XrRenderModelPathInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelPathInfoFB
  XrRenderModelPathInfoFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelPathInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelPathInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelPathInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelPathInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelPathInfoFB*>(this);
  }
  Path path;
};
static_assert(sizeof(XrRenderModelPathInfoFB) == sizeof(RenderModelPathInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelPathInfoFB pointer to const from a
 * RenderModelPathInfoFB reference to const.
 * @relates RenderModelPathInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPathInfoFB const* get(RenderModelPathInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPathInfoFB as the
 * address of a raw XrRenderModelPathInfoFB
 * @relates RenderModelPathInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPathInfoFB* put(RenderModelPathInfoFB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelPropertiesFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPropertiesFB>
 * @xrentity{XrRenderModelPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelPropertiesFB, next_) {}

  //! Default copy constructor
  RenderModelPropertiesFB(const RenderModelPropertiesFB& rhs) = default;
  //! Default copy assignment
  RenderModelPropertiesFB& operator=(const RenderModelPropertiesFB& rhs) = default;
  //! Copy construct from raw
  RenderModelPropertiesFB(const XrRenderModelPropertiesFB& rhs) : RenderModelPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelPropertiesFB& operator=(const XrRenderModelPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelPropertiesFB&() const {
    return *reinterpret_cast<const XrRenderModelPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelPropertiesFB&() {
    return *reinterpret_cast<XrRenderModelPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelPropertiesFB
  XrRenderModelPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelPropertiesFB*>(this);
  }
  uint32_t vendorId;
  char modelName[XR_MAX_RENDER_MODEL_NAME_SIZE_FB];
  RenderModelKeyFB modelKey;
  uint32_t modelVersion;
  RenderModelFlagsFB flags;
};
static_assert(sizeof(XrRenderModelPropertiesFB) == sizeof(RenderModelPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelPropertiesFB pointer to const from a
 * RenderModelPropertiesFB reference to const.
 * @relates RenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesFB const* get(RenderModelPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPropertiesFB as
 * the address of a raw XrRenderModelPropertiesFB
 * @relates RenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesFB* put(RenderModelPropertiesFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelBufferFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelBufferFB>
 * @xrentity{XrRenderModelBufferFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelBufferFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelBufferFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelBufferFB, next_) {}

  //! Default copy constructor
  RenderModelBufferFB(const RenderModelBufferFB& rhs) = default;
  //! Default copy assignment
  RenderModelBufferFB& operator=(const RenderModelBufferFB& rhs) = default;
  //! Copy construct from raw
  RenderModelBufferFB(const XrRenderModelBufferFB& rhs) : RenderModelBufferFB() { *put() = rhs; }
  //! Copy assign from raw
  RenderModelBufferFB& operator=(const XrRenderModelBufferFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelBufferFB&() const {
    return *reinterpret_cast<const XrRenderModelBufferFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelBufferFB&() { return *reinterpret_cast<XrRenderModelBufferFB*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelBufferFB
  XrRenderModelBufferFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelBufferFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelBufferFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelBufferFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelBufferFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelBufferFB*>(this);
  }
  uint32_t bufferCapacityInput;
  uint32_t bufferCountOutput;
  uint8_t* buffer;
};
static_assert(sizeof(XrRenderModelBufferFB) == sizeof(RenderModelBufferFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelBufferFB pointer to const from a
 * RenderModelBufferFB reference to const.
 * @relates RenderModelBufferFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelBufferFB const* get(RenderModelBufferFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelBufferFB as the
 * address of a raw XrRenderModelBufferFB
 * @relates RenderModelBufferFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelBufferFB* put(RenderModelBufferFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelLoadInfoFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelLoadInfoFB>
 * @xrentity{XrRenderModelLoadInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelLoadInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelLoadInfoFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelLoadInfoFB, next_) {}

  //! Default copy constructor
  RenderModelLoadInfoFB(const RenderModelLoadInfoFB& rhs) = default;
  //! Default copy assignment
  RenderModelLoadInfoFB& operator=(const RenderModelLoadInfoFB& rhs) = default;
  //! Copy construct from raw
  RenderModelLoadInfoFB(const XrRenderModelLoadInfoFB& rhs) : RenderModelLoadInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelLoadInfoFB& operator=(const XrRenderModelLoadInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelLoadInfoFB&() const {
    return *reinterpret_cast<const XrRenderModelLoadInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelLoadInfoFB&() { return *reinterpret_cast<XrRenderModelLoadInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelLoadInfoFB
  XrRenderModelLoadInfoFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelLoadInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelLoadInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelLoadInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelLoadInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelLoadInfoFB*>(this);
  }
  RenderModelKeyFB modelKey;
};
static_assert(sizeof(XrRenderModelLoadInfoFB) == sizeof(RenderModelLoadInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelLoadInfoFB pointer to const from a
 * RenderModelLoadInfoFB reference to const.
 * @relates RenderModelLoadInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelLoadInfoFB const* get(RenderModelLoadInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelLoadInfoFB as the
 * address of a raw XrRenderModelLoadInfoFB
 * @relates RenderModelLoadInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelLoadInfoFB* put(RenderModelLoadInfoFB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrSystemRenderModelPropertiesFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemRenderModelPropertiesFB>
 * @xrentity{XrSystemRenderModelPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemRenderModelPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemRenderModelPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemRenderModelPropertiesFB, next_) {}

  //! Default copy constructor
  SystemRenderModelPropertiesFB(const SystemRenderModelPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemRenderModelPropertiesFB& operator=(const SystemRenderModelPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemRenderModelPropertiesFB(const XrSystemRenderModelPropertiesFB& rhs)
      : SystemRenderModelPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemRenderModelPropertiesFB& operator=(const XrSystemRenderModelPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemRenderModelPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemRenderModelPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemRenderModelPropertiesFB&() {
    return *reinterpret_cast<XrSystemRenderModelPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemRenderModelPropertiesFB
  XrSystemRenderModelPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemRenderModelPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemRenderModelPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemRenderModelPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemRenderModelPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemRenderModelPropertiesFB*>(this);
  }
  Bool32 supportsRenderModelLoading;
};
static_assert(sizeof(XrSystemRenderModelPropertiesFB) == sizeof(SystemRenderModelPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemRenderModelPropertiesFB pointer to const from a
 * SystemRenderModelPropertiesFB reference to const.
 * @relates SystemRenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemRenderModelPropertiesFB const* get(
    SystemRenderModelPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemRenderModelPropertiesFB
 * as the address of a raw XrSystemRenderModelPropertiesFB
 * @relates SystemRenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemRenderModelPropertiesFB* put(SystemRenderModelPropertiesFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrViewLocateFoveatedRenderingVARJO
 *
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateFoveatedRenderingVARJO>
 * @xrentity{XrViewLocateFoveatedRenderingVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewLocateFoveatedRenderingVARJO : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewLocateFoveatedRenderingVARJO(const Bool32& foveatedRenderingActive_,
                                   const void* next_ = nullptr)
      : Parent(StructureType::ViewLocateFoveatedRenderingVARJO, next_),
        foveatedRenderingActive{foveatedRenderingActive_} {}

  //! Default/empty constructor
  ViewLocateFoveatedRenderingVARJO(const void* next_ = nullptr)

      : Parent(StructureType::ViewLocateFoveatedRenderingVARJO, next_),
        foveatedRenderingActive{false} {}

  //! Default copy constructor
  ViewLocateFoveatedRenderingVARJO(const ViewLocateFoveatedRenderingVARJO& rhs) = default;
  //! Default copy assignment
  ViewLocateFoveatedRenderingVARJO& operator=(const ViewLocateFoveatedRenderingVARJO& rhs) =
      default;
  //! Copy construct from raw
  ViewLocateFoveatedRenderingVARJO(const XrViewLocateFoveatedRenderingVARJO& rhs)
      : ViewLocateFoveatedRenderingVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewLocateFoveatedRenderingVARJO& operator=(const XrViewLocateFoveatedRenderingVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewLocateFoveatedRenderingVARJO&() const {
    return *reinterpret_cast<const XrViewLocateFoveatedRenderingVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewLocateFoveatedRenderingVARJO&() {
    return *reinterpret_cast<XrViewLocateFoveatedRenderingVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrViewLocateFoveatedRenderingVARJO
  XrViewLocateFoveatedRenderingVARJO const* get() const noexcept {
    return reinterpret_cast<XrViewLocateFoveatedRenderingVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewLocateFoveatedRenderingVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewLocateFoveatedRenderingVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewLocateFoveatedRenderingVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewLocateFoveatedRenderingVARJO*>(this);
  }
  Bool32 foveatedRenderingActive;
};
static_assert(sizeof(XrViewLocateFoveatedRenderingVARJO) ==
                  sizeof(ViewLocateFoveatedRenderingVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewLocateFoveatedRenderingVARJO pointer to const from a
 * ViewLocateFoveatedRenderingVARJO reference to const.
 * @relates ViewLocateFoveatedRenderingVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateFoveatedRenderingVARJO const* get(
    ViewLocateFoveatedRenderingVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ViewLocateFoveatedRenderingVARJO as the address of a raw XrViewLocateFoveatedRenderingVARJO
 * @relates ViewLocateFoveatedRenderingVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateFoveatedRenderingVARJO* put(
    ViewLocateFoveatedRenderingVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_foveated_rendering

#ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrFoveatedViewConfigurationViewVARJO
 *
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveatedViewConfigurationViewVARJO>
 * @xrentity{XrFoveatedViewConfigurationViewVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveatedViewConfigurationViewVARJO : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveatedViewConfigurationViewVARJO(void* next_ = nullptr)

      : Parent(StructureType::FoveatedViewConfigurationViewVARJO, next_) {}

  //! Default copy constructor
  FoveatedViewConfigurationViewVARJO(const FoveatedViewConfigurationViewVARJO& rhs) = default;
  //! Default copy assignment
  FoveatedViewConfigurationViewVARJO& operator=(const FoveatedViewConfigurationViewVARJO& rhs) =
      default;
  //! Copy construct from raw
  FoveatedViewConfigurationViewVARJO(const XrFoveatedViewConfigurationViewVARJO& rhs)
      : FoveatedViewConfigurationViewVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveatedViewConfigurationViewVARJO& operator=(const XrFoveatedViewConfigurationViewVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveatedViewConfigurationViewVARJO&() const {
    return *reinterpret_cast<const XrFoveatedViewConfigurationViewVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveatedViewConfigurationViewVARJO&() {
    return *reinterpret_cast<XrFoveatedViewConfigurationViewVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveatedViewConfigurationViewVARJO
  XrFoveatedViewConfigurationViewVARJO const* get() const noexcept {
    return reinterpret_cast<XrFoveatedViewConfigurationViewVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveatedViewConfigurationViewVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveatedViewConfigurationViewVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveatedViewConfigurationViewVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveatedViewConfigurationViewVARJO*>(this);
  }
  Bool32 foveatedRenderingActive;
};
static_assert(sizeof(XrFoveatedViewConfigurationViewVARJO) ==
                  sizeof(FoveatedViewConfigurationViewVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveatedViewConfigurationViewVARJO pointer to const from
 * a FoveatedViewConfigurationViewVARJO reference to const.
 * @relates FoveatedViewConfigurationViewVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveatedViewConfigurationViewVARJO const* get(
    FoveatedViewConfigurationViewVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FoveatedViewConfigurationViewVARJO as the address of a raw XrFoveatedViewConfigurationViewVARJO
 * @relates FoveatedViewConfigurationViewVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveatedViewConfigurationViewVARJO* put(
    FoveatedViewConfigurationViewVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_foveated_rendering

#ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrSystemFoveatedRenderingPropertiesVARJO
 *
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFoveatedRenderingPropertiesVARJO>
 * @xrentity{XrSystemFoveatedRenderingPropertiesVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFoveatedRenderingPropertiesVARJO : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFoveatedRenderingPropertiesVARJO(void* next_ = nullptr)

      : Parent(StructureType::SystemFoveatedRenderingPropertiesVARJO, next_) {}

  //! Default copy constructor
  SystemFoveatedRenderingPropertiesVARJO(const SystemFoveatedRenderingPropertiesVARJO& rhs) =
      default;
  //! Default copy assignment
  SystemFoveatedRenderingPropertiesVARJO& operator=(
      const SystemFoveatedRenderingPropertiesVARJO& rhs) = default;
  //! Copy construct from raw
  SystemFoveatedRenderingPropertiesVARJO(const XrSystemFoveatedRenderingPropertiesVARJO& rhs)
      : SystemFoveatedRenderingPropertiesVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFoveatedRenderingPropertiesVARJO& operator=(
      const XrSystemFoveatedRenderingPropertiesVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFoveatedRenderingPropertiesVARJO&() const {
    return *reinterpret_cast<const XrSystemFoveatedRenderingPropertiesVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFoveatedRenderingPropertiesVARJO&() {
    return *reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFoveatedRenderingPropertiesVARJO
  XrSystemFoveatedRenderingPropertiesVARJO const* get() const noexcept {
    return reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFoveatedRenderingPropertiesVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFoveatedRenderingPropertiesVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFoveatedRenderingPropertiesVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO*>(this);
  }
  Bool32 supportsFoveatedRendering;
};
static_assert(sizeof(XrSystemFoveatedRenderingPropertiesVARJO) ==
                  sizeof(SystemFoveatedRenderingPropertiesVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFoveatedRenderingPropertiesVARJO pointer to const
 * from a SystemFoveatedRenderingPropertiesVARJO reference to const.
 * @relates SystemFoveatedRenderingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFoveatedRenderingPropertiesVARJO const* get(
    SystemFoveatedRenderingPropertiesVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFoveatedRenderingPropertiesVARJO as the address of a raw
 * XrSystemFoveatedRenderingPropertiesVARJO
 * @relates SystemFoveatedRenderingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFoveatedRenderingPropertiesVARJO* put(
    SystemFoveatedRenderingPropertiesVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_foveated_rendering

#ifdef XR_VARJO_composition_layer_depth_test
/*!
 * C++ projection of XrCompositionLayerDepthTestVARJO
 *
 * Provided by the `XR_VARJO_composition_layer_depth_test` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthTestVARJO>
 * @xrentity{XrCompositionLayerDepthTestVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerDepthTestVARJO : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerDepthTestVARJO(float depthTestRangeNearZ_, float depthTestRangeFarZ_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthTestVARJO, next_),
        depthTestRangeNearZ{depthTestRangeNearZ_},
        depthTestRangeFarZ{depthTestRangeFarZ_} {}

  //! Default/empty constructor
  CompositionLayerDepthTestVARJO(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerDepthTestVARJO, next_),
        depthTestRangeNearZ{0.0f},
        depthTestRangeFarZ{0.0f} {}

  //! Default copy constructor
  CompositionLayerDepthTestVARJO(const CompositionLayerDepthTestVARJO& rhs) = default;
  //! Default copy assignment
  CompositionLayerDepthTestVARJO& operator=(const CompositionLayerDepthTestVARJO& rhs) = default;
  //! Copy construct from raw
  CompositionLayerDepthTestVARJO(const XrCompositionLayerDepthTestVARJO& rhs)
      : CompositionLayerDepthTestVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerDepthTestVARJO& operator=(const XrCompositionLayerDepthTestVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerDepthTestVARJO&() const {
    return *reinterpret_cast<const XrCompositionLayerDepthTestVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerDepthTestVARJO&() {
    return *reinterpret_cast<XrCompositionLayerDepthTestVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerDepthTestVARJO
  XrCompositionLayerDepthTestVARJO const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerDepthTestVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerDepthTestVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerDepthTestVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerDepthTestVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerDepthTestVARJO*>(this);
  }
  float depthTestRangeNearZ;
  float depthTestRangeFarZ;
};
static_assert(sizeof(XrCompositionLayerDepthTestVARJO) == sizeof(CompositionLayerDepthTestVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthTestVARJO pointer to const from a
 * CompositionLayerDepthTestVARJO reference to const.
 * @relates CompositionLayerDepthTestVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthTestVARJO const* get(
    CompositionLayerDepthTestVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerDepthTestVARJO as the address of a raw XrCompositionLayerDepthTestVARJO
 * @relates CompositionLayerDepthTestVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthTestVARJO* put(CompositionLayerDepthTestVARJO& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_composition_layer_depth_test

#ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrSystemMarkerTrackingPropertiesVARJO
 *
 * Provided by the `XR_VARJO_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemMarkerTrackingPropertiesVARJO>
 * @xrentity{XrSystemMarkerTrackingPropertiesVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemMarkerTrackingPropertiesVARJO : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemMarkerTrackingPropertiesVARJO(void* next_ = nullptr)

      : Parent(StructureType::SystemMarkerTrackingPropertiesVARJO, next_) {}

  //! Default copy constructor
  SystemMarkerTrackingPropertiesVARJO(const SystemMarkerTrackingPropertiesVARJO& rhs) = default;
  //! Default copy assignment
  SystemMarkerTrackingPropertiesVARJO& operator=(const SystemMarkerTrackingPropertiesVARJO& rhs) =
      default;
  //! Copy construct from raw
  SystemMarkerTrackingPropertiesVARJO(const XrSystemMarkerTrackingPropertiesVARJO& rhs)
      : SystemMarkerTrackingPropertiesVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemMarkerTrackingPropertiesVARJO& operator=(const XrSystemMarkerTrackingPropertiesVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemMarkerTrackingPropertiesVARJO&() const {
    return *reinterpret_cast<const XrSystemMarkerTrackingPropertiesVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemMarkerTrackingPropertiesVARJO&() {
    return *reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemMarkerTrackingPropertiesVARJO
  XrSystemMarkerTrackingPropertiesVARJO const* get() const noexcept {
    return reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemMarkerTrackingPropertiesVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemMarkerTrackingPropertiesVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemMarkerTrackingPropertiesVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO*>(this);
  }
  Bool32 supportsMarkerTracking;
};
static_assert(sizeof(XrSystemMarkerTrackingPropertiesVARJO) ==
                  sizeof(SystemMarkerTrackingPropertiesVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemMarkerTrackingPropertiesVARJO pointer to const
 * from a SystemMarkerTrackingPropertiesVARJO reference to const.
 * @relates SystemMarkerTrackingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemMarkerTrackingPropertiesVARJO const* get(
    SystemMarkerTrackingPropertiesVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemMarkerTrackingPropertiesVARJO as the address of a raw XrSystemMarkerTrackingPropertiesVARJO
 * @relates SystemMarkerTrackingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemMarkerTrackingPropertiesVARJO* put(
    SystemMarkerTrackingPropertiesVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrEventDataMarkerTrackingUpdateVARJO
 *
 * Provided by the `XR_VARJO_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMarkerTrackingUpdateVARJO>
 * @xrentity{XrEventDataMarkerTrackingUpdateVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataMarkerTrackingUpdateVARJO : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataMarkerTrackingUpdateVARJO(uint64_t markerId_, const Bool32& isActive_,
                                     const Bool32& isPredicted_, const Time& time_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::EventDataMarkerTrackingUpdateVARJO, next_),
        markerId{markerId_},
        isActive{isActive_},
        isPredicted{isPredicted_},
        time{time_} {}

  //! Default/empty constructor
  EventDataMarkerTrackingUpdateVARJO(const void* next_ = nullptr)

      : Parent(StructureType::EventDataMarkerTrackingUpdateVARJO, next_),
        markerId{0},
        isActive{false},
        isPredicted{false},
        time{} {}

  //! Default copy constructor
  EventDataMarkerTrackingUpdateVARJO(const EventDataMarkerTrackingUpdateVARJO& rhs) = default;
  //! Default copy assignment
  EventDataMarkerTrackingUpdateVARJO& operator=(const EventDataMarkerTrackingUpdateVARJO& rhs) =
      default;
  //! Copy construct from raw
  EventDataMarkerTrackingUpdateVARJO(const XrEventDataMarkerTrackingUpdateVARJO& rhs)
      : EventDataMarkerTrackingUpdateVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataMarkerTrackingUpdateVARJO& operator=(const XrEventDataMarkerTrackingUpdateVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataMarkerTrackingUpdateVARJO&() const {
    return *reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataMarkerTrackingUpdateVARJO&() {
    return *reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataMarkerTrackingUpdateVARJO
  XrEventDataMarkerTrackingUpdateVARJO const* get() const noexcept {
    return reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataMarkerTrackingUpdateVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataMarkerTrackingUpdateVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataMarkerTrackingUpdateVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO*>(this);
  }
  uint64_t markerId;
  Bool32 isActive;
  Bool32 isPredicted;
  Time time;
};
static_assert(sizeof(XrEventDataMarkerTrackingUpdateVARJO) ==
                  sizeof(EventDataMarkerTrackingUpdateVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataMarkerTrackingUpdateVARJO pointer to const from
 * a EventDataMarkerTrackingUpdateVARJO reference to const.
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMarkerTrackingUpdateVARJO const* get(
    EventDataMarkerTrackingUpdateVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataMarkerTrackingUpdateVARJO as the address of a raw XrEventDataMarkerTrackingUpdateVARJO
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMarkerTrackingUpdateVARJO* put(
    EventDataMarkerTrackingUpdateVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataMarkerTrackingUpdateVARJO as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataMarkerTrackingUpdateVARJO const& h) {
  return h.get_base();
}
#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrMarkerSpaceCreateInfoVARJO
 *
 * Provided by the `XR_VARJO_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerSpaceCreateInfoVARJO>
 * @xrentity{XrMarkerSpaceCreateInfoVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerSpaceCreateInfoVARJO : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerSpaceCreateInfoVARJO(uint64_t markerId_, const Posef& poseInMarkerSpace_,
                             const void* next_ = nullptr)
      : Parent(StructureType::MarkerSpaceCreateInfoVARJO, next_),
        markerId{markerId_},
        poseInMarkerSpace{poseInMarkerSpace_} {}

  //! Default/empty constructor
  MarkerSpaceCreateInfoVARJO(const void* next_ = nullptr)

      : Parent(StructureType::MarkerSpaceCreateInfoVARJO, next_),
        markerId{0},
        poseInMarkerSpace{} {}

  //! Default copy constructor
  MarkerSpaceCreateInfoVARJO(const MarkerSpaceCreateInfoVARJO& rhs) = default;
  //! Default copy assignment
  MarkerSpaceCreateInfoVARJO& operator=(const MarkerSpaceCreateInfoVARJO& rhs) = default;
  //! Copy construct from raw
  MarkerSpaceCreateInfoVARJO(const XrMarkerSpaceCreateInfoVARJO& rhs)
      : MarkerSpaceCreateInfoVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerSpaceCreateInfoVARJO& operator=(const XrMarkerSpaceCreateInfoVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerSpaceCreateInfoVARJO&() const {
    return *reinterpret_cast<const XrMarkerSpaceCreateInfoVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerSpaceCreateInfoVARJO&() {
    return *reinterpret_cast<XrMarkerSpaceCreateInfoVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerSpaceCreateInfoVARJO
  XrMarkerSpaceCreateInfoVARJO const* get() const noexcept {
    return reinterpret_cast<XrMarkerSpaceCreateInfoVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerSpaceCreateInfoVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerSpaceCreateInfoVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerSpaceCreateInfoVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerSpaceCreateInfoVARJO*>(this);
  }
  uint64_t markerId;
  Posef poseInMarkerSpace;
};
static_assert(sizeof(XrMarkerSpaceCreateInfoVARJO) == sizeof(MarkerSpaceCreateInfoVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerSpaceCreateInfoVARJO pointer to const from a
 * MarkerSpaceCreateInfoVARJO reference to const.
 * @relates MarkerSpaceCreateInfoVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoVARJO const* get(
    MarkerSpaceCreateInfoVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerSpaceCreateInfoVARJO as
 * the address of a raw XrMarkerSpaceCreateInfoVARJO
 * @relates MarkerSpaceCreateInfoVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoVARJO* put(MarkerSpaceCreateInfoVARJO& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_marker_tracking

#ifdef XR_MSFT_spatial_anchor_persistence
/*!
 * C++ projection of XrSpatialAnchorPersistenceNameMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorPersistenceNameMSFT>
 * @xrentity{XrSpatialAnchorPersistenceNameMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialAnchorPersistenceNameMSFT {
public:
  //! Constructor initializing all members.
  SpatialAnchorPersistenceNameMSFT(const char* name_) {
    if (nullptr != name_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(name, XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT, name_,
                XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT);
#else
      strncpy(name, name_, XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT - 1);
      name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  SpatialAnchorPersistenceNameMSFT()

  {}

  //! Default copy constructor
  SpatialAnchorPersistenceNameMSFT(const SpatialAnchorPersistenceNameMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorPersistenceNameMSFT& operator=(const SpatialAnchorPersistenceNameMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorPersistenceNameMSFT(const XrSpatialAnchorPersistenceNameMSFT& rhs)
      : SpatialAnchorPersistenceNameMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorPersistenceNameMSFT& operator=(const XrSpatialAnchorPersistenceNameMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorPersistenceNameMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorPersistenceNameMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorPersistenceNameMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorPersistenceNameMSFT
  XrSpatialAnchorPersistenceNameMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorPersistenceNameMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialAnchorPersistenceNameMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialAnchorPersistenceNameMSFT{};
    }
    return reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(this);
  }
  char name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT];
};
static_assert(sizeof(XrSpatialAnchorPersistenceNameMSFT) ==
                  sizeof(SpatialAnchorPersistenceNameMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorPersistenceNameMSFT pointer to const from a
 * SpatialAnchorPersistenceNameMSFT reference to const.
 * @relates SpatialAnchorPersistenceNameMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceNameMSFT const* get(
    SpatialAnchorPersistenceNameMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorPersistenceNameMSFT as the address of a raw XrSpatialAnchorPersistenceNameMSFT
 * @relates SpatialAnchorPersistenceNameMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceNameMSFT* put(
    SpatialAnchorPersistenceNameMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence
/*!
 * C++ projection of XrSpatialAnchorPersistenceInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorPersistenceInfoMSFT>
 * @xrentity{XrSpatialAnchorPersistenceInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorPersistenceInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorPersistenceInfoMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName_,
      const SpatialAnchorMSFT& spatialAnchor_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorPersistenceInfoMSFT, next_),
        spatialAnchorPersistenceName{spatialAnchorPersistenceName_},
        spatialAnchor{spatialAnchor_} {}

  //! Default/empty constructor
  SpatialAnchorPersistenceInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorPersistenceInfoMSFT, next_),
        spatialAnchorPersistenceName{},
        spatialAnchor{} {}

  //! Default copy constructor
  SpatialAnchorPersistenceInfoMSFT(const SpatialAnchorPersistenceInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorPersistenceInfoMSFT& operator=(const SpatialAnchorPersistenceInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorPersistenceInfoMSFT(const XrSpatialAnchorPersistenceInfoMSFT& rhs)
      : SpatialAnchorPersistenceInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorPersistenceInfoMSFT& operator=(const XrSpatialAnchorPersistenceInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorPersistenceInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorPersistenceInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorPersistenceInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorPersistenceInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorPersistenceInfoMSFT
  XrSpatialAnchorPersistenceInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorPersistenceInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorPersistenceInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorPersistenceInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorPersistenceInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorPersistenceInfoMSFT*>(this);
  }
  SpatialAnchorPersistenceNameMSFT spatialAnchorPersistenceName;
  SpatialAnchorMSFT spatialAnchor;
};
static_assert(sizeof(XrSpatialAnchorPersistenceInfoMSFT) ==
                  sizeof(SpatialAnchorPersistenceInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorPersistenceInfoMSFT pointer to const from a
 * SpatialAnchorPersistenceInfoMSFT reference to const.
 * @relates SpatialAnchorPersistenceInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceInfoMSFT const* get(
    SpatialAnchorPersistenceInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorPersistenceInfoMSFT as the address of a raw XrSpatialAnchorPersistenceInfoMSFT
 * @relates SpatialAnchorPersistenceInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceInfoMSFT* put(
    SpatialAnchorPersistenceInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence
/*!
 * C++ projection of XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorFromPersistedAnchorCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(
      const SpatialAnchorStoreConnectionMSFT& spatialAnchorStore_,
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName_,
      const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT, next_),
        spatialAnchorStore{spatialAnchorStore_},
        spatialAnchorPersistenceName{spatialAnchorPersistenceName_} {}

  //! Default/empty constructor
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT, next_),
        spatialAnchorStore{},
        spatialAnchorPersistenceName{} {}

  //! Default copy constructor
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT& operator=(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(
      const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs)
      : SpatialAnchorFromPersistedAnchorCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT& operator=(
      const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
  XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorFromPersistedAnchorCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(this);
  }
  SpatialAnchorStoreConnectionMSFT spatialAnchorStore;
  SpatialAnchorPersistenceNameMSFT spatialAnchorPersistenceName;
};
static_assert(sizeof(XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT) ==
                  sizeof(SpatialAnchorFromPersistedAnchorCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT pointer
 * to const from a SpatialAnchorFromPersistedAnchorCreateInfoMSFT reference to const.
 * @relates SpatialAnchorFromPersistedAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT const* get(
    SpatialAnchorFromPersistedAnchorCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorFromPersistedAnchorCreateInfoMSFT as the address of a raw
 * XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
 * @relates SpatialAnchorFromPersistedAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* put(
    SpatialAnchorFromPersistedAnchorCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_FB_foveation_vulkan
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageFoveationVulkanFB
 *
 * Provided by the `XR_FB_foveation_vulkan` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageFoveationVulkanFB>
 * @xrentity{XrSwapchainImageFoveationVulkanFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageFoveationVulkanFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageFoveationVulkanFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageFoveationVulkanFB, next_) {}

  //! Default copy constructor
  SwapchainImageFoveationVulkanFB(const SwapchainImageFoveationVulkanFB& rhs) = default;
  //! Default copy assignment
  SwapchainImageFoveationVulkanFB& operator=(const SwapchainImageFoveationVulkanFB& rhs) = default;
  //! Copy construct from raw
  SwapchainImageFoveationVulkanFB(const XrSwapchainImageFoveationVulkanFB& rhs)
      : SwapchainImageFoveationVulkanFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageFoveationVulkanFB& operator=(const XrSwapchainImageFoveationVulkanFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageFoveationVulkanFB&() const {
    return *reinterpret_cast<const XrSwapchainImageFoveationVulkanFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageFoveationVulkanFB&() {
    return *reinterpret_cast<XrSwapchainImageFoveationVulkanFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageFoveationVulkanFB
  XrSwapchainImageFoveationVulkanFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageFoveationVulkanFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageFoveationVulkanFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageFoveationVulkanFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageFoveationVulkanFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageFoveationVulkanFB*>(this);
  }
  VkImage image;
  uint32_t width;
  uint32_t height;
};
static_assert(sizeof(XrSwapchainImageFoveationVulkanFB) == sizeof(SwapchainImageFoveationVulkanFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageFoveationVulkanFB pointer to const from a
 * SwapchainImageFoveationVulkanFB reference to const.
 * @relates SwapchainImageFoveationVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageFoveationVulkanFB const* get(
    SwapchainImageFoveationVulkanFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainImageFoveationVulkanFB as the address of a raw XrSwapchainImageFoveationVulkanFB
 * @relates SwapchainImageFoveationVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageFoveationVulkanFB* put(SwapchainImageFoveationVulkanFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_FB_foveation_vulkan

#ifdef XR_FB_swapchain_update_state_android_surface
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrSwapchainStateAndroidSurfaceDimensionsFB
 *
 * Provided by the `XR_FB_swapchain_update_state_android_surface` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateAndroidSurfaceDimensionsFB>
 * @xrentity{XrSwapchainStateAndroidSurfaceDimensionsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateAndroidSurfaceDimensionsFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateAndroidSurfaceDimensionsFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateAndroidSurfaceDimensionsFB, next_) {}

  //! Default copy constructor
  SwapchainStateAndroidSurfaceDimensionsFB(const SwapchainStateAndroidSurfaceDimensionsFB& rhs) =
      default;
  //! Default copy assignment
  SwapchainStateAndroidSurfaceDimensionsFB& operator=(
      const SwapchainStateAndroidSurfaceDimensionsFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateAndroidSurfaceDimensionsFB(const XrSwapchainStateAndroidSurfaceDimensionsFB& rhs)
      : SwapchainStateAndroidSurfaceDimensionsFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateAndroidSurfaceDimensionsFB& operator=(
      const XrSwapchainStateAndroidSurfaceDimensionsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateAndroidSurfaceDimensionsFB&() const {
    return *reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateAndroidSurfaceDimensionsFB&() {
    return *reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateAndroidSurfaceDimensionsFB
  XrSwapchainStateAndroidSurfaceDimensionsFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateAndroidSurfaceDimensionsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateAndroidSurfaceDimensionsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateAndroidSurfaceDimensionsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
  }
  uint32_t width;
  uint32_t height;
};
static_assert(sizeof(XrSwapchainStateAndroidSurfaceDimensionsFB) ==
                  sizeof(SwapchainStateAndroidSurfaceDimensionsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateAndroidSurfaceDimensionsFB pointer to
 * const from a SwapchainStateAndroidSurfaceDimensionsFB reference to const.
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateAndroidSurfaceDimensionsFB const* get(
    SwapchainStateAndroidSurfaceDimensionsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainStateAndroidSurfaceDimensionsFB as the address of a raw
 * XrSwapchainStateAndroidSurfaceDimensionsFB
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateAndroidSurfaceDimensionsFB* put(
    SwapchainStateAndroidSurfaceDimensionsFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateAndroidSurfaceDimensionsFB
 * as a raw, pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateAndroidSurfaceDimensionsFB const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_FB_swapchain_update_state_android_surface

#ifdef XR_FB_swapchain_update_state_opengl_es
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainStateSamplerOpenGLESFB
 *
 * Provided by the `XR_FB_swapchain_update_state_opengl_es` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateSamplerOpenGLESFB>
 * @xrentity{XrSwapchainStateSamplerOpenGLESFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateSamplerOpenGLESFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateSamplerOpenGLESFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateSamplerOpenGLESFB, next_) {}

  //! Default copy constructor
  SwapchainStateSamplerOpenGLESFB(const SwapchainStateSamplerOpenGLESFB& rhs) = default;
  //! Default copy assignment
  SwapchainStateSamplerOpenGLESFB& operator=(const SwapchainStateSamplerOpenGLESFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateSamplerOpenGLESFB(const XrSwapchainStateSamplerOpenGLESFB& rhs)
      : SwapchainStateSamplerOpenGLESFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateSamplerOpenGLESFB& operator=(const XrSwapchainStateSamplerOpenGLESFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateSamplerOpenGLESFB&() const {
    return *reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateSamplerOpenGLESFB&() {
    return *reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateSamplerOpenGLESFB
  XrSwapchainStateSamplerOpenGLESFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateSamplerOpenGLESFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateSamplerOpenGLESFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateSamplerOpenGLESFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(this);
  }
  EGLenum minFilter;
  EGLenum magFilter;
  EGLenum wrapModeS;
  EGLenum wrapModeT;
  EGLenum swizzleRed;
  EGLenum swizzleGreen;
  EGLenum swizzleBlue;
  EGLenum swizzleAlpha;
  float maxAnisotropy;
  Color4f borderColor;
};
static_assert(sizeof(XrSwapchainStateSamplerOpenGLESFB) == sizeof(SwapchainStateSamplerOpenGLESFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateSamplerOpenGLESFB pointer to const from a
 * SwapchainStateSamplerOpenGLESFB reference to const.
 * @relates SwapchainStateSamplerOpenGLESFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerOpenGLESFB const* get(
    SwapchainStateSamplerOpenGLESFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainStateSamplerOpenGLESFB as the address of a raw XrSwapchainStateSamplerOpenGLESFB
 * @relates SwapchainStateSamplerOpenGLESFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerOpenGLESFB* put(SwapchainStateSamplerOpenGLESFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateSamplerOpenGLESFB as a raw,
 * pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateSamplerOpenGLESFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateSamplerOpenGLESFB const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_FB_swapchain_update_state_opengl_es

#ifdef XR_FB_swapchain_update_state_vulkan
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainStateSamplerVulkanFB
 *
 * Provided by the `XR_FB_swapchain_update_state_vulkan` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateSamplerVulkanFB>
 * @xrentity{XrSwapchainStateSamplerVulkanFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateSamplerVulkanFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateSamplerVulkanFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateSamplerVulkanFB, next_) {}

  //! Default copy constructor
  SwapchainStateSamplerVulkanFB(const SwapchainStateSamplerVulkanFB& rhs) = default;
  //! Default copy assignment
  SwapchainStateSamplerVulkanFB& operator=(const SwapchainStateSamplerVulkanFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateSamplerVulkanFB(const XrSwapchainStateSamplerVulkanFB& rhs)
      : SwapchainStateSamplerVulkanFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateSamplerVulkanFB& operator=(const XrSwapchainStateSamplerVulkanFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateSamplerVulkanFB&() const {
    return *reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateSamplerVulkanFB&() {
    return *reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateSamplerVulkanFB
  XrSwapchainStateSamplerVulkanFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateSamplerVulkanFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateSamplerVulkanFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateSamplerVulkanFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateSamplerVulkanFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(this);
  }
  VkFilter minFilter;
  VkFilter magFilter;
  VkSamplerMipmapMode mipmapMode;
  VkSamplerAddressMode wrapModeS;
  VkSamplerAddressMode wrapModeT;
  VkComponentSwizzle swizzleRed;
  VkComponentSwizzle swizzleGreen;
  VkComponentSwizzle swizzleBlue;
  VkComponentSwizzle swizzleAlpha;
  float maxAnisotropy;
  Color4f borderColor;
};
static_assert(sizeof(XrSwapchainStateSamplerVulkanFB) == sizeof(SwapchainStateSamplerVulkanFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateSamplerVulkanFB pointer to const from a
 * SwapchainStateSamplerVulkanFB reference to const.
 * @relates SwapchainStateSamplerVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerVulkanFB const* get(
    SwapchainStateSamplerVulkanFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateSamplerVulkanFB
 * as the address of a raw XrSwapchainStateSamplerVulkanFB
 * @relates SwapchainStateSamplerVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerVulkanFB* put(SwapchainStateSamplerVulkanFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateSamplerVulkanFB as a raw,
 * pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateSamplerVulkanFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateSamplerVulkanFB const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_FB_swapchain_update_state_vulkan

#ifdef XR_FB_space_warp
/*!
 * C++ projection of XrCompositionLayerSpaceWarpInfoFB
 *
 * Provided by the `XR_FB_space_warp` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSpaceWarpInfoFB>
 * @xrentity{XrCompositionLayerSpaceWarpInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerSpaceWarpInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerSpaceWarpInfoFB(const CompositionLayerSpaceWarpInfoFlagsFB& layerFlags_,
                                  const SwapchainSubImage& motionVectorSubImage_,
                                  const Posef& appSpaceDeltaPose_,
                                  const SwapchainSubImage& depthSubImage_, float minDepth_,
                                  float maxDepth_, float nearZ_, float farZ_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerSpaceWarpInfoFB, next_),
        layerFlags{layerFlags_},
        motionVectorSubImage{motionVectorSubImage_},
        appSpaceDeltaPose{appSpaceDeltaPose_},
        depthSubImage{depthSubImage_},
        minDepth{minDepth_},
        maxDepth{maxDepth_},
        nearZ{nearZ_},
        farZ{farZ_} {}

  //! Default/empty constructor
  CompositionLayerSpaceWarpInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerSpaceWarpInfoFB, next_),
        layerFlags{},
        motionVectorSubImage{},
        appSpaceDeltaPose{},
        depthSubImage{},
        minDepth{0.0f},
        maxDepth{0.0f},
        nearZ{0.0f},
        farZ{0.0f} {}

  //! Default copy constructor
  CompositionLayerSpaceWarpInfoFB(const CompositionLayerSpaceWarpInfoFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerSpaceWarpInfoFB& operator=(const CompositionLayerSpaceWarpInfoFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerSpaceWarpInfoFB(const XrCompositionLayerSpaceWarpInfoFB& rhs)
      : CompositionLayerSpaceWarpInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerSpaceWarpInfoFB& operator=(const XrCompositionLayerSpaceWarpInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerSpaceWarpInfoFB&() const {
    return *reinterpret_cast<const XrCompositionLayerSpaceWarpInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerSpaceWarpInfoFB&() {
    return *reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerSpaceWarpInfoFB
  XrCompositionLayerSpaceWarpInfoFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerSpaceWarpInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerSpaceWarpInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerSpaceWarpInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB*>(this);
  }
  CompositionLayerSpaceWarpInfoFlagsFB layerFlags;
  SwapchainSubImage motionVectorSubImage;
  Posef appSpaceDeltaPose;
  SwapchainSubImage depthSubImage;
  float minDepth;
  float maxDepth;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrCompositionLayerSpaceWarpInfoFB) == sizeof(CompositionLayerSpaceWarpInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerSpaceWarpInfoFB pointer to const from a
 * CompositionLayerSpaceWarpInfoFB reference to const.
 * @relates CompositionLayerSpaceWarpInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSpaceWarpInfoFB const* get(
    CompositionLayerSpaceWarpInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerSpaceWarpInfoFB as the address of a raw XrCompositionLayerSpaceWarpInfoFB
 * @relates CompositionLayerSpaceWarpInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSpaceWarpInfoFB* put(CompositionLayerSpaceWarpInfoFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_space_warp

#ifdef XR_FB_space_warp
/*!
 * C++ projection of XrSystemSpaceWarpPropertiesFB
 *
 * Provided by the `XR_FB_space_warp` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpaceWarpPropertiesFB>
 * @xrentity{XrSystemSpaceWarpPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpaceWarpPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpaceWarpPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemSpaceWarpPropertiesFB, next_) {}

  //! Default copy constructor
  SystemSpaceWarpPropertiesFB(const SystemSpaceWarpPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemSpaceWarpPropertiesFB& operator=(const SystemSpaceWarpPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemSpaceWarpPropertiesFB(const XrSystemSpaceWarpPropertiesFB& rhs)
      : SystemSpaceWarpPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpaceWarpPropertiesFB& operator=(const XrSystemSpaceWarpPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpaceWarpPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemSpaceWarpPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpaceWarpPropertiesFB&() {
    return *reinterpret_cast<XrSystemSpaceWarpPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpaceWarpPropertiesFB
  XrSystemSpaceWarpPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemSpaceWarpPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpaceWarpPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpaceWarpPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpaceWarpPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpaceWarpPropertiesFB*>(this);
  }
  uint32_t recommendedMotionVectorImageRectWidth;
  uint32_t recommendedMotionVectorImageRectHeight;
};
static_assert(sizeof(XrSystemSpaceWarpPropertiesFB) == sizeof(SystemSpaceWarpPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpaceWarpPropertiesFB pointer to const from a
 * SystemSpaceWarpPropertiesFB reference to const.
 * @relates SystemSpaceWarpPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpaceWarpPropertiesFB const* get(
    SystemSpaceWarpPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemSpaceWarpPropertiesFB
 * as the address of a raw XrSystemSpaceWarpPropertiesFB
 * @relates SystemSpaceWarpPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpaceWarpPropertiesFB* put(SystemSpaceWarpPropertiesFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_space_warp

#ifdef XR_ALMALENCE_digital_lens_control
/*!
 * C++ projection of XrDigitalLensControlALMALENCE
 *
 * Provided by the `XR_ALMALENCE_digital_lens_control` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDigitalLensControlALMALENCE>
 * @xrentity{XrDigitalLensControlALMALENCE}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DigitalLensControlALMALENCE : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DigitalLensControlALMALENCE(const DigitalLensControlFlagsALMALENCE& flags_,
                              const void* next_ = nullptr)
      : Parent(StructureType::DigitalLensControlALMALENCE, next_), flags{flags_} {}

  //! Default/empty constructor
  DigitalLensControlALMALENCE(const void* next_ = nullptr)

      : Parent(StructureType::DigitalLensControlALMALENCE, next_), flags{} {}

  //! Default copy constructor
  DigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& rhs) = default;
  //! Default copy assignment
  DigitalLensControlALMALENCE& operator=(const DigitalLensControlALMALENCE& rhs) = default;
  //! Copy construct from raw
  DigitalLensControlALMALENCE(const XrDigitalLensControlALMALENCE& rhs)
      : DigitalLensControlALMALENCE() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DigitalLensControlALMALENCE& operator=(const XrDigitalLensControlALMALENCE& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDigitalLensControlALMALENCE&() const {
    return *reinterpret_cast<const XrDigitalLensControlALMALENCE*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDigitalLensControlALMALENCE&() {
    return *reinterpret_cast<XrDigitalLensControlALMALENCE*>(this);
  }

  //! Accessor for this as the address of a raw XrDigitalLensControlALMALENCE
  XrDigitalLensControlALMALENCE const* get() const noexcept {
    return reinterpret_cast<XrDigitalLensControlALMALENCE const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDigitalLensControlALMALENCE.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDigitalLensControlALMALENCE* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DigitalLensControlALMALENCE{};
      next = oldNext;
    }
    return reinterpret_cast<XrDigitalLensControlALMALENCE*>(this);
  }
  DigitalLensControlFlagsALMALENCE flags;
};
static_assert(sizeof(XrDigitalLensControlALMALENCE) == sizeof(DigitalLensControlALMALENCE),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDigitalLensControlALMALENCE pointer to const from a
 * DigitalLensControlALMALENCE reference to const.
 * @relates DigitalLensControlALMALENCE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDigitalLensControlALMALENCE const* get(
    DigitalLensControlALMALENCE const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DigitalLensControlALMALENCE
 * as the address of a raw XrDigitalLensControlALMALENCE
 * @relates DigitalLensControlALMALENCE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDigitalLensControlALMALENCE* put(DigitalLensControlALMALENCE& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ALMALENCE_digital_lens_control

#ifdef XR_FB_passthrough_keyboard_hands
/*!
 * C++ projection of XrPassthroughKeyboardHandsIntensityFB
 *
 * Provided by the `XR_FB_passthrough_keyboard_hands` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughKeyboardHandsIntensityFB>
 * @xrentity{XrPassthroughKeyboardHandsIntensityFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughKeyboardHandsIntensityFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughKeyboardHandsIntensityFB(float leftHandIntensity_, float rightHandIntensity_,
                                      const void* next_ = nullptr)
      : Parent(StructureType::PassthroughKeyboardHandsIntensityFB, next_),
        leftHandIntensity{leftHandIntensity_},
        rightHandIntensity{rightHandIntensity_} {}

  //! Default/empty constructor
  PassthroughKeyboardHandsIntensityFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughKeyboardHandsIntensityFB, next_),
        leftHandIntensity{0.0f},
        rightHandIntensity{0.0f} {}

  //! Default copy constructor
  PassthroughKeyboardHandsIntensityFB(const PassthroughKeyboardHandsIntensityFB& rhs) = default;
  //! Default copy assignment
  PassthroughKeyboardHandsIntensityFB& operator=(const PassthroughKeyboardHandsIntensityFB& rhs) =
      default;
  //! Copy construct from raw
  PassthroughKeyboardHandsIntensityFB(const XrPassthroughKeyboardHandsIntensityFB& rhs)
      : PassthroughKeyboardHandsIntensityFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughKeyboardHandsIntensityFB& operator=(const XrPassthroughKeyboardHandsIntensityFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughKeyboardHandsIntensityFB&() const {
    return *reinterpret_cast<const XrPassthroughKeyboardHandsIntensityFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughKeyboardHandsIntensityFB&() {
    return *reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughKeyboardHandsIntensityFB
  XrPassthroughKeyboardHandsIntensityFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughKeyboardHandsIntensityFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughKeyboardHandsIntensityFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughKeyboardHandsIntensityFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB*>(this);
  }
  float leftHandIntensity;
  float rightHandIntensity;
};
static_assert(sizeof(XrPassthroughKeyboardHandsIntensityFB) ==
                  sizeof(PassthroughKeyboardHandsIntensityFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughKeyboardHandsIntensityFB pointer to const
 * from a PassthroughKeyboardHandsIntensityFB reference to const.
 * @relates PassthroughKeyboardHandsIntensityFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughKeyboardHandsIntensityFB const* get(
    PassthroughKeyboardHandsIntensityFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughKeyboardHandsIntensityFB as the address of a raw XrPassthroughKeyboardHandsIntensityFB
 * @relates PassthroughKeyboardHandsIntensityFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughKeyboardHandsIntensityFB* put(
    PassthroughKeyboardHandsIntensityFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough_keyboard_hands

#ifdef XR_EXT_uuid
/*!
 * C++ projection of XrUuidEXT
 *
 * Provided by the `XR_EXT_uuid` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUuidEXT>
 * @xrentity{XrUuidEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS UuidEXT {
public:
  //! Constructor initializing all members.
  UuidEXT(uint8_t data_[XR_UUID_SIZE_EXT]) { memcpy(data, data_, sizeof(data)); }

  //! Default/empty constructor
  UuidEXT()

      : data{0} {}

  //! Default copy constructor
  UuidEXT(const UuidEXT& rhs) = default;
  //! Default copy assignment
  UuidEXT& operator=(const UuidEXT& rhs) = default;
  //! Copy construct from raw
  UuidEXT(const XrUuidEXT& rhs) : UuidEXT() { *put() = rhs; }
  //! Copy assign from raw
  UuidEXT& operator=(const XrUuidEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrUuidEXT&() const { return *reinterpret_cast<const XrUuidEXT*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrUuidEXT&() { return *reinterpret_cast<XrUuidEXT*>(this); }

  //! Accessor for this as the address of a raw XrUuidEXT
  XrUuidEXT const* get() const noexcept { return reinterpret_cast<XrUuidEXT const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrUuidEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrUuidEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = UuidEXT{};
    }
    return reinterpret_cast<XrUuidEXT*>(this);
  }
  uint8_t data[XR_UUID_SIZE_EXT];
};
static_assert(sizeof(XrUuidEXT) == sizeof(UuidEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrUuidEXT pointer to const from a UuidEXT reference to
 * const.
 * @relates UuidEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuidEXT const* get(UuidEXT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing UuidEXT as the address of a
 * raw XrUuidEXT
 * @relates UuidEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuidEXT* put(UuidEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_uuid
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_STRUCTS_HPP_
