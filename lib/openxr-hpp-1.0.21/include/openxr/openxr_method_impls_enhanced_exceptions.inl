// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_METHOD_IMPLS_ENHANCED_EXCEPTIONS_INL_
#define OPENXR_METHOD_IMPLS_ENHANCED_EXCEPTIONS_INL_
/*!
 * @file
 * @brief Inline implementations - include @ref openxr_method_impls.hpp instead!
 *
 * Contains inline implementations of "enhanced mode" method wrappers whose signature is only
 * available when exceptions are permitted.
 */

#ifdef OPENXR_HPP_DOXYGEN

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#include "openxr_handles.hpp"
#endif

#ifndef OPENXR_HANDLES_HPP_
#error "This is not meant to be included on its own."
#endif

#if !defined(OPENXR_HPP_DISABLE_ENHANCED_MODE) && !defined(OPENXR_HPP_NO_EXCEPTIONS)

namespace OPENXR_HPP_NAMESPACE {

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                                                     Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetInstanceProcAddr(this->get(), name, function));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::getInstanceProcAddr");
  }

  return;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Dispatch&& d) {
  std::vector<ApiLayerProperties, Allocator> properties;
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return properties;
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateApiLayerProperties(
        propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrApiLayerProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return properties;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d) {
  std::vector<ApiLayerProperties, Allocator> properties{vectorAllocator};
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return properties;
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateApiLayerProperties(
        propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrApiLayerProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return properties;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ExtensionProperties, Allocator>
enumerateInstanceExtensionPropertiesToVector(const char* layerName, Dispatch&& d) {
  std::vector<ExtensionProperties, Allocator> properties;
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
      layerName, propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return properties;
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
        layerName, propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrExtensionProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return properties;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ExtensionProperties, Allocator>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Allocator const& vectorAllocator, Dispatch&& d) {
  std::vector<ExtensionProperties, Allocator> properties{vectorAllocator};
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
      layerName, propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return properties;
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
        layerName, propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrExtensionProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return properties;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Instance createInstance(const InstanceCreateInfo& createInfo, Dispatch&& d) {
  Instance handle;
  Result result = static_cast<Result>(d.xrCreateInstance(createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::createInstance");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d) {
  Instance handle;
  Result result = static_cast<Result>(d.xrCreateInstance(createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::createInstanceUnique");
  }

  return UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyInstance(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::destroy");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE InstanceProperties Instance::getInstanceProperties(Dispatch&& d) const {
  InstanceProperties returnVal;
  Result result = static_cast<Result>(
      d.xrGetInstanceProperties(this->get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getInstanceProperties");
  }

  return returnVal;
}

#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::resultToString(Result value,
                                                char buffer[XR_MAX_RESULT_STRING_SIZE],
                                                Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrResultToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::resultToString");
  }

  return;
}

#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::structureTypeToString(StructureType value,
                                                       char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                                                       Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrStructureTypeToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::structureTypeToString");
  }

  return;
}

#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SystemId Instance::getSystem(const SystemGetInfo& getInfo, Dispatch&& d) const {
  SystemId returnVal;
  Result result = static_cast<Result>(
      d.xrGetSystem(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getSystem");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SystemProperties Instance::getSystemProperties(SystemId systemId,
                                                                 Dispatch&& d) const {
  SystemProperties returnVal;
  Result result = static_cast<Result>(
      d.xrGetSystemProperties(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::getSystemProperties");
  }

  return returnVal;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<EnvironmentBlendMode, Allocator>
Instance::enumerateEnvironmentBlendModesToVector(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Dispatch&& d) const {
  std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes;
  uint32_t environmentBlendModeCountOutput = 0;
  uint32_t environmentBlendModeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return environmentBlendModes;
  }
  do {
    environmentBlendModes.resize(environmentBlendModeCountOutput);
    environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
    result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        environmentBlendModeCapacityInput, &environmentBlendModeCountOutput,
        reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
    environmentBlendModes.resize(environmentBlendModeCountOutput);
  } else
    environmentBlendModes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return environmentBlendModes;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<EnvironmentBlendMode, Allocator>
Instance::enumerateEnvironmentBlendModesToVector(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Allocator const& vectorAllocator,
                                                 Dispatch&& d) const {
  std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes{vectorAllocator};
  uint32_t environmentBlendModeCountOutput = 0;
  uint32_t environmentBlendModeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return environmentBlendModes;
  }
  do {
    environmentBlendModes.resize(environmentBlendModeCountOutput);
    environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
    result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        environmentBlendModeCapacityInput, &environmentBlendModeCountOutput,
        reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
    environmentBlendModes.resize(environmentBlendModeCountOutput);
  } else
    environmentBlendModes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return environmentBlendModes;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Session Instance::createSession(const SessionCreateInfo& createInfo,
                                                  Dispatch&& d) const {
  Session handle;
  Result result =
      static_cast<Result>(d.xrCreateSession(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::createSession");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>
Instance::createSessionUnique(const SessionCreateInfo& createInfo, Dispatch&& d) const {
  Session handle;
  Result result =
      static_cast<Result>(d.xrCreateSession(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::createSessionUnique");
  }

  return UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySession(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::destroy");
  }

  return;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReferenceSpaceType, Allocator>
Session::enumerateReferenceSpacesToVector(Dispatch&& d) const {
  std::vector<ReferenceSpaceType, Allocator> spaces;
  uint32_t spaceCountOutput = 0;
  uint32_t spaceCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return spaces;
  }
  do {
    spaces.resize(spaceCountOutput);
    spaceCapacityInput = static_cast<uint32_t>(spaces.size());
    result = static_cast<Result>(
        d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput,
                                     reinterpret_cast<XrReferenceSpaceType*>(spaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
    spaces.resize(spaceCountOutput);
  } else
    spaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return spaces;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReferenceSpaceType, Allocator>
Session::enumerateReferenceSpacesToVector(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<ReferenceSpaceType, Allocator> spaces{vectorAllocator};
  uint32_t spaceCountOutput = 0;
  uint32_t spaceCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return spaces;
  }
  do {
    spaces.resize(spaceCountOutput);
    spaceCapacityInput = static_cast<uint32_t>(spaces.size());
    result = static_cast<Result>(
        d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput,
                                     reinterpret_cast<XrReferenceSpaceType*>(spaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
    spaces.resize(spaceCountOutput);
  } else
    spaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return spaces;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                                                      Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::createReferenceSpace");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>
Session::createReferenceSpaceUnique(const ReferenceSpaceCreateInfo& createInfo,
                                    Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createReferenceSpaceUnique");
  }

  return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createActionSpace(const ActionSpaceCreateInfo& createInfo,
                                                   Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::createActionSpace");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>
Session::createActionSpaceUnique(const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createActionSpaceUnique");
  }

  return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceLocation Space::locateSpace(Space baseSpace, Time time, Dispatch&& d) const {
  SpaceLocation returnVal;
  Result result = static_cast<Result>(d.xrLocateSpace(this->get(), baseSpace.get(), time.get(),
                                                      OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::locateSpace");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Space::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySpace(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::destroy");
  }

  return;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationType, Allocator>
Instance::enumerateViewConfigurationsToVector(SystemId systemId, Dispatch&& d) const {
  std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes;
  uint32_t viewConfigurationTypeCountOutput = 0;
  uint32_t viewConfigurationTypeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurations(
      this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
      &viewConfigurationTypeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return viewConfigurationTypes;
  }
  do {
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurations(
        this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
        &viewConfigurationTypeCountOutput,
        reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
  } else
    viewConfigurationTypes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return viewConfigurationTypes;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationType, Allocator>
Instance::enumerateViewConfigurationsToVector(SystemId systemId, Allocator const& vectorAllocator,
                                              Dispatch&& d) const {
  std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes{vectorAllocator};
  uint32_t viewConfigurationTypeCountOutput = 0;
  uint32_t viewConfigurationTypeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurations(
      this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
      &viewConfigurationTypeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return viewConfigurationTypes;
  }
  do {
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurations(
        this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
        &viewConfigurationTypeCountOutput,
        reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
  } else
    viewConfigurationTypes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return viewConfigurationTypes;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ViewConfigurationProperties Instance::getViewConfigurationProperties(
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
  ViewConfigurationProperties returnVal;
  Result result = static_cast<Result>(d.xrGetViewConfigurationProperties(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getViewConfigurationProperties");
  }

  return returnVal;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationView, Allocator>
Instance::enumerateViewConfigurationViewsToVector(SystemId systemId,
                                                  ViewConfigurationType viewConfigurationType,
                                                  Dispatch&& d) const {
  std::vector<ViewConfigurationView, Allocator> views;
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return views;
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        viewCapacityInput, &viewCountOutput,
        reinterpret_cast<XrViewConfigurationView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return views;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationView, Allocator>
Instance::enumerateViewConfigurationViewsToVector(SystemId systemId,
                                                  ViewConfigurationType viewConfigurationType,
                                                  Allocator const& vectorAllocator,
                                                  Dispatch&& d) const {
  std::vector<ViewConfigurationView, Allocator> views{vectorAllocator};
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return views;
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        viewCapacityInput, &viewCountOutput,
        reinterpret_cast<XrViewConfigurationView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return views;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<int64_t, Allocator> Session::enumerateSwapchainFormatsToVector(
    Dispatch&& d) const {
  std::vector<int64_t, Allocator> formats;
  uint32_t formatCountOutput = 0;
  uint32_t formatCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return formats;
  }
  do {
    formats.resize(formatCountOutput);
    formatCapacityInput = static_cast<uint32_t>(formats.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput,
                                      reinterpret_cast<int64_t*>(formats.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
    formats.resize(formatCountOutput);
  } else
    formats.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return formats;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<int64_t, Allocator> Session::enumerateSwapchainFormatsToVector(
    Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<int64_t, Allocator> formats{vectorAllocator};
  uint32_t formatCountOutput = 0;
  uint32_t formatCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return formats;
  }
  do {
    formats.resize(formatCountOutput);
    formatCapacityInput = static_cast<uint32_t>(formats.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput,
                                      reinterpret_cast<int64_t*>(formats.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
    formats.resize(formatCountOutput);
  } else
    formats.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return formats;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Swapchain Session::createSwapchain(const SwapchainCreateInfo& createInfo,
                                                     Dispatch&& d) const {
  Swapchain handle;
  Result result =
      static_cast<Result>(d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchain");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>
Session::createSwapchainUnique(const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
  Swapchain handle;
  Result result =
      static_cast<Result>(d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchainUnique");
  }

  return UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Swapchain::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySwapchain(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::destroy");
  }

  return;
}

template <typename ResultItemType, typename Allocator, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ResultItemType, Allocator>
Swapchain::enumerateSwapchainImagesToVector(Dispatch&& d) const {
  std::vector<ResultItemType, Allocator> images;
  uint32_t imageCountOutput = 0;
  uint32_t imageCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return images;
  }
  do {
    images.resize(imageCountOutput);
    imageCapacityInput = static_cast<uint32_t>(images.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput,
                                     reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
    images.resize(imageCountOutput);
  } else
    images.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return images;
}

template <typename ResultItemType, typename Allocator, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ResultItemType, Allocator>
Swapchain::enumerateSwapchainImagesToVector(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<ResultItemType, Allocator> images{vectorAllocator};
  uint32_t imageCountOutput = 0;
  uint32_t imageCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return images;
  }
  do {
    images.resize(imageCountOutput);
    imageCapacityInput = static_cast<uint32_t>(images.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput,
                                     reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
    images.resize(imageCountOutput);
  } else
    images.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return images;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE uint32_t
Swapchain::acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo, Dispatch&& d) const {
  uint32_t returnVal;
  Result result =
      static_cast<Result>(d.xrAcquireSwapchainImage(this->get(), acquireInfo.get(), &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::acquireSwapchainImage");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Swapchain::releaseSwapchainImage(
    const SwapchainImageReleaseInfo& releaseInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrReleaseSwapchainImage(this->get(), releaseInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::releaseSwapchainImage");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::beginSession(const SessionBeginInfo& beginInfo,
                                             Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrBeginSession(this->get(), beginInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::beginSession");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::endSession(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrEndSession(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::endSession");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::requestExitSession(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrRequestExitSession(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::requestExitSession");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FrameState Session::waitFrame(const FrameWaitInfo& frameWaitInfo,
                                                Dispatch&& d) const {
  FrameState returnVal;
  Result result = static_cast<Result>(
      d.xrWaitFrame(this->get(), frameWaitInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::waitFrame");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::endFrame(const FrameEndInfo& frameEndInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrEndFrame(this->get(), frameEndInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::endFrame");
  }

  return;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<View, Allocator> Session::locateViewsToVector(
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Dispatch&& d) const {
  std::vector<View, Allocator> views;
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrLocateViews(
      this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return views;
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState,
                                                 viewCapacityInput, &viewCountOutput,
                                                 reinterpret_cast<XrView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return views;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<View, Allocator> Session::locateViewsToVector(
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Allocator const& vectorAllocator,
    Dispatch&& d) const {
  std::vector<View, Allocator> views{vectorAllocator};
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrLocateViews(
      this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return views;
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState,
                                                 viewCapacityInput, &viewCountOutput,
                                                 reinterpret_cast<XrView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return views;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Path Instance::stringToPath(const char* pathString, Dispatch&& d) const {
  Path returnVal;
  Result result = static_cast<Result>(
      d.xrStringToPath(this->get(), pathString, OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::stringToPath");
  }

  return returnVal;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::pathToString(Path path,
                                                                          Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(
      d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrPathToString(this->get(), path.get(), bufferCapacityInput,
                                                  &bufferCountOutput,
                                                  reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::pathToString(
    Path path, Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(
      d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrPathToString(this->get(), path.get(), bufferCapacityInput,
                                                  &bufferCountOutput,
                                                  reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionSet Instance::createActionSet(const ActionSetCreateInfo& createInfo,
                                                      Dispatch&& d) const {
  ActionSet handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Instance::createActionSet");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>
Instance::createActionSetUnique(const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
  ActionSet handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createActionSetUnique");
  }

  return UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void ActionSet::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyActionSet(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::ActionSet::destroy");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Action ActionSet::createAction(const ActionCreateInfo& createInfo,
                                                 Dispatch&& d) const {
  Action handle;
  Result result =
      static_cast<Result>(d.xrCreateAction(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::ActionSet::createAction");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>
ActionSet::createActionUnique(const ActionCreateInfo& createInfo, Dispatch&& d) const {
  Action handle;
  Result result =
      static_cast<Result>(d.xrCreateAction(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::ActionSet::createActionUnique");
  }

  return UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Action::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyAction(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Action::destroy");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::suggestInteractionProfileBindings(
    const InteractionProfileSuggestedBinding& suggestedBindings, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrSuggestInteractionProfileBindings(this->get(), suggestedBindings.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::suggestInteractionProfileBindings");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::attachSessionActionSets(
    const SessionActionSetsAttachInfo& attachInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrAttachSessionActionSets(this->get(), attachInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::attachSessionActionSets");
  }

  return;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE InteractionProfileState
Session::getCurrentInteractionProfile(Path topLevelUserPath, Dispatch&& d) const {
  InteractionProfileState returnVal;
  Result result = static_cast<Result>(d.xrGetCurrentInteractionProfile(
      this->get(), topLevelUserPath.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::getCurrentInteractionProfile");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStateBoolean
Session::getActionStateBoolean(const ActionStateGetInfo& getInfo, Dispatch&& d) const {
  ActionStateBoolean returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStateBoolean(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStateBoolean");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStateFloat Session::getActionStateFloat(const ActionStateGetInfo& getInfo,
                                                                Dispatch&& d) const {
  ActionStateFloat returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStateFloat(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStateFloat");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStateVector2f
Session::getActionStateVector2f(const ActionStateGetInfo& getInfo, Dispatch&& d) const {
  ActionStateVector2f returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStateVector2f(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStateVector2f");
  }

  return returnVal;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStatePose Session::getActionStatePose(const ActionStateGetInfo& getInfo,
                                                              Dispatch&& d) const {
  ActionStatePose returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStatePose(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStatePose");
  }

  return returnVal;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<Path, Allocator> Session::enumerateBoundSourcesForActionToVector(
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Dispatch&& d) const {
  std::vector<Path, Allocator> sources;
  uint32_t sourceCountOutput = 0;
  uint32_t sourceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
      this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return sources;
  }
  do {
    sources.resize(sourceCountOutput);
    sourceCapacityInput = static_cast<uint32_t>(sources.size());
    result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
        this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput,
        reinterpret_cast<XrPath*>(sources.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
    sources.resize(sourceCountOutput);
  } else
    sources.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return sources;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<Path, Allocator> Session::enumerateBoundSourcesForActionToVector(
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
    Dispatch&& d) const {
  std::vector<Path, Allocator> sources{vectorAllocator};
  uint32_t sourceCountOutput = 0;
  uint32_t sourceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
      this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return sources;
  }
  do {
    sources.resize(sourceCountOutput);
    sourceCapacityInput = static_cast<uint32_t>(sources.size());
    result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
        this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput,
        reinterpret_cast<XrPath*>(sources.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
    sources.resize(sourceCountOutput);
  } else
    sources.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return sources;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Session::getInputSourceLocalizedName(
    const InputSourceLocalizedNameGetInfo& getInfo, Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
      this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
        this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Session::getInputSourceLocalizedName(
    const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
    Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
      this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
        this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType,
                                                               uint32_t threadId,
                                                               Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetAndroidApplicationThreadKHR(
      this->get(), OPENXR_HPP_NAMESPACE::get(threadType), threadId));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setAndroidApplicationThreadKHR");
  }

  return;
}

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings
#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Swapchain Session::createSwapchainAndroidSurfaceKHR(
    const SwapchainCreateInfo& info, jobject* surface, Dispatch&& d) const {
  Swapchain handle;
  Result result = static_cast<Result>(
      d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchainAndroidSurfaceKHR");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>
Session::createSwapchainAndroidSurfaceUniqueKHR(const SwapchainCreateInfo& info, jobject* surface,
                                                Dispatch&& d) const {
  Swapchain handle;
  Result result = static_cast<Result>(
      d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchainAndroidSurfaceUniqueKHR");
  }

  return UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain
#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsOpenGLKHR
Instance::getOpenGLGraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsOpenGLKHR returnVal;
  Result result = static_cast<Result>(d.xrGetOpenGLGraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getOpenGLGraphicsRequirementsKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsOpenGLESKHR
Instance::getOpenGLESGraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsOpenGLESKHR returnVal;
  Result result = static_cast<Result>(d.xrGetOpenGLESGraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getOpenGLESGraphicsRequirementsKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanInstanceExtensionsKHR(
    SystemId systemId, Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanInstanceExtensionsKHR(
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanDeviceExtensionsKHR(
    SystemId systemId, Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanDeviceExtensionsKHR(
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return str;
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return str;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VkPhysicalDevice Instance::getVulkanGraphicsDeviceKHR(SystemId systemId,
                                                                        VkInstance vkInstance,
                                                                        Dispatch&& d) const {
  VkPhysicalDevice returnVal;
  Result result = static_cast<Result>(
      d.xrGetVulkanGraphicsDeviceKHR(this->get(), systemId.get(), vkInstance, &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsDeviceKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsVulkanKHR
Instance::getVulkanGraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsVulkanKHR returnVal;
  Result result = static_cast<Result>(d.xrGetVulkanGraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsRequirementsKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsD3D11KHR
Instance::getD3D11GraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsD3D11KHR returnVal;
  Result result = static_cast<Result>(d.xrGetD3D11GraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getD3D11GraphicsRequirementsKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsD3D12KHR
Instance::getD3D12GraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsD3D12KHR returnVal;
  Result result = static_cast<Result>(d.xrGetD3D12GraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getD3D12GraphicsRequirementsKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_visibility_mask

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VisibilityMaskKHR
Session::getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
                              VisibilityMaskTypeKHR visibilityMaskType, Dispatch&& d) const {
  VisibilityMaskKHR returnVal;
  Result result = static_cast<Result>(d.xrGetVisibilityMaskKHR(
      this->get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewIndex,
      OPENXR_HPP_NAMESPACE::get(visibilityMaskType), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::getVisibilityMaskKHR");
  }

  return returnVal;
}

#endif  // XR_KHR_visibility_mask
#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Time Instance::convertWin32PerformanceCounterToTimeKHR(
    const LARGE_INTEGER* performanceCounter, Dispatch&& d) const {
  Time returnVal;
  Result result = static_cast<Result>(d.xrConvertWin32PerformanceCounterToTimeKHR(
      this->get(), performanceCounter, OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertWin32PerformanceCounterToTimeKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time
#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE LARGE_INTEGER
Instance::convertTimeToWin32PerformanceCounterKHR(Time time, Dispatch&& d) const {
  LARGE_INTEGER returnVal;
  Result result = static_cast<Result>(
      d.xrConvertTimeToWin32PerformanceCounterKHR(this->get(), time.get(), &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertTimeToWin32PerformanceCounterKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time
#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Time Instance::convertTimespecTimeToTimeKHR(const struct timespec* timespecTime,
                                                              Dispatch&& d) const {
  Time returnVal;
  Result result = static_cast<Result>(d.xrConvertTimespecTimeToTimeKHR(
      this->get(), timespecTime, OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertTimespecTimeToTimeKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time
#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE timespec Instance::convertTimeToTimespecTimeKHR(Time time, Dispatch&& d) const {
  timespec returnVal;
  Result result =
      static_cast<Result>(d.xrConvertTimeToTimespecTimeKHR(this->get(), time.get(), &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertTimeToTimespecTimeKHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time
#ifdef XR_KHR_loader_init

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                                           Dispatch&& d) {
  Result result = static_cast<Result>(d.xrInitializeLoaderKHR(loaderInitInfo));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::initializeLoaderKHR");
  }

  return;
}

#endif  // XR_KHR_loader_init
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::createVulkanInstanceKHR(
    const VulkanInstanceCreateInfoKHR& createInfo, VkInstance* vulkanInstance,
    VkResult* vulkanResult, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrCreateVulkanInstanceKHR(this->get(), createInfo.get(), vulkanInstance, vulkanResult));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createVulkanInstanceKHR");
  }

  return;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo,
                                                       VkDevice* vulkanDevice,
                                                       VkResult* vulkanResult, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrCreateVulkanDeviceKHR(this->get(), createInfo.get(), vulkanDevice, vulkanResult));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createVulkanDeviceKHR");
  }

  return;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VkPhysicalDevice Instance::getVulkanGraphicsDevice2KHR(
    const VulkanGraphicsDeviceGetInfoKHR& getInfo, Dispatch&& d) const {
  VkPhysicalDevice returnVal;
  Result result =
      static_cast<Result>(d.xrGetVulkanGraphicsDevice2KHR(this->get(), getInfo.get(), &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsDevice2KHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsVulkanKHR
Instance::getVulkanGraphicsRequirements2KHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsVulkanKHR returnVal;
  Result result = static_cast<Result>(d.xrGetVulkanGraphicsRequirements2KHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsRequirements2KHR");
  }

  return returnVal;
}

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_EXT_performance_settings

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                                                   PerfSettingsLevelEXT level,
                                                                   Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPerfSettingsSetPerformanceLevelEXT(
      this->get(), OPENXR_HPP_NAMESPACE::get(domain), OPENXR_HPP_NAMESPACE::get(level)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::perfSettingsSetPerformanceLevelEXT");
  }

  return;
}

#endif  // XR_EXT_performance_settings
#ifdef XR_EXT_thermal_query

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::thermalGetTemperatureTrendEXT(
    PerfSettingsDomainEXT domain, PerfSettingsNotificationLevelEXT& notificationLevel,
    float* tempHeadroom, float* tempSlope, Dispatch&& d) const {
  XrPerfSettingsNotificationLevelEXT notificationLevel_tmp;
  Result result = static_cast<Result>(
      d.xrThermalGetTemperatureTrendEXT(this->get(), OPENXR_HPP_NAMESPACE::get(domain),
                                        notificationLevel_tmp, tempHeadroom, tempSlope));
  notificationLevel = static_cast<PerfSettingsNotificationLevelEXT>(notificationLevel_tmp);
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::thermalGetTemperatureTrendEXT");
  }

  return;
}

#endif  // XR_EXT_thermal_query
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::setDebugUtilsObjectNameEXT(
    const DebugUtilsObjectNameInfoEXT& nameInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetDebugUtilsObjectNameEXT(this->get(), nameInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::setDebugUtilsObjectNameEXT");
  }

  return;
}

#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE DebugUtilsMessengerEXT Instance::createDebugUtilsMessengerEXT(
    const DebugUtilsMessengerCreateInfoEXT& createInfo, Dispatch&& d) const {
  DebugUtilsMessengerEXT handle;
  Result result = static_cast<Result>(
      d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createDebugUtilsMessengerEXT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>
Instance::createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                             Dispatch&& d) const {
  DebugUtilsMessengerEXT handle;
  Result result = static_cast<Result>(
      d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createDebugUtilsMessengerUniqueEXT");
  }

  return UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void DebugUtilsMessengerEXT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyDebugUtilsMessengerEXT(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::DebugUtilsMessengerEXT::destroy");
  }

  return;
}

#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::submitDebugUtilsMessageEXT(
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
    const DebugUtilsMessengerCallbackDataEXT& callbackData, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSubmitDebugUtilsMessageEXT(
      this->get(), messageSeverity, messageTypes, callbackData.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::submitDebugUtilsMessageEXT");
  }

  return;
}

#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::sessionBeginDebugUtilsLabelRegionEXT(
    const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSessionBeginDebugUtilsLabelRegionEXT(this->get(), labelInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::sessionBeginDebugUtilsLabelRegionEXT");
  }

  return;
}

#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSessionEndDebugUtilsLabelRegionEXT(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::sessionEndDebugUtilsLabelRegionEXT");
  }

  return;
}

#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                                                Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSessionInsertDebugUtilsLabelEXT(this->get(), labelInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::sessionInsertDebugUtilsLabelEXT");
  }

  return;
}

#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpatialAnchorMSFT Session::createSpatialAnchorMSFT(
    const SpatialAnchorCreateInfoMSFT& createInfo, Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
Session::createSpatialAnchorUniqueMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                       Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorUniqueMSFT");
  }

  return UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createSpatialAnchorSpaceMSFT(
    const SpatialAnchorSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
  Space handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorSpaceMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>
Session::createSpatialAnchorSpaceUniqueMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                            Dispatch&& d) const {
  Space handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorSpaceUniqueMSFT");
  }

  return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpatialAnchorMSFT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySpatialAnchorMSFT(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::SpatialAnchorMSFT::destroy");
  }

  return;
}

#endif  // XR_MSFT_spatial_anchor
#ifdef XR_EXT_conformance_automation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath,
                                                        XrBool32 isActive, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceActiveEXT(
      this->get(), interactionProfile.get(), topLevelPath.get(), isActive));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceActiveEXT");
  }

  return;
}

#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath,
                                                           XrBool32 state, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceStateBoolEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), state));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceStateBoolEXT");
  }

  return;
}

#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath,
                                                            float state, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceStateFloatEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), state));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceStateFloatEXT");
  }

  return;
}

#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceStateVector2fEXT(Path topLevelPath,
                                                               Path inputSourcePath,
                                                               XrVector2f state,
                                                               Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceStateVector2fEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), state));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceStateVector2fEXT");
  }

  return;
}

#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath,
                                                          Space space, XrPosef pose,
                                                          Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceLocationEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), space.get(), pose));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceLocationEXT");
  }

  return;
}

#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_hand_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandTrackerEXT
Session::createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo, Dispatch&& d) const {
  HandTrackerEXT handle;
  Result result =
      static_cast<Result>(d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::createHandTrackerEXT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>
Session::createHandTrackerUniqueEXT(const HandTrackerCreateInfoEXT& createInfo,
                                    Dispatch&& d) const {
  HandTrackerEXT handle;
  Result result =
      static_cast<Result>(d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createHandTrackerUniqueEXT");
  }

  return UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void HandTrackerEXT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyHandTrackerEXT(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::destroy");
  }

  return;
}

#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandJointLocationsEXT
HandTrackerEXT::locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo, Dispatch&& d) const {
  HandJointLocationsEXT returnVal;
  Result result = static_cast<Result>(
      d.xrLocateHandJointsEXT(this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::locateHandJointsEXT");
  }

  return returnVal;
}

#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_hand_tracking_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space HandTrackerEXT::createHandMeshSpaceMSFT(
    const HandMeshSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::createHandMeshSpaceMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>
HandTrackerEXT::createHandMeshSpaceUniqueMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                              Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::createHandMeshSpaceUniqueMSFT");
  }

  return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandMeshMSFT
HandTrackerEXT::updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo, Dispatch&& d) const {
  HandMeshMSFT returnVal;
  Result result = static_cast<Result>(
      d.xrUpdateHandMeshMSFT(this->get(), updateInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::updateHandMeshMSFT");
  }

  return returnVal;
}

#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpatialAnchorMSFT Session::createSpatialAnchorFromPerceptionAnchorMSFT(
    IUnknown* perceptionAnchor, Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING
                                     "::Session::createSpatialAnchorFromPerceptionAnchorMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
Session::createSpatialAnchorFromPerceptionAnchorUniqueMSFT(IUnknown* perceptionAnchor,
                                                           Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result,
        OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorFromPerceptionAnchorUniqueMSFT");
  }

  return UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop
#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::tryGetPerceptionAnchorFromSpatialAnchorMSFT(
    SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(this->get(), anchor.get(), perceptionAnchor));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING
                                     "::Session::tryGetPerceptionAnchorFromSpatialAnchorMSFT");
  }

  return;
}

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop
#ifdef XR_MSFT_composition_layer_reprojection

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReprojectionModeMSFT, Allocator>
Instance::enumerateReprojectionModesToVectorMSFT(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Dispatch&& d) const {
  std::vector<ReprojectionModeMSFT, Allocator> modes;
  uint32_t modeCountOutput = 0;
  uint32_t modeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      modeCapacityInput, &modeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return modes;
  }
  do {
    modes.resize(modeCountOutput);
    modeCapacityInput = static_cast<uint32_t>(modes.size());
    result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        modeCapacityInput, &modeCountOutput,
        reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
    modes.resize(modeCountOutput);
  } else
    modes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return modes;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReprojectionModeMSFT, Allocator>
Instance::enumerateReprojectionModesToVectorMSFT(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Allocator const& vectorAllocator,
                                                 Dispatch&& d) const {
  std::vector<ReprojectionModeMSFT, Allocator> modes{vectorAllocator};
  uint32_t modeCountOutput = 0;
  uint32_t modeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      modeCapacityInput, &modeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return modes;
  }
  do {
    modes.resize(modeCountOutput);
    modeCapacityInput = static_cast<uint32_t>(modes.size());
    result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        modeCapacityInput, &modeCountOutput,
        reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
    modes.resize(modeCountOutput);
  } else
    modes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return modes;
}

#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_FB_swapchain_update_state

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Swapchain::updateSwapchainFB(const XrSwapchainStateBaseHeaderFB* state,
                                                    Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrUpdateSwapchainFB(this->get(), state));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Swapchain::updateSwapchainFB");
  }

  return;
}

#endif  // XR_FB_swapchain_update_state
#ifdef XR_MSFT_scene_understanding

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<SceneComputeFeatureMSFT, Allocator>
Instance::enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId, Dispatch&& d) const {
  std::vector<SceneComputeFeatureMSFT, Allocator> features;
  uint32_t featureCountOutput = 0;
  uint32_t featureCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
      this->get(), systemId.get(), featureCapacityInput, &featureCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || featureCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return features;
  }
  do {
    features.resize(featureCountOutput);
    featureCapacityInput = static_cast<uint32_t>(features.size());
    result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
        this->get(), systemId.get(), featureCapacityInput, &featureCountOutput,
        reinterpret_cast<XrSceneComputeFeatureMSFT*>(features.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(featureCountOutput <= features.size());
    features.resize(featureCountOutput);
  } else
    features.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return features;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<SceneComputeFeatureMSFT, Allocator>
Instance::enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId,
                                                    Allocator const& vectorAllocator,
                                                    Dispatch&& d) const {
  std::vector<SceneComputeFeatureMSFT, Allocator> features{vectorAllocator};
  uint32_t featureCountOutput = 0;
  uint32_t featureCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
      this->get(), systemId.get(), featureCapacityInput, &featureCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || featureCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return features;
  }
  do {
    features.resize(featureCountOutput);
    featureCapacityInput = static_cast<uint32_t>(features.size());
    result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
        this->get(), systemId.get(), featureCapacityInput, &featureCountOutput,
        reinterpret_cast<XrSceneComputeFeatureMSFT*>(features.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(featureCountOutput <= features.size());
    features.resize(featureCountOutput);
  } else
    features.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return features;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SceneObserverMSFT Session::createSceneObserverMSFT(
    const SceneObserverCreateInfoMSFT& createInfo, Dispatch&& d) const {
  SceneObserverMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneObserverMSFT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSceneObserverMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>>
Session::createSceneObserverUniqueMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                       Dispatch&& d) const {
  SceneObserverMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneObserverMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSceneObserverUniqueMSFT");
  }

  return UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SceneObserverMSFT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySceneObserverMSFT(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::SceneObserverMSFT::destroy");
  }

  return;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SceneMSFT
SceneObserverMSFT::createSceneMSFT(const SceneCreateInfoMSFT& createInfo, Dispatch&& d) const {
  SceneMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneMSFT(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneObserverMSFT::createSceneMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>>
SceneObserverMSFT::createSceneUniqueMSFT(const SceneCreateInfoMSFT& createInfo,
                                         Dispatch&& d) const {
  SceneMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneObserverMSFT::createSceneUniqueMSFT");
  }

  return UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SceneMSFT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySceneMSFT(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::SceneMSFT::destroy");
  }

  return;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SceneObserverMSFT::computeNewSceneMSFT(
    const NewSceneComputeInfoMSFT& computeInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrComputeNewSceneMSFT(this->get(), computeInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneObserverMSFT::computeNewSceneMSFT");
  }

  return;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SceneComponentsMSFT
SceneMSFT::getSceneComponentsMSFT(const SceneComponentsGetInfoMSFT& getInfo, Dispatch&& d) const {
  SceneComponentsMSFT returnVal;
  Result result = static_cast<Result>(
      d.xrGetSceneComponentsMSFT(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneMSFT::getSceneComponentsMSFT");
  }

  return returnVal;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SceneComponentLocationsMSFT SceneMSFT::locateSceneComponentsMSFT(
    const SceneComponentsLocateInfoMSFT& locateInfo, Dispatch&& d) const {
  SceneComponentLocationsMSFT returnVal;
  Result result = static_cast<Result>(d.xrLocateSceneComponentsMSFT(
      this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneMSFT::locateSceneComponentsMSFT");
  }

  return returnVal;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SceneMeshBuffersMSFT
SceneMSFT::getSceneMeshBuffersMSFT(const SceneMeshBuffersGetInfoMSFT& getInfo, Dispatch&& d) const {
  SceneMeshBuffersMSFT returnVal;
  Result result = static_cast<Result>(d.xrGetSceneMeshBuffersMSFT(
      this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneMSFT::getSceneMeshBuffersMSFT");
  }

  return returnVal;
}

#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding_serialization

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SceneObserverMSFT::deserializeSceneMSFT(
    const SceneDeserializeInfoMSFT& deserializeInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrDeserializeSceneMSFT(this->get(), deserializeInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneObserverMSFT::deserializeSceneMSFT");
  }

  return;
}

#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_understanding_serialization

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SceneMSFT::getSerializedSceneFragmentDataMSFT(
    const SerializedSceneFragmentDataGetInfoMSFT& getInfo, uint32_t countInput,
    uint32_t* readOutput, uint8_t* buffer, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetSerializedSceneFragmentDataMSFT(
      this->get(), getInfo.get(), countInput, readOutput, buffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SceneMSFT::getSerializedSceneFragmentDataMSFT");
  }

  return;
}

#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_FB_display_refresh_rate

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<float, Allocator> Session::enumerateDisplayRefreshRatesToVectorFB(
    Dispatch&& d) const {
  std::vector<float, Allocator> displayRefreshRates;
  uint32_t displayRefreshRateCountOutput = 0;
  uint32_t displayRefreshRateCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
      this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return displayRefreshRates;
  }
  do {
    displayRefreshRates.resize(displayRefreshRateCountOutput);
    displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
    result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
        this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput,
        reinterpret_cast<float*>(displayRefreshRates.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
    displayRefreshRates.resize(displayRefreshRateCountOutput);
  } else
    displayRefreshRates.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return displayRefreshRates;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<float, Allocator> Session::enumerateDisplayRefreshRatesToVectorFB(
    Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<float, Allocator> displayRefreshRates{vectorAllocator};
  uint32_t displayRefreshRateCountOutput = 0;
  uint32_t displayRefreshRateCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
      this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return displayRefreshRates;
  }
  do {
    displayRefreshRates.resize(displayRefreshRateCountOutput);
    displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
    result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
        this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput,
        reinterpret_cast<float*>(displayRefreshRates.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
    displayRefreshRates.resize(displayRefreshRateCountOutput);
  } else
    displayRefreshRates.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return displayRefreshRates;
}

#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_display_refresh_rate

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE float Session::getDisplayRefreshRateFB(Dispatch&& d) const {
  float returnVal;
  Result result = static_cast<Result>(d.xrGetDisplayRefreshRateFB(this->get(), &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::getDisplayRefreshRateFB");
  }

  return returnVal;
}

#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_display_refresh_rate

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::requestDisplayRefreshRateFB(float displayRefreshRate,
                                                            Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrRequestDisplayRefreshRateFB(this->get(), displayRefreshRate));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::requestDisplayRefreshRateFB");
  }

  return;
}

#endif  // XR_FB_display_refresh_rate
#ifdef XR_HTCX_vive_tracker_interaction

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViveTrackerPathsHTCX, Allocator>
Instance::enumerateViveTrackerPathsToVectorHTCX(Dispatch&& d) const {
  std::vector<ViveTrackerPathsHTCX, Allocator> paths;
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return paths;
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput,
                                          reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return paths;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViveTrackerPathsHTCX, Allocator>
Instance::enumerateViveTrackerPathsToVectorHTCX(Allocator const& vectorAllocator,
                                                Dispatch&& d) const {
  std::vector<ViveTrackerPathsHTCX, Allocator> paths{vectorAllocator};
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return paths;
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput,
                                          reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return paths;
}

#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTC_facial_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FacialTrackerHTC
Session::createFacialTrackerHTC(const FacialTrackerCreateInfoHTC& createInfo, Dispatch&& d) const {
  FacialTrackerHTC handle;
  Result result =
      static_cast<Result>(d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFacialTrackerHTC");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>
Session::createFacialTrackerUniqueHTC(const FacialTrackerCreateInfoHTC& createInfo,
                                      Dispatch&& d) const {
  FacialTrackerHTC handle;
  Result result =
      static_cast<Result>(d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFacialTrackerUniqueHTC");
  }

  return UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void FacialTrackerHTC::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyFacialTrackerHTC(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::FacialTrackerHTC::destroy");
  }

  return;
}

#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FacialExpressionsHTC
FacialTrackerHTC::getFacialExpressionsHTC(Dispatch&& d) const {
  FacialExpressionsHTC returnVal;
  Result result = static_cast<Result>(
      d.xrGetFacialExpressionsHTC(this->get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::FacialTrackerHTC::getFacialExpressionsHTC");
  }

  return returnVal;
}

#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_color_space

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ColorSpaceFB, Allocator> Session::enumerateColorSpacesToVectorFB(
    Dispatch&& d) const {
  std::vector<ColorSpaceFB, Allocator> colorSpaces;
  uint32_t colorSpaceCountOutput = 0;
  uint32_t colorSpaceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateColorSpacesFB(
      this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return colorSpaces;
  }
  do {
    colorSpaces.resize(colorSpaceCountOutput);
    colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
    result = static_cast<Result>(
        d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput,
                                   reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
    colorSpaces.resize(colorSpaceCountOutput);
  } else
    colorSpaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return colorSpaces;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ColorSpaceFB, Allocator> Session::enumerateColorSpacesToVectorFB(
    Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<ColorSpaceFB, Allocator> colorSpaces{vectorAllocator};
  uint32_t colorSpaceCountOutput = 0;
  uint32_t colorSpaceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateColorSpacesFB(
      this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return colorSpaces;
  }
  do {
    colorSpaces.resize(colorSpaceCountOutput);
    colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
    result = static_cast<Result>(
        d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput,
                                   reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
    colorSpaces.resize(colorSpaceCountOutput);
  } else
    colorSpaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return colorSpaces;
}

#endif  // XR_FB_color_space
#ifdef XR_FB_color_space

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setColorSpaceFB(ColorSpaceFB colorspace, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSetColorSpaceFB(this->get(), OPENXR_HPP_NAMESPACE::get(colorspace)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::setColorSpaceFB");
  }

  return;
}

#endif  // XR_FB_color_space
#ifdef XR_FB_hand_tracking_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandTrackingMeshFB HandTrackerEXT::getHandMeshFB(Dispatch&& d) const {
  HandTrackingMeshFB returnVal;
  Result result =
      static_cast<Result>(d.xrGetHandMeshFB(this->get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::getHandMeshFB");
  }

  return returnVal;
}

#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_foveation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FoveationProfileFB Session::createFoveationProfileFB(
    const FoveationProfileCreateInfoFB& createInfo, Dispatch&& d) const {
  FoveationProfileFB handle;
  Result result = static_cast<Result>(
      d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFoveationProfileFB");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>
Session::createFoveationProfileUniqueFB(const FoveationProfileCreateInfoFB& createInfo,
                                        Dispatch&& d) const {
  FoveationProfileFB handle;
  Result result = static_cast<Result>(
      d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFoveationProfileUniqueFB");
  }

  return UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_FB_foveation
#ifdef XR_FB_foveation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void FoveationProfileFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyFoveationProfileFB(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::FoveationProfileFB::destroy");
  }

  return;
}

#endif  // XR_FB_foveation
#ifdef XR_FB_keyboard_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE KeyboardTrackingDescriptionFB Session::querySystemTrackedKeyboardFB(
    const KeyboardTrackingQueryFB& queryInfo, Dispatch&& d) const {
  KeyboardTrackingDescriptionFB returnVal;
  Result result = static_cast<Result>(d.xrQuerySystemTrackedKeyboardFB(
      this->get(), queryInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::querySystemTrackedKeyboardFB");
  }

  return returnVal;
}

#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo,
                                                       Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createKeyboardSpaceFB");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>
Session::createKeyboardSpaceUniqueFB(const KeyboardSpaceCreateInfoFB& createInfo,
                                     Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createKeyboardSpaceUniqueFB");
  }

  return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE TriangleMeshFB
Session::createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo, Dispatch&& d) const {
  TriangleMeshFB handle;
  Result result =
      static_cast<Result>(d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::createTriangleMeshFB");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>
Session::createTriangleMeshUniqueFB(const TriangleMeshCreateInfoFB& createInfo,
                                    Dispatch&& d) const {
  TriangleMeshFB handle;
  Result result =
      static_cast<Result>(d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createTriangleMeshUniqueFB");
  }

  return UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyTriangleMeshFB(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::destroy");
  }

  return;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshGetVertexBufferFB(XrVector3f** outVertexBuffer,
                                                                     Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrTriangleMeshGetVertexBufferFB(this->get(), outVertexBuffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshGetVertexBufferFB");
  }

  return;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshGetIndexBufferFB(uint32_t** outIndexBuffer,
                                                                    Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrTriangleMeshGetIndexBufferFB(this->get(), outIndexBuffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshGetIndexBufferFB");
  }

  return;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshBeginUpdateFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrTriangleMeshBeginUpdateFB(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshBeginUpdateFB");
  }

  return;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshEndUpdateFB(uint32_t vertexCount,
                                                               uint32_t triangleCount,
                                                               Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrTriangleMeshEndUpdateFB(this->get(), vertexCount, triangleCount));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshEndUpdateFB");
  }

  return;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE uint32_t
TriangleMeshFB::triangleMeshBeginVertexBufferUpdateFB(Dispatch&& d) const {
  uint32_t returnVal;
  Result result =
      static_cast<Result>(d.xrTriangleMeshBeginVertexBufferUpdateFB(this->get(), &returnVal));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING
                                     "::TriangleMeshFB::triangleMeshBeginVertexBufferUpdateFB");
  }

  return returnVal;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshEndVertexBufferUpdateFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrTriangleMeshEndVertexBufferUpdateFB(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING
                                     "::TriangleMeshFB::triangleMeshEndVertexBufferUpdateFB");
  }

  return;
}

#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughFB
Session::createPassthroughFB(const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
  PassthroughFB handle;
  Result result =
      static_cast<Result>(d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughFB");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>
Session::createPassthroughUniqueFB(const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
  PassthroughFB handle;
  Result result =
      static_cast<Result>(d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughUniqueFB");
  }

  return UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyPassthroughFB(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::destroy");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughFB::passthroughStartFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughStartFB(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::passthroughStartFB");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughFB::passthroughPauseFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughPauseFB(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::passthroughPauseFB");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughLayerFB Session::createPassthroughLayerFB(
    const PassthroughLayerCreateInfoFB& createInfo, Dispatch&& d) const {
  PassthroughLayerFB handle;
  Result result = static_cast<Result>(
      d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughLayerFB");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>
Session::createPassthroughLayerUniqueFB(const PassthroughLayerCreateInfoFB& createInfo,
                                        Dispatch&& d) const {
  PassthroughLayerFB handle;
  Result result = static_cast<Result>(
      d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughLayerUniqueFB");
  }

  return UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyPassthroughLayerFB(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::destroy");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerPauseFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughLayerPauseFB(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerPauseFB");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerResumeFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughLayerResumeFB(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerResumeFB");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerSetStyleFB(
    const PassthroughStyleFB& style, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughLayerSetStyleFB(this->get(), style.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerSetStyleFB");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GeometryInstanceFB Session::createGeometryInstanceFB(
    const GeometryInstanceCreateInfoFB& createInfo, Dispatch&& d) const {
  GeometryInstanceFB handle;
  Result result = static_cast<Result>(
      d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createGeometryInstanceFB");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>
Session::createGeometryInstanceUniqueFB(const GeometryInstanceCreateInfoFB& createInfo,
                                        Dispatch&& d) const {
  GeometryInstanceFB handle;
  Result result = static_cast<Result>(
      d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createGeometryInstanceUniqueFB");
  }

  return UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void GeometryInstanceFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyGeometryInstanceFB(this->get()));
  val_ = XR_NULL_HANDLE;
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::GeometryInstanceFB::destroy");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void GeometryInstanceFB::geometryInstanceSetTransformFB(
    const GeometryInstanceTransformFB& transformation, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrGeometryInstanceSetTransformFB(this->get(), transformation.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::GeometryInstanceFB::geometryInstanceSetTransformFB");
  }

  return;
}

#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<RenderModelPathInfoFB, Allocator>
Session::enumerateRenderModelPathsToVectorFB(Dispatch&& d) const {
  std::vector<RenderModelPathInfoFB, Allocator> paths;
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return paths;
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput,
                                        reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return paths;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<RenderModelPathInfoFB, Allocator>
Session::enumerateRenderModelPathsToVectorFB(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<RenderModelPathInfoFB, Allocator> paths{vectorAllocator};
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return paths;
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput,
                                        reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return paths;
}

#endif  // XR_FB_render_model
#ifdef XR_VARJO_environment_depth_estimation

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setEnvironmentDepthEstimationVARJO(XrBool32 enabled,
                                                                   Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetEnvironmentDepthEstimationVARJO(this->get(), enabled));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setEnvironmentDepthEstimationVARJO");
  }

  return;
}

#endif  // XR_VARJO_environment_depth_estimation
#ifdef XR_VARJO_marker_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setMarkerTrackingVARJO(XrBool32 enabled, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetMarkerTrackingVARJO(this->get(), enabled));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setMarkerTrackingVARJO");
  }

  return;
}

#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                                              Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSetMarkerTrackingTimeoutVARJO(this->get(), markerId, timeout.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setMarkerTrackingTimeoutVARJO");
  }

  return;
}

#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setMarkerTrackingPredictionVARJO(uint64_t markerId,
                                                                 XrBool32 enabled,
                                                                 Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSetMarkerTrackingPredictionVARJO(this->get(), markerId, enabled));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setMarkerTrackingPredictionVARJO");
  }

  return;
}

#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Extent2Df Session::getMarkerSizeVARJO(uint64_t markerId, Dispatch&& d) const {
  Extent2Df returnVal;
  Result result = static_cast<Result>(
      d.xrGetMarkerSizeVARJO(this->get(), markerId, OPENXR_HPP_NAMESPACE::put(returnVal)));

  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::getMarkerSizeVARJO");
  }

  return returnVal;
}

#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space
Session::createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createMarkerSpaceVARJO");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>
Session::createMarkerSpaceUniqueVARJO(const MarkerSpaceCreateInfoVARJO& createInfo,
                                      Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createMarkerSpaceUniqueVARJO");
  }

  return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_VARJO_marker_tracking
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpatialAnchorStoreConnectionMSFT
Session::createSpatialAnchorStoreConnectionMSFT(Dispatch&& d) const {
  SpatialAnchorStoreConnectionMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorStoreConnectionMSFT(this->get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorStoreConnectionMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>
Session::createSpatialAnchorStoreConnectionUniqueMSFT(Dispatch&& d) const {
  SpatialAnchorStoreConnectionMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorStoreConnectionMSFT(this->get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING
                                     "::Session::createSpatialAnchorStoreConnectionUniqueMSFT");
  }

  return UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>(handle,
                                                                                        deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpatialAnchorStoreConnectionMSFT::destroy(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrDestroySpatialAnchorStoreConnectionMSFT(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::SpatialAnchorStoreConnectionMSFT::destroy");
  }

  return;
}

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpatialAnchorStoreConnectionMSFT::persistSpatialAnchorMSFT(
    const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrPersistSpatialAnchorMSFT(this->get(), spatialAnchorPersistenceInfo.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result,
        OPENXR_HPP_NAMESPACE_STRING "::SpatialAnchorStoreConnectionMSFT::persistSpatialAnchorMSFT");
  }

  return;
}

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
SpatialAnchorStoreConnectionMSFT::enumeratePersistedSpatialAnchorNamesToVectorMSFT(
    Dispatch&& d) const {
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator> persistedAnchorNames;
  uint32_t spatialAnchorNamesCountOutput = 0;
  uint32_t spatialAnchorNamesCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
      this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spatialAnchorNamesCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return persistedAnchorNames;
  }
  do {
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
    spatialAnchorNamesCapacityInput = static_cast<uint32_t>(persistedAnchorNames.size());
    result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
        this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput,
        reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(persistedAnchorNames.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spatialAnchorNamesCountOutput <= persistedAnchorNames.size());
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
  } else
    persistedAnchorNames.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return persistedAnchorNames;
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
SpatialAnchorStoreConnectionMSFT::enumeratePersistedSpatialAnchorNamesToVectorMSFT(
    Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator> persistedAnchorNames{vectorAllocator};
  uint32_t spatialAnchorNamesCountOutput = 0;
  uint32_t spatialAnchorNamesCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
      this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spatialAnchorNamesCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return persistedAnchorNames;
  }
  do {
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
    spatialAnchorNamesCapacityInput = static_cast<uint32_t>(persistedAnchorNames.size());
    result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
        this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput,
        reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(persistedAnchorNames.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spatialAnchorNamesCountOutput <= persistedAnchorNames.size());
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
  } else
    persistedAnchorNames.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return persistedAnchorNames;
}

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpatialAnchorMSFT Session::createSpatialAnchorFromPersistedNameMSFT(
    const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
    Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(d.xrCreateSpatialAnchorFromPersistedNameMSFT(
      this->get(), spatialAnchorCreateInfo.get(), handle.put()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorFromPersistedNameMSFT");
  }

  return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
Session::createSpatialAnchorFromPersistedNameUniqueMSFT(
    const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
    Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(d.xrCreateSpatialAnchorFromPersistedNameMSFT(
      this->get(), spatialAnchorCreateInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING
                                     "::Session::createSpatialAnchorFromPersistedNameUniqueMSFT");
  }

  return UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpatialAnchorStoreConnectionMSFT::unpersistSpatialAnchorMSFT(
    const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrUnpersistSpatialAnchorMSFT(this->get(), spatialAnchorPersistenceName.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING
        "::SpatialAnchorStoreConnectionMSFT::unpersistSpatialAnchorMSFT");
  }

  return;
}

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpatialAnchorStoreConnectionMSFT::clearSpatialAnchorStoreMSFT(
    Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrClearSpatialAnchorStoreMSFT(this->get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING
        "::SpatialAnchorStoreConnectionMSFT::clearSpatialAnchorStoreMSFT");
  }

  return;
}

#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::getAudioOutputDeviceGuidOculus(
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetAudioOutputDeviceGuidOculus(this->get(), buffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getAudioOutputDeviceGuidOculus");
  }

  return;
}

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid
#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::getAudioInputDeviceGuidOculus(
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetAudioInputDeviceGuidOculus(this->get(), buffer));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getAudioInputDeviceGuidOculus");
  }

  return;
}

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid
#ifdef XR_ALMALENCE_digital_lens_control

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setDigitalLensControlALMALENCE(
    const DigitalLensControlALMALENCE& digitalLensControl, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrSetDigitalLensControlALMALENCE(this->get(), digitalLensControl.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::setDigitalLensControlALMALENCE");
  }

  return;
}

#endif  // XR_ALMALENCE_digital_lens_control
#ifdef XR_FB_passthrough_keyboard_hands

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerSetKeyboardHandsIntensityFB(
    const PassthroughKeyboardHandsIntensityFB& intensity, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrPassthroughLayerSetKeyboardHandsIntensityFB(this->get(), intensity.get()));

  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING
        "::PassthroughLayerFB::passthroughLayerSetKeyboardHandsIntensityFB");
  }

  return;
}

#endif  // XR_FB_passthrough_keyboard_hands
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // ifndef OPENXR_METHOD_IMPLS_ENHANCED_EXCEPTIONS_INL_
