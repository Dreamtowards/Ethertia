// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_HANDLES_HPP_
#define OPENXR_HANDLES_HPP_
/**
 * @file
 * @brief Declares wrappers for OpenXR handle types, with function calls transformed into methods,
 * as well as free functions for those few that do not take a handle as their first argument.
 *
 * Does not include the implementations of the functions: for that, see @ref openxr_method_impls.hpp
 * @ingroup handles
 * @ingroup api_free_functions
 */

#include "openxr_atoms.hpp"
#include "openxr_enums.hpp"
#include "openxr_exceptions.hpp"
#include "openxr_flags.hpp"
#include "openxr_handles_forward.hpp"
#include "openxr_structs_forward.hpp"
#include "openxr_time.hpp"
#include "openxr_dispatch_traits.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#include <vector>
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#if !defined(OPENXR_HPP_INLINE)
#if defined(__clang___)
#if __has_attribute(always_inline)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#else
#define OPENXR_HPP_INLINE inline
#endif
#elif defined(__GNUC__)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#elif defined(_MSC_VER)
#define OPENXR_HPP_INLINE inline
#else
#define OPENXR_HPP_INLINE inline
#endif
#endif  // !OPENXR_HPP_INLINE

#if !defined(OPENXR_HPP_CONSTEXPR)
#if defined(_MSC_VER) && (_MSC_VER <= 1800)
#define OPENXR_HPP_CONSTEXPR
#else
#define OPENXR_HPP_CONSTEXPR constexpr
#endif
#endif  // !OPENXR_HPP_CONSTEXPR

#if !defined(OPENXR_HPP_SWITCH_CONSTEXPR)
//! @todo set this to constexpr in c++14
#define OPENXR_HPP_SWITCH_CONSTEXPR
#endif  // !OPENXR_HPP_SWITCH_CONSTEXPR

// 32-bit OpenXR is not typesafe for handles, so don't allow copy constructors
// on this platform by default. To enable this feature on 32-bit platforms
// please define OPENXR_HPP_TYPESAFE_CONVERSION
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || \
    defined(_M_X64) || defined(__ia64) || defined(_M_IA64) || defined(__aarch64__) ||       \
    defined(__powerpc64__)
#if !defined(OPENXR_HPP_TYPESAFE_CONVERSION)
#define OPENXR_HPP_TYPESAFE_CONVERSION
#endif
#endif

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#if !defined(OPENXR_HPP_TYPESAFE_EXPLICIT)
#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
#define OPENXR_HPP_TYPESAFE_EXPLICIT
#else
#define OPENXR_HPP_TYPESAFE_EXPLICIT explicit
#endif
#endif  // !OPENXR_HPP_TYPESAFE_EXPLICIT

#ifdef OPENXR_HPP_DOXYGEN
#define OPENXR_HPP_NO_DEFAULT_DISPATCH
#define OPENXR_HPP_NO_SMART_HANDLE
#undef OPENXR_HPP_NO_SMART_HANDLE
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER DispatchLoaderStatic()
#undef OPENXR_HPP_DEFAULT_CORE_DISPATCHER
#define OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#undef OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#endif

/*!
 * @def OPENXR_HPP_TYPESAFE_CONVERSION
 * @brief Whether to force conversion/implicit constructors.
 *
 * Enabled by default on 64-bit platforms.
 * 32-bit OpenXR is not typesafe for handles, so this is disabled on such platforms by default.
 * To enable this feature on 32-bit platforms please define `OPENXR_HPP_TYPESAFE_CONVERSION`
 *
 * @ingroup config
 */
/*!
 * @defgroup config_dispatch Default dispatch configuration
 * @ingroup config
 */
/*!
 * @def OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @brief Define to disable default dispatch arguments.
 * @see OPENXR_HPP_DEFAULT_CORE_DISPATCHER, OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_CORE_DISPATCHER
 * @brief Define to the expression you'd like to use as the default dispatcher for core API
 * functions.
 *
 * Defaults to `DispatchLoaderStatic()` unless `OPENXR_HPP_NO_DEFAULT_DISPATCH` is defined.
 *
 * If both this and `OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE` are defined (by you, or by default if
 * `OPENXR_HPP_NO_DEFAULT_DISPATCH` is not defined), `OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG` will be
 * defined to `= OPENXR_HPP_DEFAULT_CORE_DISPATCHER`.
 *
 * @see DispatchLoaderStatic, OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE,
 * OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
 * @brief Define to the type of the expression you'd like to use as the default dispatcher for core
 * API functions.
 *
 * This will be used as the default type parameter in functions where
 * `OPENXR_HPP_DEFAULT_CORE_DISPATCHER` will be the default argument.
 *
 * Defaults to `DispatchLoaderStatic` unless `OPENXR_HPP_NO_DEFAULT_DISPATCH` is defined.
 *
 * If both this and `OPENXR_HPP_DEFAULT_CORE_DISPATCHER` are defined (by you, or by default if
 * `OPENXR_HPP_NO_DEFAULT_DISPATCH` is not defined), `OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG`
 * will be defined to `= OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE`.
 *
 * @see DispatchLoaderStatic, OPENXR_HPP_DEFAULT_CORE_DISPATCHER, OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
 * @brief Define to the expression you'd like to use as the default dispatcher for extension API
 * functions.
 *
 * This has no default value: by default, you need to provide a dispatcher explicitly for extension
 * functions. If you define this and `OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE`, however,
 * `OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG` will be set to `=` and your definition.
 *
 * A globally-accessible instance of xr::DispatchLoaderDynamic would be suitable.
 *
 * @ingroup config_dispatch
 */

/*!
 * @def OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE
 * @brief Define to the type expression you'd like to use as the type of the default dispatcher for
 * extension API functions.
 *
 * This has no default value: by default, you need to provide a dispatcher explicitly for extension
 * functions. If you define this and `OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER`, however,
 * `OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG` will be set to `=` and your definition.
 *
 * xr::DispatchLoaderDynamic would be suitable.
 *
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DISABLE_ENHANCED_MODE
 * @brief Define in order to disable the more complete C++ projections of OpenXR methods, leaving
 * only the most C-like prototypes behind.
 *
 * This will disable returning of output parameters (directly and through ReturnType pairs),
 * wrapping of two-call-idiom methods, functions creating `Unique` handles with ownership, etc.
 * It slightly reduces the number of files included.
 *
 * @ingroup config
 */

/*!
 * @def OPENXR_HPP_NO_SMART_HANDLE
 * @brief Define in order to disable the UniqueHandle-creating C++ method projections.
 *
 * Enhanced mode creation calls by default include a projection that returns a smart handle
 * representing unique ownership. Defining this macro will hide those methods.
 *
 * @see OPENXR_HPP_DISABLE_ENHANCED_MODE
 *
 * @ingroup config
 */

#ifndef OPENXR_HPP_NO_DEFAULT_DISPATCH

#if !defined(XR_NO_PROTOTYPES) && !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER) && \
    !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER DispatchLoaderStatic()
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE DispatchLoaderStatic
#include "openxr_dispatch_static.hpp"
#endif  // !defined(XR_NO_PROTOTYPES) && !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER)

#endif  // !OPENXR_HPP_NO_DEFAULT_DISPATCH

#if defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER) && defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG = OPENXR_HPP_DEFAULT_CORE_DISPATCHER
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG = OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
#endif

#if defined(OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER) && \
    defined(OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG = OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG = OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE
#endif

#ifndef OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG
#endif

namespace OPENXR_HPP_NAMESPACE {

/*!
 * @defgroup return_results Returning results
 * @brief Types used by API call wrappers to return output in a friendly, C++ manner.
 */

/*!
 * @brief Contains a Result enumerant and a returned value.
 *
 * Implicitly convertible to std::tuple<> so you can do `std::tie(result, value)
 * = callThatReturnsResultValue()`
 *
 * @ingroup return_results
 */
template <typename T>
struct ResultValue {
  ResultValue(Result r, T const& v) : result(r), value(v) {}

  ResultValue(Result r, T&& v) : result(r), value(std::move(v)) {}

  Result result;
  T value;

  operator std::tuple<Result&, T&>() { return std::tuple<Result&, T&>(result, value); }
  operator std::tuple<Result const&, T const&>() const {
    return std::tuple<Result const&, T const&>(result, value);
  }
};

}  // namespace OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
// The generalization of std::string with user-specifiable allocator types.
template <typename Allocator = std::allocator<char>>
using string_with_allocator = std::basic_string<char, std::char_traits<char>, Allocator>;
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief Handle class - wrapping XrInstance without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstance>
 *
 * @xrentity{XrInstance}
 * @ingroup handles
 */
class Instance {
public:
  using Type = Instance;
  using RawHandleType = XrInstance;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Instance() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrInstance type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Instance(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Instance(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrInstance
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrInstance type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Instance value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Instance value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrInstance manipulation
   * @{
   */
  //! Gets the raw XrInstance value.
  OPENXR_HPP_CONSTEXPR XrInstance get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Instance yourHandle;
   * auto result = d.xrCreateInstance(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Instance&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetInstanceProcAddr wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInstanceProcAddr enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetInstanceProcAddr enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyInstance wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyInstance enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyInstance enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetInstanceProperties wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProperties(InstanceProperties& instanceProperties,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInstanceProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type InstanceProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<InstanceProperties> getInstanceProperties(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetInstanceProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type InstanceProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  InstanceProperties getInstanceProperties(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPollEvent wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollEvent>
   *
   * @xrentity{xrPollEvent}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollEvent(EventDataBuffer& eventData,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPollEvent enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::EventUnavailable, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollEvent>
   *
   * @xrentity{xrPollEvent}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollEvent(EventDataBuffer& eventData,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrResultToString wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrResultToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrResultToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStructureTypeToString wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStructureTypeToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStructureTypeToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSystem wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSystem(const SystemGetInfo& getInfo, SystemId systemId,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSystem enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SystemId
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SystemId> getSystem(const SystemGetInfo& getInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSystem enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SystemId
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SystemId getSystem(const SystemGetInfo& getInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSystemProperties wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSystemProperties(SystemId systemId, SystemProperties& properties,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSystemProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SystemProperties
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SystemProperties> getSystemProperties(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSystemProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SystemProperties
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SystemProperties getSystemProperties(SystemId systemId,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateEnvironmentBlendModes wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateEnvironmentBlendModes(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        uint32_t environmentBlendModeCapacityInput,
                                        uint32_t* environmentBlendModeCountOutput,
                                        XrEnvironmentBlendMode* environmentBlendModes,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<EnvironmentBlendMode, Allocator>> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<EnvironmentBlendMode, Allocator>> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<EnvironmentBlendMode, Allocator> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<EnvironmentBlendMode, Allocator> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSession(const SessionCreateInfo& createInfo, Session& session,
                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSession enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Session> createSession(const SessionCreateInfo& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSession enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Session createSession(const SessionCreateInfo& createInfo,
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSession wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>> createSessionUnique(
      const SessionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSession wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Session, impl::RemoveRefConst<Dispatch>> createSessionUnique(
      const SessionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateViewConfigurations wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViewConfigurations(SystemId systemId, uint32_t viewConfigurationTypeCapacityInput,
                                     uint32_t* viewConfigurationTypeCountOutput,
                                     XrViewConfigurationType* viewConfigurationTypes,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationType, Allocator>> enumerateViewConfigurationsToVector(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationType, Allocator>> enumerateViewConfigurationsToVector(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationType, Allocator> enumerateViewConfigurationsToVector(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationType, Allocator> enumerateViewConfigurationsToVector(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetViewConfigurationProperties wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getViewConfigurationProperties(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        ViewConfigurationProperties& configurationProperties,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetViewConfigurationProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ViewConfigurationProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ViewConfigurationProperties> getViewConfigurationProperties(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetViewConfigurationProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ViewConfigurationProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ViewConfigurationProperties getViewConfigurationProperties(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateViewConfigurationViews wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViewConfigurationViews(SystemId systemId,
                                         ViewConfigurationType viewConfigurationType,
                                         uint32_t viewCapacityInput, uint32_t* viewCountOutput,
                                         XrViewConfigurationView* views,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationView, Allocator>>
  enumerateViewConfigurationViewsToVector(SystemId systemId,
                                          ViewConfigurationType viewConfigurationType,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationView, Allocator>>
  enumerateViewConfigurationViewsToVector(SystemId systemId,
                                          ViewConfigurationType viewConfigurationType,
                                          Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationView, Allocator> enumerateViewConfigurationViewsToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationView, Allocator> enumerateViewConfigurationViewsToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrStringToPath wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stringToPath(const char* pathString, Path path,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStringToPath enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Path
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Path> stringToPath(const char* pathString,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStringToPath enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Path
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Path stringToPath(const char* pathString,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrPathToString wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pathToString(Path path, uint32_t bufferCapacityInput, uint32_t* bufferCountOutput,
                      char* buffer, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> pathToString(
      Path path, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> pathToString(Path path,
                                                             Allocator const& vectorAllocator,
                                                             Dispatch&& d) const;

#else
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> pathToString(
      Path path, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> pathToString(Path path, Allocator const& vectorAllocator,
                                                Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateActionSet wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createActionSet(const ActionSetCreateInfo& createInfo, ActionSet& actionSet,
                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSet enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionSet> createActionSet(const ActionSetCreateInfo& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSet enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionSet createActionSet(const ActionSetCreateInfo& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSet wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>> createActionSetUnique(
      const ActionSetCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSet wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>> createActionSetUnique(
      const ActionSetCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSuggestInteractionProfileBindings wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSuggestInteractionProfileBindings enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSuggestInteractionProfileBindings enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getOpenGLGraphicsRequirementsKHR(SystemId systemId,
                                          GraphicsRequirementsOpenGLKHR& graphicsRequirements,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsOpenGLKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsOpenGLKHR> getOpenGLGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsOpenGLKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsOpenGLKHR getOpenGLGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getOpenGLESGraphicsRequirementsKHR(SystemId systemId,
                                            GraphicsRequirementsOpenGLESKHR& graphicsRequirements,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsOpenGLESKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsOpenGLESKHR> getOpenGLESGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsOpenGLESKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsOpenGLESKHR getOpenGLESGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanInstanceExtensionsKHR(SystemId systemId, uint32_t bufferCapacityInput,
                                        uint32_t* bufferCountOutput, char* buffer,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanInstanceExtensionsKHR(SystemId systemId,
                                                                  Allocator const& vectorAllocator,
                                                                  Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanDeviceExtensionsKHR(SystemId systemId, uint32_t bufferCapacityInput,
                                      uint32_t* bufferCountOutput, char* buffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanDeviceExtensionsKHR(SystemId systemId,
                                                                Allocator const& vectorAllocator,
                                                                Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsDeviceKHR(SystemId systemId, VkInstance vkInstance,
                                    VkPhysicalDevice* vkPhysicalDevice,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VkPhysicalDevice> getVulkanGraphicsDeviceKHR(
      SystemId systemId, VkInstance vkInstance,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VkPhysicalDevice getVulkanGraphicsDeviceKHR(SystemId systemId, VkInstance vkInstance,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsRequirementsKHR(SystemId systemId,
                                          GraphicsRequirementsVulkanKHR& graphicsRequirements,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsVulkanKHR> getVulkanGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsVulkanKHR getVulkanGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getD3D11GraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsD3D11KHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsD3D11KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsD3D11KHR> getD3D11GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsD3D11KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsD3D11KHR getD3D11GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getD3D12GraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsD3D12KHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsD3D12KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsD3D12KHR> getD3D12GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsD3D12KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsD3D12KHR getD3D12GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertWin32PerformanceCounterToTimeKHR(const LARGE_INTEGER* performanceCounter, Time time,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Time> convertWin32PerformanceCounterToTimeKHR(
      const LARGE_INTEGER* performanceCounter,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Time convertWin32PerformanceCounterToTimeKHR(const LARGE_INTEGER* performanceCounter,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimeToWin32PerformanceCounterKHR(Time time, LARGE_INTEGER* performanceCounter,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type LARGE_INTEGER
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<LARGE_INTEGER> convertTimeToWin32PerformanceCounterKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type LARGE_INTEGER
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  LARGE_INTEGER convertTimeToWin32PerformanceCounterKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

  /*!
   * @brief xrConvertTimespecTimeToTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimespecTimeToTimeKHR(const struct timespec* timespecTime, Time time,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimespecTimeToTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Time> convertTimespecTimeToTimeKHR(
      const struct timespec* timespecTime, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimespecTimeToTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Time convertTimespecTimeToTimeKHR(const struct timespec* timespecTime,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

  /*!
   * @brief xrConvertTimeToTimespecTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimeToTimespecTimeKHR(Time time, struct timespec* timespecTime,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimeToTimespecTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type timespec
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<timespec> convertTimeToTimespecTimeKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimeToTimespecTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type timespec
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  timespec convertTimeToTimespecTimeKHR(Time time,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateVulkanInstanceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                                 VkInstance* vulkanInstance, VkResult* vulkanResult,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVulkanInstanceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                                 VkInstance* vulkanInstance, VkResult* vulkanResult,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVulkanInstanceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                               VkInstance* vulkanInstance, VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateVulkanDeviceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                               VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVulkanDeviceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                               VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVulkanDeviceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                             VkResult* vulkanResult,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsDevice2KHR(const VulkanGraphicsDeviceGetInfoKHR& getInfo,
                                     VkPhysicalDevice* vulkanPhysicalDevice,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VkPhysicalDevice> getVulkanGraphicsDevice2KHR(
      const VulkanGraphicsDeviceGetInfoKHR& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VkPhysicalDevice getVulkanGraphicsDevice2KHR(const VulkanGraphicsDeviceGetInfoKHR& getInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsRequirements2KHR(SystemId systemId,
                                           GraphicsRequirementsVulkanKHR& graphicsRequirements,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsVulkanKHR> getVulkanGraphicsRequirements2KHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsVulkanKHR getVulkanGraphicsRequirements2KHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createDebugUtilsMessengerEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                      DebugUtilsMessengerEXT& messenger,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<DebugUtilsMessengerEXT> createDebugUtilsMessengerEXT(
      const DebugUtilsMessengerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  DebugUtilsMessengerEXT createDebugUtilsMessengerEXT(
      const DebugUtilsMessengerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>>
  createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>
  createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                    const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                    const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                  XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                  const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_composition_layer_reprojection

  /*!
   * @brief xrEnumerateReprojectionModesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateReprojectionModesMSFT(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        uint32_t modeCapacityInput, uint32_t* modeCountOutput,
                                        XrReprojectionModeMSFT* modes,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReprojectionModeMSFT, Allocator>> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReprojectionModeMSFT, Allocator>> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReprojectionModeMSFT, Allocator> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReprojectionModeMSFT, Allocator> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_MSFT_scene_understanding

  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSceneComputeFeaturesMSFT(SystemId systemId, uint32_t featureCapacityInput,
                                           uint32_t* featureCountOutput,
                                           XrSceneComputeFeatureMSFT* features,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SceneComputeFeatureMSFT, Allocator>>
  enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SceneComputeFeatureMSFT, Allocator>>
  enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId, Allocator const& vectorAllocator,
                                            Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SceneComputeFeatureMSFT, Allocator> enumerateSceneComputeFeaturesToVectorMSFT(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SceneComputeFeatureMSFT, Allocator> enumerateSceneComputeFeaturesToVectorMSFT(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding

#ifdef XR_HTCX_vive_tracker_interaction

  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViveTrackerPathsHTCX(uint32_t pathCapacityInput, uint32_t* pathCountOutput,
                                       XrViveTrackerPathsHTCX* paths,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>> enumerateViveTrackerPathsToVectorHTCX(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>> enumerateViveTrackerPathsToVectorHTCX(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViveTrackerPathsHTCX, Allocator> enumerateViveTrackerPathsToVectorHTCX(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViveTrackerPathsHTCX, Allocator> enumerateViveTrackerPathsToVectorHTCX(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetAudioOutputDeviceGuidOculus wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioOutputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioOutputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioOutputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetAudioOutputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioOutputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioOutputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioOutputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetAudioOutputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioOutputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioOutputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getAudioOutputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid

#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetAudioInputDeviceGuidOculus wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioInputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioInputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioInputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetAudioInputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioInputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioInputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioInputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetAudioInputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioInputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioInputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getAudioInputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid

  //! @}
private:
  XrInstance val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrInstance) == sizeof(Instance),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrInstance from an Instance value.
 *
 * @found_by_adl
 * @see Instance::get()
 * @relates Instance
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrInstance get(Instance const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrInstance handle in a Instance (by reference).
 *
 * e.g.
 * ```
 * Instance yourHandle;
 * auto result = d.xrCreateInstance(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Instance
 */
static OPENXR_HPP_INLINE XrInstance* put(Instance& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Instance const& lhs,
                                                      Instance const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Instance const& lhs,
                                                      Instance const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Instance const& lhs,
                                                      XrInstance rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrInstance lhs,
                                                      Instance const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Instance const& lhs,
                                                      XrInstance rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrInstance lhs,
                                                      Instance const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Instance and nullptr: true if the handle is null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Instance: true if the handle is null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Instance const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Instance and nullptr: true if the handle is not null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Instance: true if the handle is not null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Instance const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSession without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSession>
 *
 * @xrentity{XrSession}
 * @ingroup handles
 */
class Session {
public:
  using Type = Session;
  using RawHandleType = XrSession;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Session() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSession type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Session(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Session(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSession
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSession type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Session value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Session value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSession manipulation
   * @{
   */
  //! Gets the raw XrSession value.
  OPENXR_HPP_CONSTEXPR XrSession get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Session yourHandle;
   * auto result = d.xrCreateSession(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Session&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateReferenceSpaces wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateReferenceSpaces(uint32_t spaceCapacityInput, uint32_t* spaceCountOutput,
                                  XrReferenceSpaceType* spaces,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReferenceSpaceType, Allocator>> enumerateReferenceSpacesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReferenceSpaceType, Allocator>> enumerateReferenceSpacesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReferenceSpaceType, Allocator> enumerateReferenceSpacesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReferenceSpaceType, Allocator> enumerateReferenceSpacesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateReferenceSpace wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo, Space& space,
                              Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateReferenceSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateReferenceSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateReferenceSpace wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createReferenceSpaceUnique(
      const ReferenceSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateReferenceSpace wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createReferenceSpaceUnique(
      const ReferenceSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetReferenceSpaceBoundsRect wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetReferenceSpaceBoundsRect>
   *
   * @xrentity{xrGetReferenceSpaceBoundsRect}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType, Extent2Df& bounds,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetReferenceSpaceBoundsRect enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SpaceBoundsUnavailable, or an error code
   * if asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetReferenceSpaceBoundsRect>
   *
   * @xrentity{xrGetReferenceSpaceBoundsRect}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType, Extent2Df& bounds,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateActionSpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createActionSpace(const ActionSpaceCreateInfo& createInfo, Space& space,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createActionSpace(const ActionSpaceCreateInfo& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createActionSpace(const ActionSpaceCreateInfo& createInfo,
                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSpace wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createActionSpaceUnique(
      const ActionSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSpace wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createActionSpaceUnique(
      const ActionSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateSwapchainFormats wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainFormats(uint32_t formatCapacityInput, uint32_t* formatCountOutput,
                                   int64_t* formats,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<int64_t, Allocator>> enumerateSwapchainFormatsToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<int64_t, Allocator>> enumerateSwapchainFormatsToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<int64_t, Allocator> enumerateSwapchainFormatsToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<int64_t, Allocator> enumerateSwapchainFormatsToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSwapchain wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSwapchain(const SwapchainCreateInfo& createInfo, Swapchain& swapchain,
                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchain enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Swapchain> createSwapchain(const SwapchainCreateInfo& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchain enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Swapchain createSwapchain(const SwapchainCreateInfo& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchain wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>> createSwapchainUnique(
      const SwapchainCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchain wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> createSwapchainUnique(
      const SwapchainCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginSession(const SessionBeginInfo& beginInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrBeginSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginSession(const SessionBeginInfo& beginInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrBeginSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void beginSession(const SessionBeginInfo& beginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEndSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEndSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEndSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestExitSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestExitSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestExitSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrWaitFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitFrame(const FrameWaitInfo& frameWaitInfo, FrameState& frameState,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrWaitFrame enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FrameState
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FrameState> waitFrame(const FrameWaitInfo& frameWaitInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrWaitFrame enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FrameState
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FrameState waitFrame(const FrameWaitInfo& frameWaitInfo,
                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginFrame>
   *
   * @xrentity{xrBeginFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginFrame(const FrameBeginInfo& frameBeginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::FrameDiscarded, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginFrame>
   *
   * @xrentity{xrBeginFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginFrame(const FrameBeginInfo& frameBeginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEndFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endFrame(const FrameEndInfo& frameEndInfo,
                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEndFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endFrame(const FrameEndInfo& frameEndInfo,
                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEndFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void endFrame(const FrameEndInfo& frameEndInfo,
                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrLocateViews wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateViews(const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
                     uint32_t viewCapacityInput, uint32_t* viewCountOutput, XrView* views,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<View, Allocator>> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<View, Allocator>> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<View, Allocator> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<View, Allocator> locateViewsToVector(const ViewLocateInfo& viewLocateInfo,
                                                   XrViewState* viewState,
                                                   Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrAttachSessionActionSets wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAttachSessionActionSets enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAttachSessionActionSets enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetCurrentInteractionProfile wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getCurrentInteractionProfile(Path topLevelUserPath,
                                      InteractionProfileState& interactionProfile,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetCurrentInteractionProfile enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type InteractionProfileState
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<InteractionProfileState> getCurrentInteractionProfile(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetCurrentInteractionProfile enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type InteractionProfileState
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  InteractionProfileState getCurrentInteractionProfile(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateBoolean wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateBoolean(const ActionStateGetInfo& getInfo, ActionStateBoolean& state,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateBoolean enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateBoolean
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateBoolean> getActionStateBoolean(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateBoolean enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateBoolean
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateBoolean getActionStateBoolean(const ActionStateGetInfo& getInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateFloat wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateFloat(const ActionStateGetInfo& getInfo, ActionStateFloat& state,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateFloat enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateFloat
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateFloat> getActionStateFloat(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateFloat enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateFloat
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateFloat getActionStateFloat(const ActionStateGetInfo& getInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateVector2f wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateVector2f(const ActionStateGetInfo& getInfo, ActionStateVector2f& state,
                                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateVector2f enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateVector2f
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateVector2f> getActionStateVector2f(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateVector2f enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateVector2f
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateVector2f getActionStateVector2f(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStatePose wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStatePose(const ActionStateGetInfo& getInfo, ActionStatePose& state,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStatePose enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStatePose
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStatePose> getActionStatePose(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStatePose enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStatePose
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStatePose getActionStatePose(const ActionStateGetInfo& getInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSyncActions wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSyncActions>
   *
   * @xrentity{xrSyncActions}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result syncActions(const ActionsSyncInfo& syncInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSyncActions enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSyncActions>
   *
   * @xrentity{xrSyncActions}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result syncActions(const ActionsSyncInfo& syncInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateBoundSourcesForAction wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateBoundSourcesForAction(const BoundSourcesForActionEnumerateInfo& enumerateInfo,
                                        uint32_t sourceCapacityInput, uint32_t* sourceCountOutput,
                                        Path sources,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetInputSourceLocalizedName wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInputSourceLocalizedName(const InputSourceLocalizedNameGetInfo& getInfo,
                                     uint32_t bufferCapacityInput, uint32_t* bufferCountOutput,
                                     char* buffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyHapticFeedback wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                             const XrHapticBaseHeader* hapticFeedback,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                             const XrHapticBaseHeader* hapticFeedback,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopHapticFeedback wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetAndroidApplicationThreadKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetAndroidApplicationThreadKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetAndroidApplicationThreadKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSwapchainAndroidSurfaceKHR(const SwapchainCreateInfo& info, Swapchain& swapchain,
                                          jobject* surface,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Swapchain> createSwapchainAndroidSurfaceKHR(
      const SwapchainCreateInfo& info, jobject* surface,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Swapchain createSwapchainAndroidSurfaceKHR(const SwapchainCreateInfo& info, jobject* surface,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>>
  createSwapchainAndroidSurfaceUniqueKHR(const SwapchainCreateInfo& info, jobject* surface,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> createSwapchainAndroidSurfaceUniqueKHR(
      const SwapchainCreateInfo& info, jobject* surface,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain

#ifdef XR_KHR_visibility_mask

  /*!
   * @brief xrGetVisibilityMaskKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
                              VisibilityMaskTypeKHR visibilityMaskType,
                              VisibilityMaskKHR& visibilityMask,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVisibilityMaskKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VisibilityMaskKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VisibilityMaskKHR> getVisibilityMaskKHR(
      ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
      VisibilityMaskTypeKHR visibilityMaskType,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVisibilityMaskKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VisibilityMaskKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VisibilityMaskKHR getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType,
                                         uint32_t viewIndex,
                                         VisibilityMaskTypeKHR visibilityMaskType,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_visibility_mask

#ifdef XR_EXT_performance_settings

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                            PerfSettingsLevelEXT level,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                            PerfSettingsLevelEXT level,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain, PerfSettingsLevelEXT level,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_thermal_query

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrThermalGetTemperatureTrendEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                       PerfSettingsNotificationLevelEXT& notificationLevel,
                                       float* tempHeadroom, float* tempSlope,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrThermalGetTemperatureTrendEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                       PerfSettingsNotificationLevelEXT& notificationLevel,
                                       float* tempHeadroom, float* tempSlope,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrThermalGetTemperatureTrendEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                     PerfSettingsNotificationLevelEXT& notificationLevel,
                                     float* tempHeadroom, float* tempSlope,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_thermal_query

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionBeginDebugUtilsLabelRegionEXT(
      const DebugUtilsLabelEXT& labelInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionBeginDebugUtilsLabelRegionEXT(
      const DebugUtilsLabelEXT& labelInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionBeginDebugUtilsLabelRegionEXT(const DebugUtilsLabelEXT& labelInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                 SpatialAnchorMSFT& anchor,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorMSFT(
      const SpatialAnchorCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorUniqueMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>> createSpatialAnchorUniqueMSFT(
      const SpatialAnchorCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorSpaceMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                      Space& space,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createSpatialAnchorSpaceMSFT(
      const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createSpatialAnchorSpaceMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorSpaceUniqueMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createSpatialAnchorSpaceUniqueMSFT(
      const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceActiveEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, XrBool32 isActive,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceActiveEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, XrBool32 isActive,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceActiveEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, XrBool32 isActive,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateBoolEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, XrBool32 state,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateBoolEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, XrBool32 state,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateBoolEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, XrBool32 state,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateFloatEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateFloatEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateFloatEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, XrVector2f state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, XrVector2f state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, XrVector2f state,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceLocationEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space,
                                   XrPosef pose,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceLocationEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space,
                                   XrPosef pose,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceLocationEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space, XrPosef pose,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_hand_tracking

  /*!
   * @brief xrCreateHandTrackerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                              HandTrackerEXT& handTracker,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandTrackerEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandTrackerEXT> createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandTrackerEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandTrackerEXT createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandTrackerEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>>
  createHandTrackerUniqueEXT(const HandTrackerCreateInfoEXT& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandTrackerEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>> createHandTrackerUniqueEXT(
      const HandTrackerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, SpatialAnchorMSFT& anchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorFromPerceptionAnchorUniqueMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorFromPerceptionAnchorUniqueMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_MSFT_scene_understanding

  /*!
   * @brief xrCreateSceneObserverMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSceneObserverMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                 SceneObserverMSFT& sceneObserver,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneObserverMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneObserverMSFT> createSceneObserverMSFT(
      const SceneObserverCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneObserverMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneObserverMSFT createSceneObserverMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneObserverMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>>>
  createSceneObserverUniqueMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneObserverMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>> createSceneObserverUniqueMSFT(
      const SceneObserverCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding

#ifdef XR_FB_display_refresh_rate

  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateDisplayRefreshRatesFB(uint32_t displayRefreshRateCapacityInput,
                                        uint32_t* displayRefreshRateCountOutput,
                                        float* displayRefreshRates,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> enumerateDisplayRefreshRatesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> enumerateDisplayRefreshRatesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> enumerateDisplayRefreshRatesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> enumerateDisplayRefreshRatesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

  /*!
   * @brief xrGetDisplayRefreshRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getDisplayRefreshRateFB(float* displayRefreshRate,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetDisplayRefreshRateFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<float> getDisplayRefreshRateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetDisplayRefreshRateFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  float getDisplayRefreshRateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestDisplayRefreshRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestDisplayRefreshRateFB(float displayRefreshRate,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestDisplayRefreshRateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestDisplayRefreshRateFB(float displayRefreshRate,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestDisplayRefreshRateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestDisplayRefreshRateFB(float displayRefreshRate,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_HTC_facial_tracking

  /*!
   * @brief xrCreateFacialTrackerHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFacialTrackerHTC(const FacialTrackerCreateInfoHTC& createInfo,
                                FacialTrackerHTC& facialTracker,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFacialTrackerHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FacialTrackerHTC> createFacialTrackerHTC(
      const FacialTrackerCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFacialTrackerHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FacialTrackerHTC createFacialTrackerHTC(const FacialTrackerCreateInfoHTC& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFacialTrackerHTC wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>>
  createFacialTrackerUniqueHTC(const FacialTrackerCreateInfoHTC& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFacialTrackerHTC wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>> createFacialTrackerUniqueHTC(
      const FacialTrackerCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space

  /*!
   * @brief xrEnumerateColorSpacesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateColorSpacesFB(uint32_t colorSpaceCapacityInput, uint32_t* colorSpaceCountOutput,
                                XrColorSpaceFB* colorSpaces,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ColorSpaceFB, Allocator>> enumerateColorSpacesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ColorSpaceFB, Allocator>> enumerateColorSpacesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ColorSpaceFB, Allocator> enumerateColorSpacesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ColorSpaceFB, Allocator> enumerateColorSpacesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_color_space

#ifdef XR_FB_color_space

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetColorSpaceFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setColorSpaceFB(ColorSpaceFB colorspace,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetColorSpaceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setColorSpaceFB(ColorSpaceFB colorspace,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetColorSpaceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setColorSpaceFB(ColorSpaceFB colorspace,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_color_space

#ifdef XR_FB_foveation

  /*!
   * @brief xrCreateFoveationProfileFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFoveationProfileFB(const FoveationProfileCreateInfoFB& createInfo,
                                  FoveationProfileFB& profile,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFoveationProfileFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FoveationProfileFB> createFoveationProfileFB(
      const FoveationProfileCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFoveationProfileFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FoveationProfileFB createFoveationProfileFB(const FoveationProfileCreateInfoFB& createInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFoveationProfileFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>>
  createFoveationProfileUniqueFB(const FoveationProfileCreateInfoFB& createInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFoveationProfileFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>> createFoveationProfileUniqueFB(
      const FoveationProfileCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_foveation

#ifdef XR_FB_keyboard_tracking

  /*!
   * @brief xrQuerySystemTrackedKeyboardFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySystemTrackedKeyboardFB>
   *
   * @xrentity{xrQuerySystemTrackedKeyboardFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySystemTrackedKeyboardFB(const KeyboardTrackingQueryFB& queryInfo,
                                      KeyboardTrackingDescriptionFB& keyboard,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySystemTrackedKeyboardFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type KeyboardTrackingDescriptionFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySystemTrackedKeyboardFB>
   *
   * @xrentity{xrQuerySystemTrackedKeyboardFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<KeyboardTrackingDescriptionFB> querySystemTrackedKeyboardFB(
      const KeyboardTrackingQueryFB& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySystemTrackedKeyboardFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type KeyboardTrackingDescriptionFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySystemTrackedKeyboardFB>
   *
   * @xrentity{xrQuerySystemTrackedKeyboardFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  KeyboardTrackingDescriptionFB querySystemTrackedKeyboardFB(
      const KeyboardTrackingQueryFB& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking

  /*!
   * @brief xrCreateKeyboardSpaceFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo, Space& keyboardSpace,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateKeyboardSpaceFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateKeyboardSpaceFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateKeyboardSpaceFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createKeyboardSpaceUniqueFB(
      const KeyboardSpaceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateKeyboardSpaceFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createKeyboardSpaceUniqueFB(
      const KeyboardSpaceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_triangle_mesh

  /*!
   * @brief xrCreateTriangleMeshFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo,
                              TriangleMeshFB& outTriangleMesh,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateTriangleMeshFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<TriangleMeshFB> createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateTriangleMeshFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  TriangleMeshFB createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateTriangleMeshFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>>
  createTriangleMeshUniqueFB(const TriangleMeshCreateInfoFB& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateTriangleMeshFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>> createTriangleMeshUniqueFB(
      const TriangleMeshCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough

  /*!
   * @brief xrCreatePassthroughFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPassthroughFB(const PassthroughCreateInfoFB& createInfo,
                             PassthroughFB& outPassthrough,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughFB> createPassthroughFB(const PassthroughCreateInfoFB& createInfo,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughFB createPassthroughFB(const PassthroughCreateInfoFB& createInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>>
  createPassthroughUniqueFB(const PassthroughCreateInfoFB& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>> createPassthroughUniqueFB(
      const PassthroughCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

  /*!
   * @brief xrCreatePassthroughLayerFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPassthroughLayerFB(const PassthroughLayerCreateInfoFB& createInfo,
                                  PassthroughLayerFB& outLayer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughLayerFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughLayerFB> createPassthroughLayerFB(
      const PassthroughLayerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughLayerFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughLayerFB createPassthroughLayerFB(const PassthroughLayerCreateInfoFB& createInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughLayerFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>>
  createPassthroughLayerUniqueFB(const PassthroughLayerCreateInfoFB& createInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughLayerFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>> createPassthroughLayerUniqueFB(
      const PassthroughLayerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

  /*!
   * @brief xrCreateGeometryInstanceFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createGeometryInstanceFB(const GeometryInstanceCreateInfoFB& createInfo,
                                  GeometryInstanceFB& outGeometryInstance,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateGeometryInstanceFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GeometryInstanceFB> createGeometryInstanceFB(
      const GeometryInstanceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateGeometryInstanceFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GeometryInstanceFB createGeometryInstanceFB(const GeometryInstanceCreateInfoFB& createInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateGeometryInstanceFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>>
  createGeometryInstanceUniqueFB(const GeometryInstanceCreateInfoFB& createInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateGeometryInstanceFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>> createGeometryInstanceUniqueFB(
      const GeometryInstanceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough

#ifdef XR_FB_render_model

  /*!
   * @brief xrEnumerateRenderModelPathsFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateRenderModelPathsFB(uint32_t pathCapacityInput, uint32_t* pathCountOutput,
                                     XrRenderModelPathInfoFB* paths,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<RenderModelPathInfoFB, Allocator>> enumerateRenderModelPathsToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<RenderModelPathInfoFB, Allocator>> enumerateRenderModelPathsToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<RenderModelPathInfoFB, Allocator> enumerateRenderModelPathsToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<RenderModelPathInfoFB, Allocator> enumerateRenderModelPathsToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_render_model

#ifdef XR_FB_render_model

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelPropertiesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesFB>
   *
   * @xrentity{xrGetRenderModelPropertiesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelPropertiesFB(Path path, RenderModelPropertiesFB& properties,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelPropertiesFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::RenderModelUnavailableFB, or an error
   * code if asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesFB>
   *
   * @xrentity{xrGetRenderModelPropertiesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelPropertiesFB(Path path, RenderModelPropertiesFB& properties,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_render_model

#ifdef XR_FB_render_model

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLoadRenderModelFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadRenderModelFB>
   *
   * @xrentity{xrLoadRenderModelFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result loadRenderModelFB(const RenderModelLoadInfoFB& info, RenderModelBufferFB& buffer,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLoadRenderModelFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::RenderModelUnavailableFB, or an error
   * code if asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadRenderModelFB>
   *
   * @xrentity{xrLoadRenderModelFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result loadRenderModelFB(const RenderModelLoadInfoFB& info, RenderModelBufferFB& buffer,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_render_model

#ifdef XR_VARJO_environment_depth_estimation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetEnvironmentDepthEstimationVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthEstimationVARJO>
   *
   * @xrentity{xrSetEnvironmentDepthEstimationVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setEnvironmentDepthEstimationVARJO(XrBool32 enabled,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetEnvironmentDepthEstimationVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthEstimationVARJO>
   *
   * @xrentity{xrSetEnvironmentDepthEstimationVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setEnvironmentDepthEstimationVARJO(XrBool32 enabled,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetEnvironmentDepthEstimationVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthEstimationVARJO>
   *
   * @xrentity{xrSetEnvironmentDepthEstimationVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setEnvironmentDepthEstimationVARJO(XrBool32 enabled,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_environment_depth_estimation

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetMarkerTrackingVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingVARJO>
   *
   * @xrentity{xrSetMarkerTrackingVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingVARJO(XrBool32 enabled,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetMarkerTrackingVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingVARJO>
   *
   * @xrentity{xrSetMarkerTrackingVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingVARJO(XrBool32 enabled,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetMarkerTrackingVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingVARJO>
   *
   * @xrentity{xrSetMarkerTrackingVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setMarkerTrackingVARJO(XrBool32 enabled,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetMarkerTrackingTimeoutVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingTimeoutVARJO>
   *
   * @xrentity{xrSetMarkerTrackingTimeoutVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetMarkerTrackingTimeoutVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingTimeoutVARJO>
   *
   * @xrentity{xrSetMarkerTrackingTimeoutVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetMarkerTrackingTimeoutVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingTimeoutVARJO>
   *
   * @xrentity{xrSetMarkerTrackingTimeoutVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetMarkerTrackingPredictionVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingPredictionVARJO>
   *
   * @xrentity{xrSetMarkerTrackingPredictionVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingPredictionVARJO(uint64_t markerId, XrBool32 enabled,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetMarkerTrackingPredictionVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingPredictionVARJO>
   *
   * @xrentity{xrSetMarkerTrackingPredictionVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingPredictionVARJO(uint64_t markerId, XrBool32 enabled,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetMarkerTrackingPredictionVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingPredictionVARJO>
   *
   * @xrentity{xrSetMarkerTrackingPredictionVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setMarkerTrackingPredictionVARJO(uint64_t markerId, XrBool32 enabled,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

  /*!
   * @brief xrGetMarkerSizeVARJO wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerSizeVARJO>
   *
   * @xrentity{xrGetMarkerSizeVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerSizeVARJO(uint64_t markerId, Extent2Df& size,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerSizeVARJO enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Extent2Df
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerSizeVARJO>
   *
   * @xrentity{xrGetMarkerSizeVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Extent2Df> getMarkerSizeVARJO(uint64_t markerId,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMarkerSizeVARJO enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Extent2Df
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerSizeVARJO>
   *
   * @xrentity{xrGetMarkerSizeVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Extent2Df getMarkerSizeVARJO(uint64_t markerId,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

  /*!
   * @brief xrCreateMarkerSpaceVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo, Space& space,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerSpaceVARJO enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerSpaceVARJO enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerSpaceVARJO wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createMarkerSpaceUniqueVARJO(
      const MarkerSpaceCreateInfoVARJO& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerSpaceVARJO wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createMarkerSpaceUniqueVARJO(
      const MarkerSpaceCreateInfoVARJO& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_MSFT_spatial_anchor_persistence

  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorStoreConnectionMSFT(
      SpatialAnchorStoreConnectionMSFT& spatialAnchorStore,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorStoreConnectionMSFT> createSpatialAnchorStoreConnectionMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorStoreConnectionMSFT createSpatialAnchorStoreConnectionMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorStoreConnectionUniqueMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorStoreConnectionUniqueMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorFromPersistedNameMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      SpatialAnchorMSFT& spatialAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorFromPersistedNameMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorFromPersistedNameMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorFromPersistedNameUniqueMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorFromPersistedNameUniqueMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_ALMALENCE_digital_lens_control

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetDigitalLensControlALMALENCE wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDigitalLensControlALMALENCE>
   *
   * @xrentity{xrSetDigitalLensControlALMALENCE}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& digitalLensControl,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetDigitalLensControlALMALENCE enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDigitalLensControlALMALENCE>
   *
   * @xrentity{xrSetDigitalLensControlALMALENCE}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& digitalLensControl,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetDigitalLensControlALMALENCE enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDigitalLensControlALMALENCE>
   *
   * @xrentity{xrSetDigitalLensControlALMALENCE}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setDigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& digitalLensControl,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ALMALENCE_digital_lens_control

  //! @}
private:
  XrSession val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSession) == sizeof(Session),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSession from an Session value.
 *
 * @found_by_adl
 * @see Session::get()
 * @relates Session
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSession get(Session const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrSession
 * handle in a Session (by reference).
 *
 * e.g.
 * ```
 * Session yourHandle;
 * auto result = d.xrCreateSession(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Session
 */
static OPENXR_HPP_INLINE XrSession* put(Session& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Session const& lhs,
                                                      Session const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Session const& lhs,
                                                      Session const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSession lhs, Session const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSession lhs, Session const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSession lhs, Session const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSession lhs, Session const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSession lhs, Session const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSession lhs, Session const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Session and nullptr: true if the handle is null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Session: true if the handle is null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Session const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Session and nullptr: true if the handle is not null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Session: true if the handle is not null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Session const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSpace without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpace>
 *
 * @xrentity{XrSpace}
 * @ingroup handles
 */
class Space {
public:
  using Type = Space;
  using RawHandleType = XrSpace;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Space() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpace type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Space(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Space(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpace
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpace type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Space value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Space value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpace manipulation
   * @{
   */
  //! Gets the raw XrSpace value.
  OPENXR_HPP_CONSTEXPR XrSpace get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Space yourHandle;
   * auto result = d.xrCreateSpace(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Space&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

  /*!
   * @brief xrLocateSpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpace(Space baseSpace, Time time, SpaceLocation& location,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpaceLocation
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpaceLocation> locateSpace(Space baseSpace, Time time,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpaceLocation
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpaceLocation locateSpace(Space baseSpace, Time time,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpace enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpace enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpace val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpace) == sizeof(Space), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpace from an Space value.
 *
 * @found_by_adl
 * @see Space::get()
 * @relates Space
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpace get(Space const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrSpace
 * handle in a Space (by reference).
 *
 * e.g.
 * ```
 * Space yourHandle;
 * auto result = d.xrCreateSpace(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Space
 */
static OPENXR_HPP_INLINE XrSpace* put(Space& h, bool clear = true) noexcept { return h.put(clear); }

//! @brief `<` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Space const& lhs, Space const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Space const& lhs, Space const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpace lhs, Space const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpace lhs, Space const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpace lhs, Space const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Space and nullptr: true if the handle is null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Space: true if the handle is null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Space const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Space and nullptr: true if the handle is not null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Space: true if the handle is not null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Space const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrAction without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAction>
 *
 * @xrentity{XrAction}
 * @ingroup handles
 */
class Action {
public:
  using Type = Action;
  using RawHandleType = XrAction;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Action() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrAction type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Action(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Action(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrAction
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrAction type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Action value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Action value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrAction manipulation
   * @{
   */
  //! Gets the raw XrAction value.
  OPENXR_HPP_CONSTEXPR XrAction get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Action yourHandle;
   * auto result = d.xrCreateAction(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Action&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyAction wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyAction enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyAction enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrAction val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrAction) == sizeof(Action), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrAction from an Action value.
 *
 * @found_by_adl
 * @see Action::get()
 * @relates Action
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrAction get(Action const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrAction
 * handle in a Action (by reference).
 *
 * e.g.
 * ```
 * Action yourHandle;
 * auto result = d.xrCreateAction(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Action
 */
static OPENXR_HPP_INLINE XrAction* put(Action& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Action const& lhs,
                                                      Action const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Action const& lhs,
                                                      Action const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrAction lhs, Action const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrAction lhs, Action const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrAction lhs, Action const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrAction lhs, Action const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrAction lhs, Action const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrAction lhs, Action const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Action and nullptr: true if the handle is null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Action: true if the handle is null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Action const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Action and nullptr: true if the handle is not null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Action: true if the handle is not null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Action const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSwapchain without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchain>
 *
 * @xrentity{XrSwapchain}
 * @ingroup handles
 */
class Swapchain {
public:
  using Type = Swapchain;
  using RawHandleType = XrSwapchain;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Swapchain() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSwapchain type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Swapchain(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Swapchain(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSwapchain
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSwapchain type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Swapchain value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Swapchain value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSwapchain manipulation
   * @{
   */
  //! Gets the raw XrSwapchain value.
  OPENXR_HPP_CONSTEXPR XrSwapchain get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Swapchain yourHandle;
   * auto result = d.xrCreateSwapchain(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Swapchain&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySwapchain wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySwapchain enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySwapchain enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateSwapchainImages wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainImages(uint32_t imageCapacityInput, uint32_t* imageCountOutput,
                                  XrSwapchainImageBaseHeader* images,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ResultItemType, Allocator>> enumerateSwapchainImagesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ResultItemType, Allocator>> enumerateSwapchainImagesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ResultItemType, Allocator> enumerateSwapchainImagesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ResultItemType, Allocator> enumerateSwapchainImagesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrAcquireSwapchainImage wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo, uint32_t* index,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAcquireSwapchainImage enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<uint32_t> acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAcquireSwapchainImage enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  uint32_t acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrWaitSwapchainImage wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitSwapchainImage>
   *
   * @xrentity{xrWaitSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrWaitSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::TimeoutExpired, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitSwapchainImage>
   *
   * @xrentity{xrWaitSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrReleaseSwapchainImage wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrReleaseSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrReleaseSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_FB_swapchain_update_state

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrUpdateSwapchainFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSwapchainFB>
   *
   * @xrentity{xrUpdateSwapchainFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateSwapchainFB(const XrSwapchainStateBaseHeaderFB* state,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateSwapchainFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSwapchainFB>
   *
   * @xrentity{xrUpdateSwapchainFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateSwapchainFB(const XrSwapchainStateBaseHeaderFB* state,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateSwapchainFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSwapchainFB>
   *
   * @xrentity{xrUpdateSwapchainFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void updateSwapchainFB(const XrSwapchainStateBaseHeaderFB* state,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_swapchain_update_state

  //! @}
private:
  XrSwapchain val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSwapchain) == sizeof(Swapchain),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSwapchain from an Swapchain value.
 *
 * @found_by_adl
 * @see Swapchain::get()
 * @relates Swapchain
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSwapchain get(Swapchain const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSwapchain handle in a Swapchain (by reference).
 *
 * e.g.
 * ```
 * Swapchain yourHandle;
 * auto result = d.xrCreateSwapchain(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Swapchain
 */
static OPENXR_HPP_INLINE XrSwapchain* put(Swapchain& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Swapchain const& lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Swapchain const& lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Swapchain const& lhs,
                                                      XrSwapchain rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSwapchain lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Swapchain const& lhs,
                                                      XrSwapchain rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSwapchain lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Swapchain and nullptr: true if the handle is null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Swapchain: true if the handle is null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Swapchain const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Swapchain and nullptr: true if the handle is not null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Swapchain: true if the handle is not null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Swapchain const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrActionSet without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSet>
 *
 * @xrentity{XrActionSet}
 * @ingroup handles
 */
class ActionSet {
public:
  using Type = ActionSet;
  using RawHandleType = XrActionSet;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR ActionSet() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrActionSet type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT ActionSet(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR ActionSet(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrActionSet
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrActionSet type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this ActionSet value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this ActionSet value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrActionSet manipulation
   * @{
   */
  //! Gets the raw XrActionSet value.
  OPENXR_HPP_CONSTEXPR XrActionSet get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * ActionSet yourHandle;
   * auto result = d.xrCreateActionSet(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(ActionSet&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyActionSet wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyActionSet enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyActionSet enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateAction wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createAction(const ActionCreateInfo& createInfo, Action& action,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Action> createAction(const ActionCreateInfo& createInfo,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Action createAction(const ActionCreateInfo& createInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAction wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>> createActionUnique(
      const ActionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAction wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Action, impl::RemoveRefConst<Dispatch>> createActionUnique(
      const ActionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrActionSet val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrActionSet) == sizeof(ActionSet),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrActionSet from an ActionSet value.
 *
 * @found_by_adl
 * @see ActionSet::get()
 * @relates ActionSet
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrActionSet get(ActionSet const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrActionSet handle in a ActionSet (by reference).
 *
 * e.g.
 * ```
 * ActionSet yourHandle;
 * auto result = d.xrCreateActionSet(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates ActionSet
 */
static OPENXR_HPP_INLINE XrActionSet* put(ActionSet& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ActionSet const& lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ActionSet const& lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ActionSet const& lhs,
                                                      XrActionSet rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrActionSet lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ActionSet const& lhs,
                                                      XrActionSet rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrActionSet lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between ActionSet and nullptr: true if the handle is null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and ActionSet: true if the handle is null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       ActionSet const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between ActionSet and nullptr: true if the handle is not null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and ActionSet: true if the handle is not null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       ActionSet const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

#ifdef XR_EXT_debug_utils

/*!
 * @brief Handle class - wrapping XrDebugUtilsMessengerEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerEXT>
 *
 * @xrentity{XrDebugUtilsMessengerEXT}
 * @ingroup handles
 */
class DebugUtilsMessengerEXT {
public:
  using Type = DebugUtilsMessengerEXT;
  using RawHandleType = XrDebugUtilsMessengerEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR DebugUtilsMessengerEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrDebugUtilsMessengerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT DebugUtilsMessengerEXT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR DebugUtilsMessengerEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrDebugUtilsMessengerEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrDebugUtilsMessengerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this DebugUtilsMessengerEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this DebugUtilsMessengerEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrDebugUtilsMessengerEXT manipulation
   * @{
   */
  //! Gets the raw XrDebugUtilsMessengerEXT value.
  OPENXR_HPP_CONSTEXPR XrDebugUtilsMessengerEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * DebugUtilsMessengerEXT yourHandle;
   * auto result = d.xrCreateDebugUtilsMessengerEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(DebugUtilsMessengerEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrDebugUtilsMessengerEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrDebugUtilsMessengerEXT) == sizeof(DebugUtilsMessengerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrDebugUtilsMessengerEXT from an DebugUtilsMessengerEXT
 * value.
 *
 * @found_by_adl
 * @see DebugUtilsMessengerEXT::get()
 * @relates DebugUtilsMessengerEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrDebugUtilsMessengerEXT
get(DebugUtilsMessengerEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrDebugUtilsMessengerEXT handle in a DebugUtilsMessengerEXT (by reference).
 *
 * e.g.
 * ```
 * DebugUtilsMessengerEXT yourHandle;
 * auto result = d.xrCreateDebugUtilsMessengerEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates DebugUtilsMessengerEXT
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerEXT* put(DebugUtilsMessengerEXT& h,
                                                       bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(DebugUtilsMessengerEXT const& lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(DebugUtilsMessengerEXT const& lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(DebugUtilsMessengerEXT const& lhs,
                                                      XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrDebugUtilsMessengerEXT lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(DebugUtilsMessengerEXT const& lhs,
                                                      XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrDebugUtilsMessengerEXT lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between DebugUtilsMessengerEXT and nullptr: true if the handle is
 * null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and DebugUtilsMessengerEXT: true if the handle is
 * null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between DebugUtilsMessengerEXT and nullptr: true if the handle is
 * not null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and DebugUtilsMessengerEXT: true if the handle is
 * not null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_spatial_anchor

/*!
 * @brief Handle class - wrapping XrSpatialAnchorMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorMSFT>
 *
 * @xrentity{XrSpatialAnchorMSFT}
 * @ingroup handles
 */
class SpatialAnchorMSFT {
public:
  using Type = SpatialAnchorMSFT;
  using RawHandleType = XrSpatialAnchorMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialAnchorMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialAnchorMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialAnchorMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialAnchorMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialAnchorMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialAnchorMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialAnchorMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialAnchorMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialAnchorMSFT manipulation
   * @{
   */
  //! Gets the raw XrSpatialAnchorMSFT value.
  OPENXR_HPP_CONSTEXPR XrSpatialAnchorMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialAnchorMSFT yourHandle;
   * auto result = d.xrCreateSpatialAnchorMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialAnchorMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialAnchorMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialAnchorMSFT) == sizeof(SpatialAnchorMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialAnchorMSFT from an SpatialAnchorMSFT value.
 *
 * @found_by_adl
 * @see SpatialAnchorMSFT::get()
 * @relates SpatialAnchorMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialAnchorMSFT
get(SpatialAnchorMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialAnchorMSFT handle in a SpatialAnchorMSFT (by reference).
 *
 * e.g.
 * ```
 * SpatialAnchorMSFT yourHandle;
 * auto result = d.xrCreateSpatialAnchorMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialAnchorMSFT
 */
static OPENXR_HPP_INLINE XrSpatialAnchorMSFT* put(SpatialAnchorMSFT& h,
                                                  bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorMSFT const& lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorMSFT const& lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorMSFT const& lhs,
                                                      XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialAnchorMSFT lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorMSFT const& lhs,
                                                      XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialAnchorMSFT lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialAnchorMSFT and nullptr: true if the handle is null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialAnchorMSFT: true if the handle is null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialAnchorMSFT and nullptr: true if the handle is not
 * null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialAnchorMSFT: true if the handle is not
 * null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_EXT_hand_tracking

/*!
 * @brief Handle class - wrapping XrHandTrackerEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerEXT>
 *
 * @xrentity{XrHandTrackerEXT}
 * @ingroup handles
 */
class HandTrackerEXT {
public:
  using Type = HandTrackerEXT;
  using RawHandleType = XrHandTrackerEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR HandTrackerEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrHandTrackerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT HandTrackerEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR HandTrackerEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrHandTrackerEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrHandTrackerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this HandTrackerEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this HandTrackerEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrHandTrackerEXT manipulation
   * @{
   */
  //! Gets the raw XrHandTrackerEXT value.
  OPENXR_HPP_CONSTEXPR XrHandTrackerEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * HandTrackerEXT yourHandle;
   * auto result = d.xrCreateHandTrackerEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(HandTrackerEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyHandTrackerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyHandTrackerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyHandTrackerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrLocateHandJointsEXT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                             HandJointLocationsEXT& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateHandJointsEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandJointLocationsEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandJointLocationsEXT> locateHandJointsEXT(
      const HandJointsLocateInfoEXT& locateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateHandJointsEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandJointLocationsEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandJointLocationsEXT locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_MSFT_hand_tracking_mesh

  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo, Space& space,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandMeshSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandMeshSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createHandMeshSpaceUniqueMSFT(
      const HandMeshSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createHandMeshSpaceUniqueMSFT(
      const HandMeshSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh

  /*!
   * @brief xrUpdateHandMeshMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo, HandMeshMSFT& handMesh,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateHandMeshMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandMeshMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandMeshMSFT> updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateHandMeshMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandMeshMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandMeshMSFT updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_mesh

  /*!
   * @brief xrGetHandMeshFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetHandMeshFB>
   *
   * @xrentity{xrGetHandMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getHandMeshFB(HandTrackingMeshFB& mesh,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetHandMeshFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandTrackingMeshFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetHandMeshFB>
   *
   * @xrentity{xrGetHandMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandTrackingMeshFB> getHandMeshFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetHandMeshFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandTrackingMeshFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetHandMeshFB>
   *
   * @xrentity{xrGetHandMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandTrackingMeshFB getHandMeshFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_hand_tracking_mesh

  //! @}
private:
  XrHandTrackerEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrHandTrackerEXT) == sizeof(HandTrackerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrHandTrackerEXT from an HandTrackerEXT value.
 *
 * @found_by_adl
 * @see HandTrackerEXT::get()
 * @relates HandTrackerEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrHandTrackerEXT get(HandTrackerEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrHandTrackerEXT handle in a HandTrackerEXT (by reference).
 *
 * e.g.
 * ```
 * HandTrackerEXT yourHandle;
 * auto result = d.xrCreateHandTrackerEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates HandTrackerEXT
 */
static OPENXR_HPP_INLINE XrHandTrackerEXT* put(HandTrackerEXT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(HandTrackerEXT const& lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(HandTrackerEXT const& lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(HandTrackerEXT const& lhs,
                                                      XrHandTrackerEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrHandTrackerEXT lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(HandTrackerEXT const& lhs,
                                                      XrHandTrackerEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrHandTrackerEXT lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between HandTrackerEXT and nullptr: true if the handle is null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and HandTrackerEXT: true if the handle is null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       HandTrackerEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between HandTrackerEXT and nullptr: true if the handle is not null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and HandTrackerEXT: true if the handle is not null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       HandTrackerEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_scene_understanding

/*!
 * @brief Handle class - wrapping XrSceneObserverMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObserverMSFT>
 *
 * @xrentity{XrSceneObserverMSFT}
 * @ingroup handles
 */
class SceneObserverMSFT {
public:
  using Type = SceneObserverMSFT;
  using RawHandleType = XrSceneObserverMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SceneObserverMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSceneObserverMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SceneObserverMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SceneObserverMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSceneObserverMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSceneObserverMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SceneObserverMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SceneObserverMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSceneObserverMSFT manipulation
   * @{
   */
  //! Gets the raw XrSceneObserverMSFT value.
  OPENXR_HPP_CONSTEXPR XrSceneObserverMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SceneObserverMSFT yourHandle;
   * auto result = d.xrCreateSceneObserverMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SceneObserverMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySceneObserverMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneObserverMSFT>
   *
   * @xrentity{xrDestroySceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySceneObserverMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneObserverMSFT>
   *
   * @xrentity{xrDestroySceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySceneObserverMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneObserverMSFT>
   *
   * @xrentity{xrDestroySceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSceneMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSceneMSFT(const SceneCreateInfoMSFT& createInfo, SceneMSFT& scene,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneMSFT> createSceneMSFT(const SceneCreateInfoMSFT& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneMSFT createSceneMSFT(const SceneCreateInfoMSFT& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>>> createSceneUniqueMSFT(
      const SceneCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>> createSceneUniqueMSFT(
      const SceneCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrComputeNewSceneMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrComputeNewSceneMSFT>
   *
   * @xrentity{xrComputeNewSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result computeNewSceneMSFT(const NewSceneComputeInfoMSFT& computeInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrComputeNewSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrComputeNewSceneMSFT>
   *
   * @xrentity{xrComputeNewSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result computeNewSceneMSFT(const NewSceneComputeInfoMSFT& computeInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrComputeNewSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrComputeNewSceneMSFT>
   *
   * @xrentity{xrComputeNewSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void computeNewSceneMSFT(const NewSceneComputeInfoMSFT& computeInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_MSFT_scene_understanding_serialization

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDeserializeSceneMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeserializeSceneMSFT>
   *
   * @xrentity{xrDeserializeSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result deserializeSceneMSFT(const SceneDeserializeInfoMSFT& deserializeInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDeserializeSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeserializeSceneMSFT>
   *
   * @xrentity{xrDeserializeSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result deserializeSceneMSFT(const SceneDeserializeInfoMSFT& deserializeInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDeserializeSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeserializeSceneMSFT>
   *
   * @xrentity{xrDeserializeSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void deserializeSceneMSFT(const SceneDeserializeInfoMSFT& deserializeInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding_serialization

  //! @}
private:
  XrSceneObserverMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSceneObserverMSFT) == sizeof(SceneObserverMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSceneObserverMSFT from an SceneObserverMSFT value.
 *
 * @found_by_adl
 * @see SceneObserverMSFT::get()
 * @relates SceneObserverMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSceneObserverMSFT
get(SceneObserverMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSceneObserverMSFT handle in a SceneObserverMSFT (by reference).
 *
 * e.g.
 * ```
 * SceneObserverMSFT yourHandle;
 * auto result = d.xrCreateSceneObserverMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SceneObserverMSFT
 */
static OPENXR_HPP_INLINE XrSceneObserverMSFT* put(SceneObserverMSFT& h,
                                                  bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneObserverMSFT const& lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneObserverMSFT const& lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneObserverMSFT const& lhs,
                                                      XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSceneObserverMSFT lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneObserverMSFT const& lhs,
                                                      XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSceneObserverMSFT lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SceneObserverMSFT and nullptr: true if the handle is null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneObserverMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SceneObserverMSFT: true if the handle is null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SceneObserverMSFT and nullptr: true if the handle is not
 * null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneObserverMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SceneObserverMSFT: true if the handle is not
 * null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

/*!
 * @brief Handle class - wrapping XrSceneMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMSFT>
 *
 * @xrentity{XrSceneMSFT}
 * @ingroup handles
 */
class SceneMSFT {
public:
  using Type = SceneMSFT;
  using RawHandleType = XrSceneMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SceneMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSceneMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SceneMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SceneMSFT(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSceneMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSceneMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SceneMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SceneMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSceneMSFT manipulation
   * @{
   */
  //! Gets the raw XrSceneMSFT value.
  OPENXR_HPP_CONSTEXPR XrSceneMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SceneMSFT yourHandle;
   * auto result = d.xrCreateSceneMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SceneMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySceneMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneMSFT>
   *
   * @xrentity{xrDestroySceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneMSFT>
   *
   * @xrentity{xrDestroySceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneMSFT>
   *
   * @xrentity{xrDestroySceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSceneComponentsMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComponentsMSFT>
   *
   * @xrentity{xrGetSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneComponentsMSFT(const SceneComponentsGetInfoMSFT& getInfo,
                                SceneComponentsMSFT& components,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSceneComponentsMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneComponentsMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComponentsMSFT>
   *
   * @xrentity{xrGetSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneComponentsMSFT> getSceneComponentsMSFT(
      const SceneComponentsGetInfoMSFT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSceneComponentsMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneComponentsMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComponentsMSFT>
   *
   * @xrentity{xrGetSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneComponentsMSFT getSceneComponentsMSFT(const SceneComponentsGetInfoMSFT& getInfo,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrLocateSceneComponentsMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSceneComponentsMSFT>
   *
   * @xrentity{xrLocateSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSceneComponentsMSFT(const SceneComponentsLocateInfoMSFT& locateInfo,
                                   SceneComponentLocationsMSFT& locations,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSceneComponentsMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneComponentLocationsMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSceneComponentsMSFT>
   *
   * @xrentity{xrLocateSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneComponentLocationsMSFT> locateSceneComponentsMSFT(
      const SceneComponentsLocateInfoMSFT& locateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSceneComponentsMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneComponentLocationsMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSceneComponentsMSFT>
   *
   * @xrentity{xrLocateSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneComponentLocationsMSFT locateSceneComponentsMSFT(
      const SceneComponentsLocateInfoMSFT& locateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSceneMeshBuffersMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMeshBuffersMSFT>
   *
   * @xrentity{xrGetSceneMeshBuffersMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneMeshBuffersMSFT(const SceneMeshBuffersGetInfoMSFT& getInfo,
                                 SceneMeshBuffersMSFT& buffers,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSceneMeshBuffersMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneMeshBuffersMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMeshBuffersMSFT>
   *
   * @xrentity{xrGetSceneMeshBuffersMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneMeshBuffersMSFT> getSceneMeshBuffersMSFT(
      const SceneMeshBuffersGetInfoMSFT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSceneMeshBuffersMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneMeshBuffersMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMeshBuffersMSFT>
   *
   * @xrentity{xrGetSceneMeshBuffersMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneMeshBuffersMSFT getSceneMeshBuffersMSFT(const SceneMeshBuffersGetInfoMSFT& getInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_MSFT_scene_understanding_serialization

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSerializedSceneFragmentDataMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSerializedSceneFragmentDataMSFT>
   *
   * @xrentity{xrGetSerializedSceneFragmentDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSerializedSceneFragmentDataMSFT(const SerializedSceneFragmentDataGetInfoMSFT& getInfo,
                                            uint32_t countInput, uint32_t* readOutput,
                                            uint8_t* buffer,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSerializedSceneFragmentDataMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSerializedSceneFragmentDataMSFT>
   *
   * @xrentity{xrGetSerializedSceneFragmentDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSerializedSceneFragmentDataMSFT(const SerializedSceneFragmentDataGetInfoMSFT& getInfo,
                                            uint32_t countInput, uint32_t* readOutput,
                                            uint8_t* buffer,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSerializedSceneFragmentDataMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSerializedSceneFragmentDataMSFT>
   *
   * @xrentity{xrGetSerializedSceneFragmentDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSerializedSceneFragmentDataMSFT(const SerializedSceneFragmentDataGetInfoMSFT& getInfo,
                                          uint32_t countInput, uint32_t* readOutput,
                                          uint8_t* buffer,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding_serialization

  //! @}
private:
  XrSceneMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSceneMSFT) == sizeof(SceneMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSceneMSFT from an SceneMSFT value.
 *
 * @found_by_adl
 * @see SceneMSFT::get()
 * @relates SceneMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSceneMSFT get(SceneMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSceneMSFT handle in a SceneMSFT (by reference).
 *
 * e.g.
 * ```
 * SceneMSFT yourHandle;
 * auto result = d.xrCreateSceneMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SceneMSFT
 */
static OPENXR_HPP_INLINE XrSceneMSFT* put(SceneMSFT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneMSFT const& lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneMSFT const& lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneMSFT const& lhs,
                                                      XrSceneMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSceneMSFT lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneMSFT const& lhs,
                                                      XrSceneMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSceneMSFT lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SceneMSFT and nullptr: true if the handle is null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SceneMSFT: true if the handle is null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SceneMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SceneMSFT and nullptr: true if the handle is not null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SceneMSFT: true if the handle is not null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SceneMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_HTC_facial_tracking

/*!
 * @brief Handle class - wrapping XrFacialTrackerHTC without indicating ownership.
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackerHTC>
 *
 * @xrentity{XrFacialTrackerHTC}
 * @ingroup handles
 */
class FacialTrackerHTC {
public:
  using Type = FacialTrackerHTC;
  using RawHandleType = XrFacialTrackerHTC;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FacialTrackerHTC() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFacialTrackerHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FacialTrackerHTC(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FacialTrackerHTC(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFacialTrackerHTC
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFacialTrackerHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FacialTrackerHTC value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FacialTrackerHTC value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFacialTrackerHTC manipulation
   * @{
   */
  //! Gets the raw XrFacialTrackerHTC value.
  OPENXR_HPP_CONSTEXPR XrFacialTrackerHTC get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FacialTrackerHTC yourHandle;
   * auto result = d.xrCreateFacialTrackerHTC(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FacialTrackerHTC&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFacialTrackerHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialTrackerHTC>
   *
   * @xrentity{xrDestroyFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFacialTrackerHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialTrackerHTC>
   *
   * @xrentity{xrDestroyFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFacialTrackerHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialTrackerHTC>
   *
   * @xrentity{xrDestroyFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetFacialExpressionsHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionsHTC>
   *
   * @xrentity{xrGetFacialExpressionsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFacialExpressionsHTC(FacialExpressionsHTC& facialExpressions,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetFacialExpressionsHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FacialExpressionsHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionsHTC>
   *
   * @xrentity{xrGetFacialExpressionsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FacialExpressionsHTC> getFacialExpressionsHTC(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetFacialExpressionsHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FacialExpressionsHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionsHTC>
   *
   * @xrentity{xrGetFacialExpressionsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FacialExpressionsHTC getFacialExpressionsHTC(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFacialTrackerHTC val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFacialTrackerHTC) == sizeof(FacialTrackerHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFacialTrackerHTC from an FacialTrackerHTC value.
 *
 * @found_by_adl
 * @see FacialTrackerHTC::get()
 * @relates FacialTrackerHTC
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFacialTrackerHTC get(FacialTrackerHTC const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFacialTrackerHTC handle in a FacialTrackerHTC (by reference).
 *
 * e.g.
 * ```
 * FacialTrackerHTC yourHandle;
 * auto result = d.xrCreateFacialTrackerHTC(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FacialTrackerHTC
 */
static OPENXR_HPP_INLINE XrFacialTrackerHTC* put(FacialTrackerHTC& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FacialTrackerHTC const& lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FacialTrackerHTC const& lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FacialTrackerHTC const& lhs,
                                                      XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrFacialTrackerHTC lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FacialTrackerHTC const& lhs,
                                                      XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrFacialTrackerHTC lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FacialTrackerHTC and nullptr: true if the handle is null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialTrackerHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FacialTrackerHTC: true if the handle is null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FacialTrackerHTC and nullptr: true if the handle is not
 * null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialTrackerHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FacialTrackerHTC: true if the handle is not
 * null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_foveation

/*!
 * @brief Handle class - wrapping XrFoveationProfileFB without indicating ownership.
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationProfileFB>
 *
 * @xrentity{XrFoveationProfileFB}
 * @ingroup handles
 */
class FoveationProfileFB {
public:
  using Type = FoveationProfileFB;
  using RawHandleType = XrFoveationProfileFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FoveationProfileFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFoveationProfileFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FoveationProfileFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FoveationProfileFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFoveationProfileFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFoveationProfileFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FoveationProfileFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FoveationProfileFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFoveationProfileFB manipulation
   * @{
   */
  //! Gets the raw XrFoveationProfileFB value.
  OPENXR_HPP_CONSTEXPR XrFoveationProfileFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FoveationProfileFB yourHandle;
   * auto result = d.xrCreateFoveationProfileFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FoveationProfileFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFoveationProfileFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFoveationProfileFB>
   *
   * @xrentity{xrDestroyFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFoveationProfileFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFoveationProfileFB>
   *
   * @xrentity{xrDestroyFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFoveationProfileFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFoveationProfileFB>
   *
   * @xrentity{xrDestroyFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFoveationProfileFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFoveationProfileFB) == sizeof(FoveationProfileFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFoveationProfileFB from an FoveationProfileFB value.
 *
 * @found_by_adl
 * @see FoveationProfileFB::get()
 * @relates FoveationProfileFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFoveationProfileFB
get(FoveationProfileFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFoveationProfileFB handle in a FoveationProfileFB (by reference).
 *
 * e.g.
 * ```
 * FoveationProfileFB yourHandle;
 * auto result = d.xrCreateFoveationProfileFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FoveationProfileFB
 */
static OPENXR_HPP_INLINE XrFoveationProfileFB* put(FoveationProfileFB& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FoveationProfileFB const& lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FoveationProfileFB const& lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FoveationProfileFB const& lhs,
                                                      XrFoveationProfileFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrFoveationProfileFB lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FoveationProfileFB const& lhs,
                                                      XrFoveationProfileFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrFoveationProfileFB lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FoveationProfileFB and nullptr: true if the handle is null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FoveationProfileFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FoveationProfileFB: true if the handle is null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       FoveationProfileFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FoveationProfileFB and nullptr: true if the handle is not
 * null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FoveationProfileFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FoveationProfileFB: true if the handle is not
 * null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       FoveationProfileFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_foveation

#ifdef XR_FB_triangle_mesh

/*!
 * @brief Handle class - wrapping XrTriangleMeshFB without indicating ownership.
 *
 * Provided by the `XR_FB_triangle_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTriangleMeshFB>
 *
 * @xrentity{XrTriangleMeshFB}
 * @ingroup handles
 */
class TriangleMeshFB {
public:
  using Type = TriangleMeshFB;
  using RawHandleType = XrTriangleMeshFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR TriangleMeshFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrTriangleMeshFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT TriangleMeshFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR TriangleMeshFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrTriangleMeshFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrTriangleMeshFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this TriangleMeshFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this TriangleMeshFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrTriangleMeshFB manipulation
   * @{
   */
  //! Gets the raw XrTriangleMeshFB value.
  OPENXR_HPP_CONSTEXPR XrTriangleMeshFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * TriangleMeshFB yourHandle;
   * auto result = d.xrCreateTriangleMeshFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(TriangleMeshFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyTriangleMeshFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyTriangleMeshFB>
   *
   * @xrentity{xrDestroyTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyTriangleMeshFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyTriangleMeshFB>
   *
   * @xrentity{xrDestroyTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyTriangleMeshFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyTriangleMeshFB>
   *
   * @xrentity{xrDestroyTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshGetVertexBufferFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetVertexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetVertexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetVertexBufferFB(XrVector3f** outVertexBuffer,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshGetVertexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetVertexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetVertexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetVertexBufferFB(XrVector3f** outVertexBuffer,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshGetVertexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetVertexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetVertexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshGetVertexBufferFB(XrVector3f** outVertexBuffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshGetIndexBufferFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetIndexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetIndexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetIndexBufferFB(uint32_t** outIndexBuffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshGetIndexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetIndexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetIndexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetIndexBufferFB(uint32_t** outIndexBuffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshGetIndexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetIndexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetIndexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshGetIndexBufferFB(uint32_t** outIndexBuffer,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshBeginUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshBeginUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshBeginUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshBeginUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshBeginUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshBeginUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshEndUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndUpdateFB(uint32_t vertexCount, uint32_t triangleCount,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshEndUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndUpdateFB(uint32_t vertexCount, uint32_t triangleCount,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshEndUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshEndUpdateFB(uint32_t vertexCount, uint32_t triangleCount,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrTriangleMeshBeginVertexBufferUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshBeginVertexBufferUpdateFB(
      uint32_t* outVertexCount, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshBeginVertexBufferUpdateFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<uint32_t> triangleMeshBeginVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshBeginVertexBufferUpdateFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  uint32_t triangleMeshBeginVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshEndVertexBufferUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshEndVertexBufferUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshEndVertexBufferUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshEndVertexBufferUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrTriangleMeshFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrTriangleMeshFB) == sizeof(TriangleMeshFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrTriangleMeshFB from an TriangleMeshFB value.
 *
 * @found_by_adl
 * @see TriangleMeshFB::get()
 * @relates TriangleMeshFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrTriangleMeshFB get(TriangleMeshFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrTriangleMeshFB handle in a TriangleMeshFB (by reference).
 *
 * e.g.
 * ```
 * TriangleMeshFB yourHandle;
 * auto result = d.xrCreateTriangleMeshFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates TriangleMeshFB
 */
static OPENXR_HPP_INLINE XrTriangleMeshFB* put(TriangleMeshFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(TriangleMeshFB const& lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(TriangleMeshFB const& lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(TriangleMeshFB const& lhs,
                                                      XrTriangleMeshFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrTriangleMeshFB lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(TriangleMeshFB const& lhs,
                                                      XrTriangleMeshFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrTriangleMeshFB lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between TriangleMeshFB and nullptr: true if the handle is null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(TriangleMeshFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and TriangleMeshFB: true if the handle is null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       TriangleMeshFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between TriangleMeshFB and nullptr: true if the handle is not null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(TriangleMeshFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and TriangleMeshFB: true if the handle is not null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       TriangleMeshFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough

/*!
 * @brief Handle class - wrapping XrPassthroughFB without indicating ownership.
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughFB>
 *
 * @xrentity{XrPassthroughFB}
 * @ingroup handles
 */
class PassthroughFB {
public:
  using Type = PassthroughFB;
  using RawHandleType = XrPassthroughFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PassthroughFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPassthroughFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PassthroughFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PassthroughFB(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPassthroughFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPassthroughFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PassthroughFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PassthroughFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPassthroughFB manipulation
   * @{
   */
  //! Gets the raw XrPassthroughFB value.
  OPENXR_HPP_CONSTEXPR XrPassthroughFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PassthroughFB yourHandle;
   * auto result = d.xrCreatePassthroughFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PassthroughFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPassthroughFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughFB>
   *
   * @xrentity{xrDestroyPassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPassthroughFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughFB>
   *
   * @xrentity{xrDestroyPassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPassthroughFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughFB>
   *
   * @xrentity{xrDestroyPassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughStartFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughStartFB>
   *
   * @xrentity{xrPassthroughStartFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughStartFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughStartFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughStartFB>
   *
   * @xrentity{xrPassthroughStartFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughStartFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughStartFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughStartFB>
   *
   * @xrentity{xrPassthroughStartFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughStartFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughPauseFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughPauseFB>
   *
   * @xrentity{xrPassthroughPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughPauseFB>
   *
   * @xrentity{xrPassthroughPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughPauseFB>
   *
   * @xrentity{xrPassthroughPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrPassthroughFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPassthroughFB) == sizeof(PassthroughFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPassthroughFB from an PassthroughFB value.
 *
 * @found_by_adl
 * @see PassthroughFB::get()
 * @relates PassthroughFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPassthroughFB get(PassthroughFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPassthroughFB handle in a PassthroughFB (by reference).
 *
 * e.g.
 * ```
 * PassthroughFB yourHandle;
 * auto result = d.xrCreatePassthroughFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PassthroughFB
 */
static OPENXR_HPP_INLINE XrPassthroughFB* put(PassthroughFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughFB const& lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughFB const& lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughFB const& lhs,
                                                      XrPassthroughFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPassthroughFB lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughFB const& lhs,
                                                      XrPassthroughFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPassthroughFB lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PassthroughFB and nullptr: true if the handle is null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PassthroughFB: true if the handle is null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       PassthroughFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PassthroughFB and nullptr: true if the handle is not null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PassthroughFB: true if the handle is not null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       PassthroughFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

/*!
 * @brief Handle class - wrapping XrPassthroughLayerFB without indicating ownership.
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerFB>
 *
 * @xrentity{XrPassthroughLayerFB}
 * @ingroup handles
 */
class PassthroughLayerFB {
public:
  using Type = PassthroughLayerFB;
  using RawHandleType = XrPassthroughLayerFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PassthroughLayerFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPassthroughLayerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PassthroughLayerFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PassthroughLayerFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPassthroughLayerFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPassthroughLayerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PassthroughLayerFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PassthroughLayerFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPassthroughLayerFB manipulation
   * @{
   */
  //! Gets the raw XrPassthroughLayerFB value.
  OPENXR_HPP_CONSTEXPR XrPassthroughLayerFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PassthroughLayerFB yourHandle;
   * auto result = d.xrCreatePassthroughLayerFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PassthroughLayerFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPassthroughLayerFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughLayerFB>
   *
   * @xrentity{xrDestroyPassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPassthroughLayerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughLayerFB>
   *
   * @xrentity{xrDestroyPassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPassthroughLayerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughLayerFB>
   *
   * @xrentity{xrDestroyPassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerPauseFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerPauseFB>
   *
   * @xrentity{xrPassthroughLayerPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerPauseFB>
   *
   * @xrentity{xrPassthroughLayerPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerPauseFB>
   *
   * @xrentity{xrPassthroughLayerPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerResumeFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerResumeFB>
   *
   * @xrentity{xrPassthroughLayerResumeFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerResumeFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerResumeFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerResumeFB>
   *
   * @xrentity{xrPassthroughLayerResumeFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerResumeFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerResumeFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerResumeFB>
   *
   * @xrentity{xrPassthroughLayerResumeFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerResumeFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerSetStyleFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetStyleFB>
   *
   * @xrentity{xrPassthroughLayerSetStyleFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetStyleFB(const PassthroughStyleFB& style,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerSetStyleFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetStyleFB>
   *
   * @xrentity{xrPassthroughLayerSetStyleFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetStyleFB(const PassthroughStyleFB& style,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerSetStyleFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetStyleFB>
   *
   * @xrentity{xrPassthroughLayerSetStyleFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerSetStyleFB(const PassthroughStyleFB& style,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_FB_passthrough_keyboard_hands

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerSetKeyboardHandsIntensityFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetKeyboardHandsIntensityFB>
   *
   * @xrentity{xrPassthroughLayerSetKeyboardHandsIntensityFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetKeyboardHandsIntensityFB(
      const PassthroughKeyboardHandsIntensityFB& intensity,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerSetKeyboardHandsIntensityFB enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetKeyboardHandsIntensityFB>
   *
   * @xrentity{xrPassthroughLayerSetKeyboardHandsIntensityFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetKeyboardHandsIntensityFB(
      const PassthroughKeyboardHandsIntensityFB& intensity,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerSetKeyboardHandsIntensityFB enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetKeyboardHandsIntensityFB>
   *
   * @xrentity{xrPassthroughLayerSetKeyboardHandsIntensityFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerSetKeyboardHandsIntensityFB(
      const PassthroughKeyboardHandsIntensityFB& intensity,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough_keyboard_hands

  //! @}
private:
  XrPassthroughLayerFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPassthroughLayerFB) == sizeof(PassthroughLayerFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPassthroughLayerFB from an PassthroughLayerFB value.
 *
 * @found_by_adl
 * @see PassthroughLayerFB::get()
 * @relates PassthroughLayerFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPassthroughLayerFB
get(PassthroughLayerFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPassthroughLayerFB handle in a PassthroughLayerFB (by reference).
 *
 * e.g.
 * ```
 * PassthroughLayerFB yourHandle;
 * auto result = d.xrCreatePassthroughLayerFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PassthroughLayerFB
 */
static OPENXR_HPP_INLINE XrPassthroughLayerFB* put(PassthroughLayerFB& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughLayerFB const& lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughLayerFB const& lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughLayerFB const& lhs,
                                                      XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPassthroughLayerFB lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughLayerFB const& lhs,
                                                      XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPassthroughLayerFB lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PassthroughLayerFB and nullptr: true if the handle is null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughLayerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PassthroughLayerFB: true if the handle is null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PassthroughLayerFB and nullptr: true if the handle is not
 * null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughLayerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PassthroughLayerFB: true if the handle is not
 * null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

/*!
 * @brief Handle class - wrapping XrGeometryInstanceFB without indicating ownership.
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceFB>
 *
 * @xrentity{XrGeometryInstanceFB}
 * @ingroup handles
 */
class GeometryInstanceFB {
public:
  using Type = GeometryInstanceFB;
  using RawHandleType = XrGeometryInstanceFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR GeometryInstanceFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrGeometryInstanceFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT GeometryInstanceFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR GeometryInstanceFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrGeometryInstanceFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrGeometryInstanceFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this GeometryInstanceFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this GeometryInstanceFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrGeometryInstanceFB manipulation
   * @{
   */
  //! Gets the raw XrGeometryInstanceFB value.
  OPENXR_HPP_CONSTEXPR XrGeometryInstanceFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * GeometryInstanceFB yourHandle;
   * auto result = d.xrCreateGeometryInstanceFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(GeometryInstanceFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyGeometryInstanceFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyGeometryInstanceFB>
   *
   * @xrentity{xrDestroyGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyGeometryInstanceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyGeometryInstanceFB>
   *
   * @xrentity{xrDestroyGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyGeometryInstanceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyGeometryInstanceFB>
   *
   * @xrentity{xrDestroyGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGeometryInstanceSetTransformFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGeometryInstanceSetTransformFB>
   *
   * @xrentity{xrGeometryInstanceSetTransformFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result geometryInstanceSetTransformFB(const GeometryInstanceTransformFB& transformation,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGeometryInstanceSetTransformFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGeometryInstanceSetTransformFB>
   *
   * @xrentity{xrGeometryInstanceSetTransformFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result geometryInstanceSetTransformFB(const GeometryInstanceTransformFB& transformation,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGeometryInstanceSetTransformFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGeometryInstanceSetTransformFB>
   *
   * @xrentity{xrGeometryInstanceSetTransformFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void geometryInstanceSetTransformFB(const GeometryInstanceTransformFB& transformation,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrGeometryInstanceFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrGeometryInstanceFB) == sizeof(GeometryInstanceFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrGeometryInstanceFB from an GeometryInstanceFB value.
 *
 * @found_by_adl
 * @see GeometryInstanceFB::get()
 * @relates GeometryInstanceFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrGeometryInstanceFB
get(GeometryInstanceFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrGeometryInstanceFB handle in a GeometryInstanceFB (by reference).
 *
 * e.g.
 * ```
 * GeometryInstanceFB yourHandle;
 * auto result = d.xrCreateGeometryInstanceFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates GeometryInstanceFB
 */
static OPENXR_HPP_INLINE XrGeometryInstanceFB* put(GeometryInstanceFB& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(GeometryInstanceFB const& lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(GeometryInstanceFB const& lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(GeometryInstanceFB const& lhs,
                                                      XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrGeometryInstanceFB lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(GeometryInstanceFB const& lhs,
                                                      XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrGeometryInstanceFB lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between GeometryInstanceFB and nullptr: true if the handle is null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(GeometryInstanceFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and GeometryInstanceFB: true if the handle is null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between GeometryInstanceFB and nullptr: true if the handle is not
 * null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(GeometryInstanceFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and GeometryInstanceFB: true if the handle is not
 * null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_passthrough

#ifdef XR_MSFT_spatial_anchor_persistence

/*!
 * @brief Handle class - wrapping XrSpatialAnchorStoreConnectionMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorStoreConnectionMSFT>
 *
 * @xrentity{XrSpatialAnchorStoreConnectionMSFT}
 * @ingroup handles
 */
class SpatialAnchorStoreConnectionMSFT {
public:
  using Type = SpatialAnchorStoreConnectionMSFT;
  using RawHandleType = XrSpatialAnchorStoreConnectionMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialAnchorStoreConnectionMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialAnchorStoreConnectionMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialAnchorStoreConnectionMSFT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialAnchorStoreConnectionMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialAnchorStoreConnectionMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialAnchorStoreConnectionMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialAnchorStoreConnectionMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialAnchorStoreConnectionMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialAnchorStoreConnectionMSFT manipulation
   * @{
   */
  //! Gets the raw XrSpatialAnchorStoreConnectionMSFT value.
  OPENXR_HPP_CONSTEXPR XrSpatialAnchorStoreConnectionMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialAnchorStoreConnectionMSFT yourHandle;
   * auto result = d.xrCreateSpatialAnchorStoreConnectionMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialAnchorStoreConnectionMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialAnchorStoreConnectionMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialAnchorStoreConnectionMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDestroySpatialAnchorStoreConnectionMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPersistSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorMSFT>
   *
   * @xrentity{xrPersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorMSFT>
   *
   * @xrentity{xrPersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorMSFT>
   *
   * @xrentity{xrPersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void persistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumeratePersistedSpatialAnchorNamesMSFT(
      uint32_t spatialAnchorNamesCapacityInput, uint32_t* spatialAnchorNamesCountOutput,
      XrSpatialAnchorPersistenceNameMSFT* persistedAnchorNames,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrUnpersistSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorMSFT>
   *
   * @xrentity{xrUnpersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUnpersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorMSFT>
   *
   * @xrentity{xrUnpersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUnpersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorMSFT>
   *
   * @xrentity{xrUnpersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void unpersistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrClearSpatialAnchorStoreMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrClearSpatialAnchorStoreMSFT>
   *
   * @xrentity{xrClearSpatialAnchorStoreMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result clearSpatialAnchorStoreMSFT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrClearSpatialAnchorStoreMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrClearSpatialAnchorStoreMSFT>
   *
   * @xrentity{xrClearSpatialAnchorStoreMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result clearSpatialAnchorStoreMSFT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrClearSpatialAnchorStoreMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrClearSpatialAnchorStoreMSFT>
   *
   * @xrentity{xrClearSpatialAnchorStoreMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void clearSpatialAnchorStoreMSFT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialAnchorStoreConnectionMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialAnchorStoreConnectionMSFT) ==
                  sizeof(SpatialAnchorStoreConnectionMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialAnchorStoreConnectionMSFT from an
 * SpatialAnchorStoreConnectionMSFT value.
 *
 * @found_by_adl
 * @see SpatialAnchorStoreConnectionMSFT::get()
 * @relates SpatialAnchorStoreConnectionMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialAnchorStoreConnectionMSFT
get(SpatialAnchorStoreConnectionMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialAnchorStoreConnectionMSFT handle in a SpatialAnchorStoreConnectionMSFT (by reference).
 *
 * e.g.
 * ```
 * SpatialAnchorStoreConnectionMSFT yourHandle;
 * auto result = d.xrCreateSpatialAnchorStoreConnectionMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialAnchorStoreConnectionMSFT
 */
static OPENXR_HPP_INLINE XrSpatialAnchorStoreConnectionMSFT* put(
    SpatialAnchorStoreConnectionMSFT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialAnchorStoreConnectionMSFT and nullptr: true if the
 * handle is null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorStoreConnectionMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialAnchorStoreConnectionMSFT: true if the
 * handle is null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialAnchorStoreConnectionMSFT and nullptr: true if the
 * handle is not null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorStoreConnectionMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialAnchorStoreConnectionMSFT: true if the
 * handle is not null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_spatial_anchor_persistence

/*!
 * @defgroup api_free_functions OpenXR API free functions
 * @ingroup wrappers
 *
 * Equivalent to the method wrappers in the handle classes,
 * but for the few functions that don't take (or don't require)
 * a handle as their first argument.
 * @{
 */
// Declarations - implementations are out of line.

/*!
 * @brief xrEnumerateApiLayerProperties wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result enumerateApiLayerProperties(uint32_t propertyCapacityInput, uint32_t* propertyCountOutput,
                                   XrApiLayerProperties* properties,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined. Performs two-call idiom. Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector(
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d);

#else
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 * Performs two-call idiom.
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief xrEnumerateInstanceExtensionProperties wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result enumerateInstanceExtensionProperties(const char* layerName, uint32_t propertyCapacityInput,
                                            uint32_t* propertyCountOutput,
                                            XrExtensionProperties* properties,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined. Performs two-call idiom. Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Allocator const& vectorAllocator, Dispatch&& d);

#else
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 * Performs two-call idiom.
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector(
    const char* layerName, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector(
    const char* layerName, Allocator const& vectorAllocator, Dispatch&& d);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief xrCreateInstance wrapper (basic).
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result createInstance(const InstanceCreateInfo& createInfo, Instance& instance,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateInstance enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<Instance> createInstance(const InstanceCreateInfo& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateInstance enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Instance createInstance(const InstanceCreateInfo& createInfo,
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateInstance wrapper returning a smart handle.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * -  a smart wrapper uniquely owning a Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateInstance wrapper returning a smart handle.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns  a smart wrapper uniquely owning a Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_loader_init

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
/*!
 * @brief xrInitializeLoaderKHR wrapper (basic).
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrInitializeLoaderKHR enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns Result (which may be Result::Success, or an error code if asserts are not active )
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
/*!
 * @brief xrInitializeLoaderKHR enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
void initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_loader_init

//! @}

}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_HANDLES_HPP_
