// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_METHOD_IMPLS_ENHANCED_INL_
#define OPENXR_METHOD_IMPLS_ENHANCED_INL_
/*!
 * @file
 * @brief Inline implementations - include @ref openxr_method_impls.hpp instead!
 *
 * Contains inline implementations of "enhanced mode" method wrappers whose signature is the same
 * whether or not exceptions are permitted.
 */

#ifdef OPENXR_HPP_DOXYGEN

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#include "openxr_handles.hpp"
#endif

#ifndef OPENXR_HANDLES_HPP_
#error "This is not meant to be included on its own."
#endif

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE

namespace OPENXR_HPP_NAMESPACE {

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::getInstanceProcAddr(const char* name,
                                                       PFN_xrVoidFunction* function,
                                                       Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetInstanceProcAddr(this->get(), name, function));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ApiLayerProperties, Allocator>>
enumerateApiLayerPropertiesToVector(Dispatch&& d) {
  std::vector<ApiLayerProperties, Allocator> properties;
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(properties)};
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateApiLayerProperties(
        propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrApiLayerProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(properties)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ApiLayerProperties, Allocator>>
enumerateApiLayerPropertiesToVector(Allocator const& vectorAllocator, Dispatch&& d) {
  std::vector<ApiLayerProperties, Allocator> properties{vectorAllocator};
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(properties)};
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateApiLayerProperties(
        propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrApiLayerProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(properties)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName, Dispatch&& d) {
  std::vector<ExtensionProperties, Allocator> properties;
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
      layerName, propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(properties)};
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
        layerName, propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrExtensionProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(properties)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Allocator const& vectorAllocator, Dispatch&& d) {
  std::vector<ExtensionProperties, Allocator> properties{vectorAllocator};
  uint32_t propertyCountOutput = 0;
  uint32_t propertyCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
      layerName, propertyCapacityInput, &propertyCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(properties)};
  }
  do {
    properties.resize(propertyCountOutput);
    propertyCapacityInput = static_cast<uint32_t>(properties.size());
    result = static_cast<Result>(d.xrEnumerateInstanceExtensionProperties(
        layerName, propertyCapacityInput, &propertyCountOutput,
        reinterpret_cast<XrExtensionProperties*>(properties.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
    properties.resize(propertyCountOutput);
  } else
    properties.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(properties)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Instance> createInstance(const InstanceCreateInfo& createInfo,
                                                       Dispatch&& d) {
  Instance handle;
  Result result = static_cast<Result>(d.xrCreateInstance(createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>>
createInstanceUnique(const InstanceCreateInfo& createInfo, Dispatch&& d) {
  Instance handle;
  Result result = static_cast<Result>(d.xrCreateInstance(createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyInstance(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<InstanceProperties> Instance::getInstanceProperties(
    Dispatch&& d) const {
  InstanceProperties returnVal;
  Result result = static_cast<Result>(
      d.xrGetInstanceProperties(this->get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::pollEvent(EventDataBuffer& eventData, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPollEvent(this->get(), eventData.put()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::pollEvent");
  }
#endif

  return result;
}

#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::resultToString(Result value,
                                                  char buffer[XR_MAX_RESULT_STRING_SIZE],
                                                  Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrResultToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::structureTypeToString(StructureType value,
                                                         char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                                                         Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrStructureTypeToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SystemId> Instance::getSystem(const SystemGetInfo& getInfo,
                                                            Dispatch&& d) const {
  SystemId returnVal;
  Result result = static_cast<Result>(
      d.xrGetSystem(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SystemProperties> Instance::getSystemProperties(SystemId systemId,
                                                                              Dispatch&& d) const {
  SystemProperties returnVal;
  Result result = static_cast<Result>(
      d.xrGetSystemProperties(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<EnvironmentBlendMode, Allocator>>
Instance::enumerateEnvironmentBlendModesToVector(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Dispatch&& d) const {
  std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes;
  uint32_t environmentBlendModeCountOutput = 0;
  uint32_t environmentBlendModeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(environmentBlendModes)};
  }
  do {
    environmentBlendModes.resize(environmentBlendModeCountOutput);
    environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
    result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        environmentBlendModeCapacityInput, &environmentBlendModeCountOutput,
        reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
    environmentBlendModes.resize(environmentBlendModeCountOutput);
  } else
    environmentBlendModes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(environmentBlendModes)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<EnvironmentBlendMode, Allocator>>
Instance::enumerateEnvironmentBlendModesToVector(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Allocator const& vectorAllocator,
                                                 Dispatch&& d) const {
  std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes{vectorAllocator};
  uint32_t environmentBlendModeCountOutput = 0;
  uint32_t environmentBlendModeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(environmentBlendModes)};
  }
  do {
    environmentBlendModes.resize(environmentBlendModeCountOutput);
    environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
    result = static_cast<Result>(d.xrEnumerateEnvironmentBlendModes(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        environmentBlendModeCapacityInput, &environmentBlendModeCountOutput,
        reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
    environmentBlendModes.resize(environmentBlendModeCountOutput);
  } else
    environmentBlendModes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(environmentBlendModes)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Session> Instance::createSession(const SessionCreateInfo& createInfo,
                                                               Dispatch&& d) const {
  Session handle;
  Result result =
      static_cast<Result>(d.xrCreateSession(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>>
Instance::createSessionUnique(const SessionCreateInfo& createInfo, Dispatch&& d) const {
  Session handle;
  Result result =
      static_cast<Result>(d.xrCreateSession(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySession(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReferenceSpaceType, Allocator>>
Session::enumerateReferenceSpacesToVector(Dispatch&& d) const {
  std::vector<ReferenceSpaceType, Allocator> spaces;
  uint32_t spaceCountOutput = 0;
  uint32_t spaceCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(spaces)};
  }
  do {
    spaces.resize(spaceCountOutput);
    spaceCapacityInput = static_cast<uint32_t>(spaces.size());
    result = static_cast<Result>(
        d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput,
                                     reinterpret_cast<XrReferenceSpaceType*>(spaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
    spaces.resize(spaceCountOutput);
  } else
    spaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(spaces)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReferenceSpaceType, Allocator>>
Session::enumerateReferenceSpacesToVector(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<ReferenceSpaceType, Allocator> spaces{vectorAllocator};
  uint32_t spaceCountOutput = 0;
  uint32_t spaceCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(spaces)};
  }
  do {
    spaces.resize(spaceCountOutput);
    spaceCapacityInput = static_cast<uint32_t>(spaces.size());
    result = static_cast<Result>(
        d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput,
                                     reinterpret_cast<XrReferenceSpaceType*>(spaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
    spaces.resize(spaceCountOutput);
  } else
    spaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(spaces)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createReferenceSpace(
    const ReferenceSpaceCreateInfo& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
Session::createReferenceSpaceUnique(const ReferenceSpaceCreateInfo& createInfo,
                                    Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType,
                                                              Extent2Df& bounds,
                                                              Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetReferenceSpaceBoundsRect(
      this->get(), OPENXR_HPP_NAMESPACE::get(referenceSpaceType), bounds.put()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::getReferenceSpaceBoundsRect");
  }
#endif

  return result;
}

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createActionSpace(
    const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
Session::createActionSpaceUnique(const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceLocation> Space::locateSpace(Space baseSpace, Time time,
                                                                Dispatch&& d) const {
  SpaceLocation returnVal;
  Result result = static_cast<Result>(d.xrLocateSpace(this->get(), baseSpace.get(), time.get(),
                                                      OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Space::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySpace(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationType, Allocator>>
Instance::enumerateViewConfigurationsToVector(SystemId systemId, Dispatch&& d) const {
  std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes;
  uint32_t viewConfigurationTypeCountOutput = 0;
  uint32_t viewConfigurationTypeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurations(
      this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
      &viewConfigurationTypeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(viewConfigurationTypes)};
  }
  do {
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurations(
        this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
        &viewConfigurationTypeCountOutput,
        reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
  } else
    viewConfigurationTypes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(viewConfigurationTypes)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationType, Allocator>>
Instance::enumerateViewConfigurationsToVector(SystemId systemId, Allocator const& vectorAllocator,
                                              Dispatch&& d) const {
  std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes{vectorAllocator};
  uint32_t viewConfigurationTypeCountOutput = 0;
  uint32_t viewConfigurationTypeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurations(
      this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
      &viewConfigurationTypeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(viewConfigurationTypes)};
  }
  do {
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurations(
        this->get(), systemId.get(), viewConfigurationTypeCapacityInput,
        &viewConfigurationTypeCountOutput,
        reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
    viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
  } else
    viewConfigurationTypes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(viewConfigurationTypes)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ViewConfigurationProperties> Instance::getViewConfigurationProperties(
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
  ViewConfigurationProperties returnVal;
  Result result = static_cast<Result>(d.xrGetViewConfigurationProperties(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationView, Allocator>>
Instance::enumerateViewConfigurationViewsToVector(SystemId systemId,
                                                  ViewConfigurationType viewConfigurationType,
                                                  Dispatch&& d) const {
  std::vector<ViewConfigurationView, Allocator> views;
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(views)};
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        viewCapacityInput, &viewCountOutput,
        reinterpret_cast<XrViewConfigurationView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(views)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationView, Allocator>>
Instance::enumerateViewConfigurationViewsToVector(SystemId systemId,
                                                  ViewConfigurationType viewConfigurationType,
                                                  Allocator const& vectorAllocator,
                                                  Dispatch&& d) const {
  std::vector<ViewConfigurationView, Allocator> views{vectorAllocator};
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(views)};
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrEnumerateViewConfigurationViews(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        viewCapacityInput, &viewCountOutput,
        reinterpret_cast<XrViewConfigurationView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(views)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<int64_t, Allocator>>
Session::enumerateSwapchainFormatsToVector(Dispatch&& d) const {
  std::vector<int64_t, Allocator> formats;
  uint32_t formatCountOutput = 0;
  uint32_t formatCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(formats)};
  }
  do {
    formats.resize(formatCountOutput);
    formatCapacityInput = static_cast<uint32_t>(formats.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput,
                                      reinterpret_cast<int64_t*>(formats.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
    formats.resize(formatCountOutput);
  } else
    formats.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(formats)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<int64_t, Allocator>>
Session::enumerateSwapchainFormatsToVector(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<int64_t, Allocator> formats{vectorAllocator};
  uint32_t formatCountOutput = 0;
  uint32_t formatCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(formats)};
  }
  do {
    formats.resize(formatCountOutput);
    formatCapacityInput = static_cast<uint32_t>(formats.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput,
                                      reinterpret_cast<int64_t*>(formats.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
    formats.resize(formatCountOutput);
  } else
    formats.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(formats)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Swapchain> Session::createSwapchain(
    const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
  Swapchain handle;
  Result result =
      static_cast<Result>(d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>>
Session::createSwapchainUnique(const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
  Swapchain handle;
  Result result =
      static_cast<Result>(d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySwapchain(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename ResultItemType, typename Allocator, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ResultItemType, Allocator>>
Swapchain::enumerateSwapchainImagesToVector(Dispatch&& d) const {
  std::vector<ResultItemType, Allocator> images;
  uint32_t imageCountOutput = 0;
  uint32_t imageCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(images)};
  }
  do {
    images.resize(imageCountOutput);
    imageCapacityInput = static_cast<uint32_t>(images.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput,
                                     reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
    images.resize(imageCountOutput);
  } else
    images.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(images)};
}

template <typename ResultItemType, typename Allocator, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ResultItemType, Allocator>>
Swapchain::enumerateSwapchainImagesToVector(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<ResultItemType, Allocator> images{vectorAllocator};
  uint32_t imageCountOutput = 0;
  uint32_t imageCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(images)};
  }
  do {
    images.resize(imageCountOutput);
    imageCapacityInput = static_cast<uint32_t>(images.size());
    result = static_cast<Result>(
        d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput,
                                     reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
    images.resize(imageCountOutput);
  } else
    images.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(images)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<uint32_t> Swapchain::acquireSwapchainImage(
    const SwapchainImageAcquireInfo& acquireInfo, Dispatch&& d) const {
  uint32_t returnVal;
  Result result =
      static_cast<Result>(d.xrAcquireSwapchainImage(this->get(), acquireInfo.get(), &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                                                       Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrWaitSwapchainImage(this->get(), waitInfo.get()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Swapchain::waitSwapchainImage");
  }
#endif

  return result;
}

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result
Swapchain::releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrReleaseSwapchainImage(this->get(), releaseInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::beginSession(const SessionBeginInfo& beginInfo,
                                               Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrBeginSession(this->get(), beginInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::endSession(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrEndSession(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::requestExitSession(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrRequestExitSession(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FrameState> Session::waitFrame(const FrameWaitInfo& frameWaitInfo,
                                                             Dispatch&& d) const {
  FrameState returnVal;
  Result result = static_cast<Result>(
      d.xrWaitFrame(this->get(), frameWaitInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::beginFrame(const FrameBeginInfo& frameBeginInfo,
                                             Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrBeginFrame(this->get(), frameBeginInfo.get()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::beginFrame");
  }
#endif

  return result;
}

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::endFrame(const FrameEndInfo& frameEndInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrEndFrame(this->get(), frameEndInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<View, Allocator>> Session::locateViewsToVector(
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Dispatch&& d) const {
  std::vector<View, Allocator> views;
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrLocateViews(
      this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(views)};
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState,
                                                 viewCapacityInput, &viewCountOutput,
                                                 reinterpret_cast<XrView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(views)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<View, Allocator>> Session::locateViewsToVector(
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Allocator const& vectorAllocator,
    Dispatch&& d) const {
  std::vector<View, Allocator> views{vectorAllocator};
  uint32_t viewCountOutput = 0;
  uint32_t viewCapacityInput = 0;

  Result result = static_cast<Result>(d.xrLocateViews(
      this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(views)};
  }
  do {
    views.resize(viewCountOutput);
    viewCapacityInput = static_cast<uint32_t>(views.size());
    result = static_cast<Result>(d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState,
                                                 viewCapacityInput, &viewCountOutput,
                                                 reinterpret_cast<XrView*>(views.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
    views.resize(viewCountOutput);
  } else
    views.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(views)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Path> Instance::stringToPath(const char* pathString,
                                                           Dispatch&& d) const {
  Path returnVal;
  Result result = static_cast<Result>(
      d.xrStringToPath(this->get(), pathString, OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::pathToString(
    Path path, Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(
      d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrPathToString(this->get(), path.get(), bufferCapacityInput,
                                                  &bufferCountOutput,
                                                  reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::pathToString(
    Path path, Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(
      d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrPathToString(this->get(), path.get(), bufferCapacityInput,
                                                  &bufferCountOutput,
                                                  reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionSet> Instance::createActionSet(
    const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
  ActionSet handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>>
Instance::createActionSetUnique(const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
  ActionSet handle;
  Result result =
      static_cast<Result>(d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result ActionSet::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyActionSet(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Action> ActionSet::createAction(const ActionCreateInfo& createInfo,
                                                              Dispatch&& d) const {
  Action handle;
  Result result =
      static_cast<Result>(d.xrCreateAction(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>>
ActionSet::createActionUnique(const ActionCreateInfo& createInfo, Dispatch&& d) const {
  Action handle;
  Result result =
      static_cast<Result>(d.xrCreateAction(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Action::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyAction(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::suggestInteractionProfileBindings(
    const InteractionProfileSuggestedBinding& suggestedBindings, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrSuggestInteractionProfileBindings(this->get(), suggestedBindings.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::attachSessionActionSets(
    const SessionActionSetsAttachInfo& attachInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrAttachSessionActionSets(this->get(), attachInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<InteractionProfileState> Session::getCurrentInteractionProfile(
    Path topLevelUserPath, Dispatch&& d) const {
  InteractionProfileState returnVal;
  Result result = static_cast<Result>(d.xrGetCurrentInteractionProfile(
      this->get(), topLevelUserPath.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStateBoolean> Session::getActionStateBoolean(
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
  ActionStateBoolean returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStateBoolean(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStateFloat> Session::getActionStateFloat(
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
  ActionStateFloat returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStateFloat(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStateVector2f> Session::getActionStateVector2f(
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
  ActionStateVector2f returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStateVector2f(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStatePose> Session::getActionStatePose(
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
  ActionStatePose returnVal;
  Result result = static_cast<Result>(
      d.xrGetActionStatePose(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::syncActions(const ActionsSyncInfo& syncInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSyncActions(this->get(), syncInfo.get()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::syncActions");
  }
#endif

  return result;
}

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<Path, Allocator>>
Session::enumerateBoundSourcesForActionToVector(
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Dispatch&& d) const {
  std::vector<Path, Allocator> sources;
  uint32_t sourceCountOutput = 0;
  uint32_t sourceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
      this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(sources)};
  }
  do {
    sources.resize(sourceCountOutput);
    sourceCapacityInput = static_cast<uint32_t>(sources.size());
    result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
        this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput,
        reinterpret_cast<XrPath*>(sources.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
    sources.resize(sourceCountOutput);
  } else
    sources.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(sources)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<Path, Allocator>>
Session::enumerateBoundSourcesForActionToVector(
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
    Dispatch&& d) const {
  std::vector<Path, Allocator> sources{vectorAllocator};
  uint32_t sourceCountOutput = 0;
  uint32_t sourceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
      this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(sources)};
  }
  do {
    sources.resize(sourceCountOutput);
    sourceCapacityInput = static_cast<uint32_t>(sources.size());
    result = static_cast<Result>(d.xrEnumerateBoundSourcesForAction(
        this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput,
        reinterpret_cast<XrPath*>(sources.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
    sources.resize(sourceCountOutput);
  } else
    sources.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(sources)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>>
Session::getInputSourceLocalizedName(const InputSourceLocalizedNameGetInfo& getInfo,
                                     Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
      this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
        this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>>
Session::getInputSourceLocalizedName(const InputSourceLocalizedNameGetInfo& getInfo,
                                     Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
      this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetInputSourceLocalizedName(
        this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                                                      const XrHapticBaseHeader* hapticFeedback,
                                                      Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrApplyHapticFeedback(this->get(), hapticActionInfo.get(), hapticFeedback));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::applyHapticFeedback");
  }
#endif

  return result;
}

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                                                     Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrStopHapticFeedback(this->get(), hapticActionInfo.get()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::stopHapticFeedback");
  }
#endif

  return result;
}

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType,
                                                                 uint32_t threadId,
                                                                 Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetAndroidApplicationThreadKHR(
      this->get(), OPENXR_HPP_NAMESPACE::get(threadType), threadId));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Swapchain> Session::createSwapchainAndroidSurfaceKHR(
    const SwapchainCreateInfo& info, jobject* surface, Dispatch&& d) const {
  Swapchain handle;
  Result result = static_cast<Result>(
      d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>>
Session::createSwapchainAndroidSurfaceUniqueKHR(const SwapchainCreateInfo& info, jobject* surface,
                                                Dispatch&& d) const {
  Swapchain handle;
  Result result = static_cast<Result>(
      d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsOpenGLKHR>
Instance::getOpenGLGraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsOpenGLKHR returnVal;
  Result result = static_cast<Result>(d.xrGetOpenGLGraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsOpenGLESKHR>
Instance::getOpenGLESGraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsOpenGLESKHR returnVal;
  Result result = static_cast<Result>(d.xrGetOpenGLESGraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>>
Instance::getVulkanInstanceExtensionsKHR(SystemId systemId, Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>>
Instance::getVulkanInstanceExtensionsKHR(SystemId systemId, Allocator const& vectorAllocator,
                                         Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanInstanceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>>
Instance::getVulkanDeviceExtensionsKHR(SystemId systemId, Dispatch&& d) const {
  std::vector<char, Allocator> buffer;
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
  Result result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>>
Instance::getVulkanDeviceExtensionsKHR(SystemId systemId, Allocator const& vectorAllocator,
                                       Dispatch&& d) const {
  std::vector<char, Allocator> buffer{vectorAllocator};
  uint32_t bufferCountOutput = 0;
  uint32_t bufferCapacityInput = 0;

  std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
  Result result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
      this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(str)};
  }
  do {
    buffer.resize(bufferCountOutput);
    bufferCapacityInput = static_cast<uint32_t>(buffer.size());
    result = static_cast<Result>(d.xrGetVulkanDeviceExtensionsKHR(
        this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput,
        reinterpret_cast<char*>(buffer.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
    buffer.resize(bufferCountOutput);
  } else
    buffer.clear();

  str.assign(buffer.begin(), buffer.end());
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(str)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VkPhysicalDevice> Instance::getVulkanGraphicsDeviceKHR(
    SystemId systemId, VkInstance vkInstance, Dispatch&& d) const {
  VkPhysicalDevice returnVal;
  Result result = static_cast<Result>(
      d.xrGetVulkanGraphicsDeviceKHR(this->get(), systemId.get(), vkInstance, &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsVulkanKHR>
Instance::getVulkanGraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsVulkanKHR returnVal;
  Result result = static_cast<Result>(d.xrGetVulkanGraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsD3D11KHR>
Instance::getD3D11GraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsD3D11KHR returnVal;
  Result result = static_cast<Result>(d.xrGetD3D11GraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsD3D12KHR>
Instance::getD3D12GraphicsRequirementsKHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsD3D12KHR returnVal;
  Result result = static_cast<Result>(d.xrGetD3D12GraphicsRequirementsKHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_visibility_mask

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VisibilityMaskKHR> Session::getVisibilityMaskKHR(
    ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
    VisibilityMaskTypeKHR visibilityMaskType, Dispatch&& d) const {
  VisibilityMaskKHR returnVal;
  Result result = static_cast<Result>(d.xrGetVisibilityMaskKHR(
      this->get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewIndex,
      OPENXR_HPP_NAMESPACE::get(visibilityMaskType), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Time> Instance::convertWin32PerformanceCounterToTimeKHR(
    const LARGE_INTEGER* performanceCounter, Dispatch&& d) const {
  Time returnVal;
  Result result = static_cast<Result>(d.xrConvertWin32PerformanceCounterToTimeKHR(
      this->get(), performanceCounter, OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<LARGE_INTEGER> Instance::convertTimeToWin32PerformanceCounterKHR(
    Time time, Dispatch&& d) const {
  LARGE_INTEGER returnVal;
  Result result = static_cast<Result>(
      d.xrConvertTimeToWin32PerformanceCounterKHR(this->get(), time.get(), &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Time> Instance::convertTimespecTimeToTimeKHR(
    const struct timespec* timespecTime, Dispatch&& d) const {
  Time returnVal;
  Result result = static_cast<Result>(d.xrConvertTimespecTimeToTimeKHR(
      this->get(), timespecTime, OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<timespec> Instance::convertTimeToTimespecTimeKHR(Time time,
                                                                               Dispatch&& d) const {
  timespec returnVal;
  Result result =
      static_cast<Result>(d.xrConvertTimeToTimespecTimeKHR(this->get(), time.get(), &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_loader_init

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                                             Dispatch&& d) {
  Result result = static_cast<Result>(d.xrInitializeLoaderKHR(loaderInitInfo));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_KHR_loader_init

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::createVulkanInstanceKHR(
    const VulkanInstanceCreateInfoKHR& createInfo, VkInstance* vulkanInstance,
    VkResult* vulkanResult, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrCreateVulkanInstanceKHR(this->get(), createInfo.get(), vulkanInstance, vulkanResult));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result
Instance::createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                                VkResult* vulkanResult, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrCreateVulkanDeviceKHR(this->get(), createInfo.get(), vulkanDevice, vulkanResult));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VkPhysicalDevice> Instance::getVulkanGraphicsDevice2KHR(
    const VulkanGraphicsDeviceGetInfoKHR& getInfo, Dispatch&& d) const {
  VkPhysicalDevice returnVal;
  Result result =
      static_cast<Result>(d.xrGetVulkanGraphicsDevice2KHR(this->get(), getInfo.get(), &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsVulkanKHR>
Instance::getVulkanGraphicsRequirements2KHR(SystemId systemId, Dispatch&& d) const {
  GraphicsRequirementsVulkanKHR returnVal;
  Result result = static_cast<Result>(d.xrGetVulkanGraphicsRequirements2KHR(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_EXT_performance_settings

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                                                     PerfSettingsLevelEXT level,
                                                                     Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPerfSettingsSetPerformanceLevelEXT(
      this->get(), OPENXR_HPP_NAMESPACE::get(domain), OPENXR_HPP_NAMESPACE::get(level)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_thermal_query

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::thermalGetTemperatureTrendEXT(
    PerfSettingsDomainEXT domain, PerfSettingsNotificationLevelEXT& notificationLevel,
    float* tempHeadroom, float* tempSlope, Dispatch&& d) const {
  XrPerfSettingsNotificationLevelEXT notificationLevel_tmp;
  Result result = static_cast<Result>(
      d.xrThermalGetTemperatureTrendEXT(this->get(), OPENXR_HPP_NAMESPACE::get(domain),
                                        notificationLevel_tmp, tempHeadroom, tempSlope));
  notificationLevel = static_cast<PerfSettingsNotificationLevelEXT>(notificationLevel_tmp);
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_thermal_query

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::setDebugUtilsObjectNameEXT(
    const DebugUtilsObjectNameInfoEXT& nameInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetDebugUtilsObjectNameEXT(this->get(), nameInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<DebugUtilsMessengerEXT> Instance::createDebugUtilsMessengerEXT(
    const DebugUtilsMessengerCreateInfoEXT& createInfo, Dispatch&& d) const {
  DebugUtilsMessengerEXT handle;
  Result result = static_cast<Result>(
      d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>>
Instance::createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                             Dispatch&& d) const {
  DebugUtilsMessengerEXT handle;
  Result result = static_cast<Result>(
      d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result,
          UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result DebugUtilsMessengerEXT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyDebugUtilsMessengerEXT(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::submitDebugUtilsMessageEXT(
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
    const DebugUtilsMessengerCallbackDataEXT& callbackData, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSubmitDebugUtilsMessageEXT(
      this->get(), messageSeverity, messageTypes, callbackData.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::sessionBeginDebugUtilsLabelRegionEXT(
    const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSessionBeginDebugUtilsLabelRegionEXT(this->get(), labelInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSessionEndDebugUtilsLabelRegionEXT(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result
Session::sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSessionInsertDebugUtilsLabelEXT(this->get(), labelInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_spatial_anchor

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpatialAnchorMSFT> Session::createSpatialAnchorMSFT(
    const SpatialAnchorCreateInfoMSFT& createInfo, Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
Session::createSpatialAnchorUniqueMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                       Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createSpatialAnchorSpaceMSFT(
    const SpatialAnchorSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
  Space handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
Session::createSpatialAnchorSpaceUniqueMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                            Dispatch&& d) const {
  Space handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SpatialAnchorMSFT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySpatialAnchorMSFT(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceActiveEXT(Path interactionProfile,
                                                          Path topLevelPath, XrBool32 isActive,
                                                          Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceActiveEXT(
      this->get(), interactionProfile.get(), topLevelPath.get(), isActive));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceStateBoolEXT(Path topLevelPath,
                                                             Path inputSourcePath, XrBool32 state,
                                                             Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceStateBoolEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), state));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceStateFloatEXT(Path topLevelPath,
                                                              Path inputSourcePath, float state,
                                                              Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceStateFloatEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), state));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceStateVector2fEXT(Path topLevelPath,
                                                                 Path inputSourcePath,
                                                                 XrVector2f state,
                                                                 Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceStateVector2fEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), state));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath,
                                                            Space space, XrPosef pose,
                                                            Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetInputDeviceLocationEXT(
      this->get(), topLevelPath.get(), inputSourcePath.get(), space.get(), pose));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_hand_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandTrackerEXT> Session::createHandTrackerEXT(
    const HandTrackerCreateInfoEXT& createInfo, Dispatch&& d) const {
  HandTrackerEXT handle;
  Result result =
      static_cast<Result>(d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>>
Session::createHandTrackerUniqueEXT(const HandTrackerCreateInfoEXT& createInfo,
                                    Dispatch&& d) const {
  HandTrackerEXT handle;
  Result result =
      static_cast<Result>(d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result HandTrackerEXT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyHandTrackerEXT(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandJointLocationsEXT> HandTrackerEXT::locateHandJointsEXT(
    const HandJointsLocateInfoEXT& locateInfo, Dispatch&& d) const {
  HandJointLocationsEXT returnVal;
  Result result = static_cast<Result>(
      d.xrLocateHandJointsEXT(this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> HandTrackerEXT::createHandMeshSpaceMSFT(
    const HandMeshSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
HandTrackerEXT::createHandMeshSpaceUniqueMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                              Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandMeshMSFT> HandTrackerEXT::updateHandMeshMSFT(
    const HandMeshUpdateInfoMSFT& updateInfo, Dispatch&& d) const {
  HandMeshMSFT returnVal;
  Result result = static_cast<Result>(
      d.xrUpdateHandMeshMSFT(this->get(), updateInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpatialAnchorMSFT>
Session::createSpatialAnchorFromPerceptionAnchorMSFT(IUnknown* perceptionAnchor,
                                                     Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
Session::createSpatialAnchorFromPerceptionAnchorUniqueMSFT(IUnknown* perceptionAnchor,
                                                           Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(
      d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::tryGetPerceptionAnchorFromSpatialAnchorMSFT(
    SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(this->get(), anchor.get(), perceptionAnchor));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_MSFT_composition_layer_reprojection

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReprojectionModeMSFT, Allocator>>
Instance::enumerateReprojectionModesToVectorMSFT(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Dispatch&& d) const {
  std::vector<ReprojectionModeMSFT, Allocator> modes;
  uint32_t modeCountOutput = 0;
  uint32_t modeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      modeCapacityInput, &modeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(modes)};
  }
  do {
    modes.resize(modeCountOutput);
    modeCapacityInput = static_cast<uint32_t>(modes.size());
    result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        modeCapacityInput, &modeCountOutput,
        reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
    modes.resize(modeCountOutput);
  } else
    modes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(modes)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReprojectionModeMSFT, Allocator>>
Instance::enumerateReprojectionModesToVectorMSFT(SystemId systemId,
                                                 ViewConfigurationType viewConfigurationType,
                                                 Allocator const& vectorAllocator,
                                                 Dispatch&& d) const {
  std::vector<ReprojectionModeMSFT, Allocator> modes{vectorAllocator};
  uint32_t modeCountOutput = 0;
  uint32_t modeCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
      this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
      modeCapacityInput, &modeCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(modes)};
  }
  do {
    modes.resize(modeCountOutput);
    modeCapacityInput = static_cast<uint32_t>(modes.size());
    result = static_cast<Result>(d.xrEnumerateReprojectionModesMSFT(
        this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType),
        modeCapacityInput, &modeCountOutput,
        reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
    modes.resize(modeCountOutput);
  } else
    modes.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(modes)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_FB_swapchain_update_state

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::updateSwapchainFB(const XrSwapchainStateBaseHeaderFB* state,
                                                      Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrUpdateSwapchainFB(this->get(), state));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_swapchain_update_state

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<SceneComputeFeatureMSFT, Allocator>>
Instance::enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId, Dispatch&& d) const {
  std::vector<SceneComputeFeatureMSFT, Allocator> features;
  uint32_t featureCountOutput = 0;
  uint32_t featureCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
      this->get(), systemId.get(), featureCapacityInput, &featureCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || featureCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(features)};
  }
  do {
    features.resize(featureCountOutput);
    featureCapacityInput = static_cast<uint32_t>(features.size());
    result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
        this->get(), systemId.get(), featureCapacityInput, &featureCountOutput,
        reinterpret_cast<XrSceneComputeFeatureMSFT*>(features.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(featureCountOutput <= features.size());
    features.resize(featureCountOutput);
  } else
    features.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(features)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<SceneComputeFeatureMSFT, Allocator>>
Instance::enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId,
                                                    Allocator const& vectorAllocator,
                                                    Dispatch&& d) const {
  std::vector<SceneComputeFeatureMSFT, Allocator> features{vectorAllocator};
  uint32_t featureCountOutput = 0;
  uint32_t featureCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
      this->get(), systemId.get(), featureCapacityInput, &featureCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || featureCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(features)};
  }
  do {
    features.resize(featureCountOutput);
    featureCapacityInput = static_cast<uint32_t>(features.size());
    result = static_cast<Result>(d.xrEnumerateSceneComputeFeaturesMSFT(
        this->get(), systemId.get(), featureCapacityInput, &featureCountOutput,
        reinterpret_cast<XrSceneComputeFeatureMSFT*>(features.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(featureCountOutput <= features.size());
    features.resize(featureCountOutput);
  } else
    features.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(features)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SceneObserverMSFT> Session::createSceneObserverMSFT(
    const SceneObserverCreateInfoMSFT& createInfo, Dispatch&& d) const {
  SceneObserverMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneObserverMSFT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>>>
Session::createSceneObserverUniqueMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                       Dispatch&& d) const {
  SceneObserverMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneObserverMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SceneObserverMSFT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySceneObserverMSFT(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SceneMSFT> SceneObserverMSFT::createSceneMSFT(
    const SceneCreateInfoMSFT& createInfo, Dispatch&& d) const {
  SceneMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneMSFT(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>>>
SceneObserverMSFT::createSceneUniqueMSFT(const SceneCreateInfoMSFT& createInfo,
                                         Dispatch&& d) const {
  SceneMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSceneMSFT(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SceneMSFT::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroySceneMSFT(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SceneObserverMSFT::computeNewSceneMSFT(
    const NewSceneComputeInfoMSFT& computeInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrComputeNewSceneMSFT(this->get(), computeInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SceneComponentsMSFT> SceneMSFT::getSceneComponentsMSFT(
    const SceneComponentsGetInfoMSFT& getInfo, Dispatch&& d) const {
  SceneComponentsMSFT returnVal;
  Result result = static_cast<Result>(
      d.xrGetSceneComponentsMSFT(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SceneComponentLocationsMSFT> SceneMSFT::locateSceneComponentsMSFT(
    const SceneComponentsLocateInfoMSFT& locateInfo, Dispatch&& d) const {
  SceneComponentLocationsMSFT returnVal;
  Result result = static_cast<Result>(d.xrLocateSceneComponentsMSFT(
      this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SceneMeshBuffersMSFT> SceneMSFT::getSceneMeshBuffersMSFT(
    const SceneMeshBuffersGetInfoMSFT& getInfo, Dispatch&& d) const {
  SceneMeshBuffersMSFT returnVal;
  Result result = static_cast<Result>(d.xrGetSceneMeshBuffersMSFT(
      this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding_serialization

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SceneObserverMSFT::deserializeSceneMSFT(
    const SceneDeserializeInfoMSFT& deserializeInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrDeserializeSceneMSFT(this->get(), deserializeInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_MSFT_scene_understanding_serialization

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SceneMSFT::getSerializedSceneFragmentDataMSFT(
    const SerializedSceneFragmentDataGetInfoMSFT& getInfo, uint32_t countInput,
    uint32_t* readOutput, uint8_t* buffer, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetSerializedSceneFragmentDataMSFT(
      this->get(), getInfo.get(), countInput, readOutput, buffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_FB_display_refresh_rate

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<float, Allocator>>
Session::enumerateDisplayRefreshRatesToVectorFB(Dispatch&& d) const {
  std::vector<float, Allocator> displayRefreshRates;
  uint32_t displayRefreshRateCountOutput = 0;
  uint32_t displayRefreshRateCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
      this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(displayRefreshRates)};
  }
  do {
    displayRefreshRates.resize(displayRefreshRateCountOutput);
    displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
    result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
        this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput,
        reinterpret_cast<float*>(displayRefreshRates.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
    displayRefreshRates.resize(displayRefreshRateCountOutput);
  } else
    displayRefreshRates.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(displayRefreshRates)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<float, Allocator>>
Session::enumerateDisplayRefreshRatesToVectorFB(Allocator const& vectorAllocator,
                                                Dispatch&& d) const {
  std::vector<float, Allocator> displayRefreshRates{vectorAllocator};
  uint32_t displayRefreshRateCountOutput = 0;
  uint32_t displayRefreshRateCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
      this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(displayRefreshRates)};
  }
  do {
    displayRefreshRates.resize(displayRefreshRateCountOutput);
    displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
    result = static_cast<Result>(d.xrEnumerateDisplayRefreshRatesFB(
        this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput,
        reinterpret_cast<float*>(displayRefreshRates.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
    displayRefreshRates.resize(displayRefreshRateCountOutput);
  } else
    displayRefreshRates.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(displayRefreshRates)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<float> Session::getDisplayRefreshRateFB(Dispatch&& d) const {
  float returnVal;
  Result result = static_cast<Result>(d.xrGetDisplayRefreshRateFB(this->get(), &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::requestDisplayRefreshRateFB(float displayRefreshRate,
                                                              Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrRequestDisplayRefreshRateFB(this->get(), displayRefreshRate));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_display_refresh_rate

#ifdef XR_HTCX_vive_tracker_interaction

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>>
Instance::enumerateViveTrackerPathsToVectorHTCX(Dispatch&& d) const {
  std::vector<ViveTrackerPathsHTCX, Allocator> paths;
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(paths)};
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput,
                                          reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(paths)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>>
Instance::enumerateViveTrackerPathsToVectorHTCX(Allocator const& vectorAllocator,
                                                Dispatch&& d) const {
  std::vector<ViveTrackerPathsHTCX, Allocator> paths{vectorAllocator};
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(paths)};
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput,
                                          reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(paths)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_HTC_facial_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FacialTrackerHTC> Session::createFacialTrackerHTC(
    const FacialTrackerCreateInfoHTC& createInfo, Dispatch&& d) const {
  FacialTrackerHTC handle;
  Result result =
      static_cast<Result>(d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>>
Session::createFacialTrackerUniqueHTC(const FacialTrackerCreateInfoHTC& createInfo,
                                      Dispatch&& d) const {
  FacialTrackerHTC handle;
  Result result =
      static_cast<Result>(d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result FacialTrackerHTC::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyFacialTrackerHTC(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FacialExpressionsHTC> FacialTrackerHTC::getFacialExpressionsHTC(
    Dispatch&& d) const {
  FacialExpressionsHTC returnVal;
  Result result = static_cast<Result>(
      d.xrGetFacialExpressionsHTC(this->get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ColorSpaceFB, Allocator>>
Session::enumerateColorSpacesToVectorFB(Dispatch&& d) const {
  std::vector<ColorSpaceFB, Allocator> colorSpaces;
  uint32_t colorSpaceCountOutput = 0;
  uint32_t colorSpaceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateColorSpacesFB(
      this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(colorSpaces)};
  }
  do {
    colorSpaces.resize(colorSpaceCountOutput);
    colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
    result = static_cast<Result>(
        d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput,
                                   reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
    colorSpaces.resize(colorSpaceCountOutput);
  } else
    colorSpaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(colorSpaces)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ColorSpaceFB, Allocator>>
Session::enumerateColorSpacesToVectorFB(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<ColorSpaceFB, Allocator> colorSpaces{vectorAllocator};
  uint32_t colorSpaceCountOutput = 0;
  uint32_t colorSpaceCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumerateColorSpacesFB(
      this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(colorSpaces)};
  }
  do {
    colorSpaces.resize(colorSpaceCountOutput);
    colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
    result = static_cast<Result>(
        d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput,
                                   reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
    colorSpaces.resize(colorSpaceCountOutput);
  } else
    colorSpaces.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(colorSpaces)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_color_space

#ifdef XR_FB_color_space

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setColorSpaceFB(ColorSpaceFB colorspace, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSetColorSpaceFB(this->get(), OPENXR_HPP_NAMESPACE::get(colorspace)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_color_space

#ifdef XR_FB_hand_tracking_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandTrackingMeshFB> HandTrackerEXT::getHandMeshFB(
    Dispatch&& d) const {
  HandTrackingMeshFB returnVal;
  Result result =
      static_cast<Result>(d.xrGetHandMeshFB(this->get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_foveation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FoveationProfileFB> Session::createFoveationProfileFB(
    const FoveationProfileCreateInfoFB& createInfo, Dispatch&& d) const {
  FoveationProfileFB handle;
  Result result = static_cast<Result>(
      d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>>
Session::createFoveationProfileUniqueFB(const FoveationProfileCreateInfoFB& createInfo,
                                        Dispatch&& d) const {
  FoveationProfileFB handle;
  Result result = static_cast<Result>(
      d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result,
          UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_foveation

#ifdef XR_FB_foveation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result FoveationProfileFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyFoveationProfileFB(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_foveation

#ifdef XR_FB_keyboard_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<KeyboardTrackingDescriptionFB> Session::querySystemTrackedKeyboardFB(
    const KeyboardTrackingQueryFB& queryInfo, Dispatch&& d) const {
  KeyboardTrackingDescriptionFB returnVal;
  Result result = static_cast<Result>(d.xrQuerySystemTrackedKeyboardFB(
      this->get(), queryInfo.get(), OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createKeyboardSpaceFB(
    const KeyboardSpaceCreateInfoFB& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
Session::createKeyboardSpaceUniqueFB(const KeyboardSpaceCreateInfoFB& createInfo,
                                     Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<TriangleMeshFB> Session::createTriangleMeshFB(
    const TriangleMeshCreateInfoFB& createInfo, Dispatch&& d) const {
  TriangleMeshFB handle;
  Result result =
      static_cast<Result>(d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>>
Session::createTriangleMeshUniqueFB(const TriangleMeshCreateInfoFB& createInfo,
                                    Dispatch&& d) const {
  TriangleMeshFB handle;
  Result result =
      static_cast<Result>(d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyTriangleMeshFB(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshGetVertexBufferFB(XrVector3f** outVertexBuffer,
                                                                       Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrTriangleMeshGetVertexBufferFB(this->get(), outVertexBuffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshGetIndexBufferFB(uint32_t** outIndexBuffer,
                                                                      Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrTriangleMeshGetIndexBufferFB(this->get(), outIndexBuffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshBeginUpdateFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrTriangleMeshBeginUpdateFB(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshEndUpdateFB(uint32_t vertexCount,
                                                                 uint32_t triangleCount,
                                                                 Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrTriangleMeshEndUpdateFB(this->get(), vertexCount, triangleCount));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<uint32_t> TriangleMeshFB::triangleMeshBeginVertexBufferUpdateFB(
    Dispatch&& d) const {
  uint32_t returnVal;
  Result result =
      static_cast<Result>(d.xrTriangleMeshBeginVertexBufferUpdateFB(this->get(), &returnVal));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_triangle_mesh

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshEndVertexBufferUpdateFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrTriangleMeshEndVertexBufferUpdateFB(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughFB> Session::createPassthroughFB(
    const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
  PassthroughFB handle;
  Result result =
      static_cast<Result>(d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>>
Session::createPassthroughUniqueFB(const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
  PassthroughFB handle;
  Result result =
      static_cast<Result>(d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyPassthroughFB(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughFB::passthroughStartFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughStartFB(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughFB::passthroughPauseFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughPauseFB(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughLayerFB> Session::createPassthroughLayerFB(
    const PassthroughLayerCreateInfoFB& createInfo, Dispatch&& d) const {
  PassthroughLayerFB handle;
  Result result = static_cast<Result>(
      d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>>
Session::createPassthroughLayerUniqueFB(const PassthroughLayerCreateInfoFB& createInfo,
                                        Dispatch&& d) const {
  PassthroughLayerFB handle;
  Result result = static_cast<Result>(
      d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result,
          UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyPassthroughLayerFB(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerPauseFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughLayerPauseFB(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerResumeFB(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughLayerResumeFB(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerSetStyleFB(
    const PassthroughStyleFB& style, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrPassthroughLayerSetStyleFB(this->get(), style.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GeometryInstanceFB> Session::createGeometryInstanceFB(
    const GeometryInstanceCreateInfoFB& createInfo, Dispatch&& d) const {
  GeometryInstanceFB handle;
  Result result = static_cast<Result>(
      d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>>
Session::createGeometryInstanceUniqueFB(const GeometryInstanceCreateInfoFB& createInfo,
                                        Dispatch&& d) const {
  GeometryInstanceFB handle;
  Result result = static_cast<Result>(
      d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result,
          UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result GeometryInstanceFB::destroy(Dispatch&& d) {
  Result result = static_cast<Result>(d.xrDestroyGeometryInstanceFB(this->get()));
  val_ = XR_NULL_HANDLE;
  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result GeometryInstanceFB::geometryInstanceSetTransformFB(
    const GeometryInstanceTransformFB& transformation, Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrGeometryInstanceSetTransformFB(this->get(), transformation.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough

#ifdef XR_FB_render_model

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<RenderModelPathInfoFB, Allocator>>
Session::enumerateRenderModelPathsToVectorFB(Dispatch&& d) const {
  std::vector<RenderModelPathInfoFB, Allocator> paths;
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(paths)};
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput,
                                        reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(paths)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<RenderModelPathInfoFB, Allocator>>
Session::enumerateRenderModelPathsToVectorFB(Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<RenderModelPathInfoFB, Allocator> paths{vectorAllocator};
  uint32_t pathCountOutput = 0;
  uint32_t pathCapacityInput = 0;

  Result result = static_cast<Result>(
      d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(paths)};
  }
  do {
    paths.resize(pathCountOutput);
    pathCapacityInput = static_cast<uint32_t>(paths.size());
    result = static_cast<Result>(
        d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput,
                                        reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
    paths.resize(pathCountOutput);
  } else
    paths.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(paths)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_render_model

#ifdef XR_FB_render_model

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::getRenderModelPropertiesFB(Path path,
                                                             RenderModelPropertiesFB& properties,
                                                             Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrGetRenderModelPropertiesFB(this->get(), path.get(), properties.put()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(
        result, OPENXR_HPP_NAMESPACE_STRING "::Session::getRenderModelPropertiesFB");
  }
#endif

  return result;
}

#endif  // XR_FB_render_model

#ifdef XR_FB_render_model

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::loadRenderModelFB(const RenderModelLoadInfoFB& info,
                                                    RenderModelBufferFB& buffer,
                                                    Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrLoadRenderModelFB(this->get(), info.get(), buffer.put()));

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  OPENXR_HPP_ASSERT(succeeded(result));
#else
  if (!(succeeded(result))) {
    exceptions::throwResultException(result,
                                     OPENXR_HPP_NAMESPACE_STRING "::Session::loadRenderModelFB");
  }
#endif

  return result;
}

#endif  // XR_FB_render_model

#ifdef XR_VARJO_environment_depth_estimation

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setEnvironmentDepthEstimationVARJO(XrBool32 enabled,
                                                                     Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetEnvironmentDepthEstimationVARJO(this->get(), enabled));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_environment_depth_estimation

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setMarkerTrackingVARJO(XrBool32 enabled, Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrSetMarkerTrackingVARJO(this->get(), enabled));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                                                Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSetMarkerTrackingTimeoutVARJO(this->get(), markerId, timeout.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setMarkerTrackingPredictionVARJO(uint64_t markerId,
                                                                   XrBool32 enabled,
                                                                   Dispatch&& d) const {
  Result result =
      static_cast<Result>(d.xrSetMarkerTrackingPredictionVARJO(this->get(), markerId, enabled));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Extent2Df> Session::getMarkerSizeVARJO(uint64_t markerId,
                                                                     Dispatch&& d) const {
  Extent2Df returnVal;
  Result result = static_cast<Result>(
      d.xrGetMarkerSizeVARJO(this->get(), markerId, OPENXR_HPP_NAMESPACE::put(returnVal)));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(returnVal)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createMarkerSpaceVARJO(
    const MarkerSpaceCreateInfoVARJO& createInfo, Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
Session::createMarkerSpaceUniqueVARJO(const MarkerSpaceCreateInfoVARJO& createInfo,
                                      Dispatch&& d) const {
  Space handle;
  Result result =
      static_cast<Result>(d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpatialAnchorStoreConnectionMSFT>
Session::createSpatialAnchorStoreConnectionMSFT(Dispatch&& d) const {
  SpatialAnchorStoreConnectionMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorStoreConnectionMSFT(this->get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE
    ResultValue<UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>>
    Session::createSpatialAnchorStoreConnectionUniqueMSFT(Dispatch&& d) const {
  SpatialAnchorStoreConnectionMSFT handle;
  Result result =
      static_cast<Result>(d.xrCreateSpatialAnchorStoreConnectionMSFT(this->get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>(
                      handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SpatialAnchorStoreConnectionMSFT::destroy(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrDestroySpatialAnchorStoreConnectionMSFT(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SpatialAnchorStoreConnectionMSFT::persistSpatialAnchorMSFT(
    const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrPersistSpatialAnchorMSFT(this->get(), spatialAnchorPersistenceInfo.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>>
SpatialAnchorStoreConnectionMSFT::enumeratePersistedSpatialAnchorNamesToVectorMSFT(
    Dispatch&& d) const {
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator> persistedAnchorNames;
  uint32_t spatialAnchorNamesCountOutput = 0;
  uint32_t spatialAnchorNamesCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
      this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spatialAnchorNamesCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(persistedAnchorNames)};
  }
  do {
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
    spatialAnchorNamesCapacityInput = static_cast<uint32_t>(persistedAnchorNames.size());
    result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
        this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput,
        reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(persistedAnchorNames.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spatialAnchorNamesCountOutput <= persistedAnchorNames.size());
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
  } else
    persistedAnchorNames.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(persistedAnchorNames)};
}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>>
SpatialAnchorStoreConnectionMSFT::enumeratePersistedSpatialAnchorNamesToVectorMSFT(
    Allocator const& vectorAllocator, Dispatch&& d) const {
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator> persistedAnchorNames{vectorAllocator};
  uint32_t spatialAnchorNamesCountOutput = 0;
  uint32_t spatialAnchorNamesCapacityInput = 0;

  Result result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
      this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput, nullptr));
  if (!unqualifiedSuccess(result) || spatialAnchorNamesCountOutput == 0) {
    OPENXR_HPP_ASSERT(succeeded(result));

    return {result, std::move(persistedAnchorNames)};
  }
  do {
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
    spatialAnchorNamesCapacityInput = static_cast<uint32_t>(persistedAnchorNames.size());
    result = static_cast<Result>(d.xrEnumeratePersistedSpatialAnchorNamesMSFT(
        this->get(), spatialAnchorNamesCapacityInput, &spatialAnchorNamesCountOutput,
        reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(persistedAnchorNames.data())));
  } while (result == xr::Result::ErrorSizeInsufficient);
  if (succeeded(result)) {
    OPENXR_HPP_ASSERT(spatialAnchorNamesCountOutput <= persistedAnchorNames.size());
    persistedAnchorNames.resize(spatialAnchorNamesCountOutput);
  } else
    persistedAnchorNames.clear();

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(persistedAnchorNames)};
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpatialAnchorMSFT> Session::createSpatialAnchorFromPersistedNameMSFT(
    const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
    Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(d.xrCreateSpatialAnchorFromPersistedNameMSFT(
      this->get(), spatialAnchorCreateInfo.get(), handle.put()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, std::move(handle)};
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
Session::createSpatialAnchorFromPersistedNameUniqueMSFT(
    const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
    Dispatch&& d) const {
  SpatialAnchorMSFT handle;
  Result result = static_cast<Result>(d.xrCreateSpatialAnchorFromPersistedNameMSFT(
      this->get(), spatialAnchorCreateInfo.get(), handle.put()));
  ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
  OPENXR_HPP_ASSERT(succeeded(result));

  return {result, UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter)};
}

#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SpatialAnchorStoreConnectionMSFT::unpersistSpatialAnchorMSFT(
    const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrUnpersistSpatialAnchorMSFT(this->get(), spatialAnchorPersistenceName.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result
SpatialAnchorStoreConnectionMSFT::clearSpatialAnchorStoreMSFT(Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrClearSpatialAnchorStoreMSFT(this->get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::getAudioOutputDeviceGuidOculus(
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetAudioOutputDeviceGuidOculus(this->get(), buffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid

#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::getAudioInputDeviceGuidOculus(
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
  Result result = static_cast<Result>(d.xrGetAudioInputDeviceGuidOculus(this->get(), buffer));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid

#ifdef XR_ALMALENCE_digital_lens_control

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setDigitalLensControlALMALENCE(
    const DigitalLensControlALMALENCE& digitalLensControl, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrSetDigitalLensControlALMALENCE(this->get(), digitalLensControl.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_ALMALENCE_digital_lens_control

#ifdef XR_FB_passthrough_keyboard_hands

#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerSetKeyboardHandsIntensityFB(
    const PassthroughKeyboardHandsIntensityFB& intensity, Dispatch&& d) const {
  Result result = static_cast<Result>(
      d.xrPassthroughLayerSetKeyboardHandsIntensityFB(this->get(), intensity.get()));

  OPENXR_HPP_ASSERT(succeeded(result));

  return result;
}

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough_keyboard_hands
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // ifndef OPENXR_METHOD_IMPLS_ENHANCED_INL_
