// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_ENUMS_HPP_
#define OPENXR_ENUMS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR enum types.
 *
 * Does not include the flags (bitmasks).
 *
 * @see openxr_flags.hpp
 * @ingroup enums
 */

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

#include <string>

// Fix name collisions from noisy includes
#ifdef Success
#undef Success
#endif
#ifdef None
#undef None
#endif

#if !defined(OPENXR_HPP_INLINE)
#if defined(__clang___)
#if __has_attribute(always_inline)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#else
#define OPENXR_HPP_INLINE inline
#endif
#elif defined(__GNUC__)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#elif defined(_MSC_VER)
#define OPENXR_HPP_INLINE inline
#else
#define OPENXR_HPP_INLINE inline
#endif
#endif  // !OPENXR_HPP_INLINE

#if !defined(OPENXR_HPP_CONSTEXPR)
#if defined(_MSC_VER) && (_MSC_VER <= 1800)
#define OPENXR_HPP_CONSTEXPR
#else
#define OPENXR_HPP_CONSTEXPR constexpr
#endif
#endif  // !OPENXR_HPP_CONSTEXPR

#if !defined(OPENXR_HPP_SWITCH_CONSTEXPR)
//! @todo set this to constexpr in c++14
#define OPENXR_HPP_SWITCH_CONSTEXPR
#endif  // !OPENXR_HPP_SWITCH_CONSTEXPR

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {
/*!
 * @defgroup enums Enumerations
 * @brief C++ enum classes corresponding to OpenXR C enumerations, plus associated utility
 * functions.
 * @ingroup wrappers
 *
 * All enumerations have three utility functions defined:
 *
 * - get() - returns the raw C enum value
 * - to_string_literal() - returns a const char* containing the C++ name
 * - to_string() - wraps to_string_literal(), returning a std::string
 *
 * They all should be accessible via argument-dependent lookup, meaning you should not need to
 * explicitly specify the namespace.
 * @{
 */

/*!
 * @brief Enum class for XrResult
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrResult>
 *
 * @see failed(), succeeded(), unqualifiedSuccess()
 * @xrentity{XrResult}
 */
enum class Result : int32_t {

  Success = XR_SUCCESS,

  TimeoutExpired = XR_TIMEOUT_EXPIRED,

  SessionLossPending = XR_SESSION_LOSS_PENDING,

  EventUnavailable = XR_EVENT_UNAVAILABLE,

  SpaceBoundsUnavailable = XR_SPACE_BOUNDS_UNAVAILABLE,

  SessionNotFocused = XR_SESSION_NOT_FOCUSED,

  FrameDiscarded = XR_FRAME_DISCARDED,

  ErrorValidationFailure = XR_ERROR_VALIDATION_FAILURE,

  ErrorRuntimeFailure = XR_ERROR_RUNTIME_FAILURE,

  ErrorOutOfMemory = XR_ERROR_OUT_OF_MEMORY,

  ErrorAPIVersionUnsupported = XR_ERROR_API_VERSION_UNSUPPORTED,

  ErrorInitializationFailed = XR_ERROR_INITIALIZATION_FAILED,

  ErrorFunctionUnsupported = XR_ERROR_FUNCTION_UNSUPPORTED,

  ErrorFeatureUnsupported = XR_ERROR_FEATURE_UNSUPPORTED,

  ErrorExtensionNotPresent = XR_ERROR_EXTENSION_NOT_PRESENT,

  ErrorLimitReached = XR_ERROR_LIMIT_REACHED,

  ErrorSizeInsufficient = XR_ERROR_SIZE_INSUFFICIENT,

  ErrorHandleInvalid = XR_ERROR_HANDLE_INVALID,

  ErrorInstanceLost = XR_ERROR_INSTANCE_LOST,

  ErrorSessionRunning = XR_ERROR_SESSION_RUNNING,

  ErrorSessionNotRunning = XR_ERROR_SESSION_NOT_RUNNING,

  ErrorSessionLost = XR_ERROR_SESSION_LOST,

  ErrorSystemInvalid = XR_ERROR_SYSTEM_INVALID,

  ErrorPathInvalid = XR_ERROR_PATH_INVALID,

  ErrorPathCountExceeded = XR_ERROR_PATH_COUNT_EXCEEDED,

  ErrorPathFormatInvalid = XR_ERROR_PATH_FORMAT_INVALID,

  ErrorPathUnsupported = XR_ERROR_PATH_UNSUPPORTED,

  ErrorLayerInvalid = XR_ERROR_LAYER_INVALID,

  ErrorLayerLimitExceeded = XR_ERROR_LAYER_LIMIT_EXCEEDED,

  ErrorSwapchainRectInvalid = XR_ERROR_SWAPCHAIN_RECT_INVALID,

  ErrorSwapchainFormatUnsupported = XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED,

  ErrorActionTypeMismatch = XR_ERROR_ACTION_TYPE_MISMATCH,

  ErrorSessionNotReady = XR_ERROR_SESSION_NOT_READY,

  ErrorSessionNotStopping = XR_ERROR_SESSION_NOT_STOPPING,

  ErrorTimeInvalid = XR_ERROR_TIME_INVALID,

  ErrorReferenceSpaceUnsupported = XR_ERROR_REFERENCE_SPACE_UNSUPPORTED,

  ErrorFileAccessError = XR_ERROR_FILE_ACCESS_ERROR,

  ErrorFileContentsInvalid = XR_ERROR_FILE_CONTENTS_INVALID,

  ErrorFormFactorUnsupported = XR_ERROR_FORM_FACTOR_UNSUPPORTED,

  ErrorFormFactorUnavailable = XR_ERROR_FORM_FACTOR_UNAVAILABLE,

  ErrorAPILayerNotPresent = XR_ERROR_API_LAYER_NOT_PRESENT,

  ErrorCallOrderInvalid = XR_ERROR_CALL_ORDER_INVALID,

  ErrorGraphicsDeviceInvalid = XR_ERROR_GRAPHICS_DEVICE_INVALID,

  ErrorPoseInvalid = XR_ERROR_POSE_INVALID,

  ErrorIndexOutOfRange = XR_ERROR_INDEX_OUT_OF_RANGE,

  ErrorViewConfigurationTypeUnsupported = XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,

  ErrorEnvironmentBlendModeUnsupported = XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED,

  ErrorNameDuplicated = XR_ERROR_NAME_DUPLICATED,

  ErrorNameInvalid = XR_ERROR_NAME_INVALID,

  ErrorActionsetNotAttached = XR_ERROR_ACTIONSET_NOT_ATTACHED,

  ErrorActionsetsAlreadyAttached = XR_ERROR_ACTIONSETS_ALREADY_ATTACHED,

  ErrorLocalizedNameDuplicated = XR_ERROR_LOCALIZED_NAME_DUPLICATED,

  ErrorLocalizedNameInvalid = XR_ERROR_LOCALIZED_NAME_INVALID,

  ErrorGraphicsRequirementsCallMissing = XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING,

  ErrorRuntimeUnavailable = XR_ERROR_RUNTIME_UNAVAILABLE,

#ifdef XR_KHR_android_thread_settings
  ErrorAndroidThreadSettingsIdInvalidKHR = XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR,
#endif  // XR_KHR_android_thread_settings
#ifdef XR_KHR_android_thread_settings
  ErrorAndroidThreadSettingsFailureKHR = XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR,
#endif  // XR_KHR_android_thread_settings
#ifdef XR_MSFT_spatial_anchor
  ErrorCreateSpatialAnchorFailedMSFT = XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_secondary_view_configuration
  ErrorSecondaryViewConfigurationTypeNotEnabledMSFT =
      XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
  ErrorControllerModelKeyInvalidMSFT = XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_composition_layer_reprojection
  ErrorReprojectionModeUnsupportedMSFT = XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT,
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_scene_understanding
  ErrorComputeNewSceneNotCompletedMSFT = XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComponentIdInvalidMSFT = XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComponentTypeMismatchMSFT = XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneMeshBufferIdInvalidMSFT = XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComputeFeatureIncompatibleMSFT = XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComputeConsistencyMismatchMSFT = XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_FB_display_refresh_rate
  ErrorDisplayRefreshRateUnsupportedFB = XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB,
#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_color_space
  ErrorColorSpaceUnsupportedFB = XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB,
#endif  // XR_FB_color_space
#ifdef XR_FB_passthrough
  ErrorUnexpectedStatePassthroughFB = XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorFeatureAlreadyCreatedPassthroughFB = XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorFeatureRequiredPassthroughFB = XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorNotPermittedPassthroughFB = XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorInsufficientResourcesPassthroughFB = XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorUnknownPassthroughFB = XR_ERROR_UNKNOWN_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
  ErrorRenderModelKeyInvalidFB = XR_ERROR_RENDER_MODEL_KEY_INVALID_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelUnavailableFB = XR_RENDER_MODEL_UNAVAILABLE_FB,
#endif  // XR_FB_render_model
#ifdef XR_VARJO_marker_tracking
  ErrorMarkerNotTrackedVARJO = XR_ERROR_MARKER_NOT_TRACKED_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
  ErrorMarkerIdInvalidVARJO = XR_ERROR_MARKER_ID_INVALID_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_MSFT_spatial_anchor_persistence
  ErrorSpatialAnchorNameNotFoundMSFT = XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
  ErrorSpatialAnchorNameInvalidMSFT = XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
};
static_assert(sizeof(Result) == sizeof(XrResult), "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrResult value from a Result.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrResult get(Result const& v) {
  return static_cast<XrResult>(v);
}

/*!
 * @brief Free function for retrieving the string name of a Result value as a const char *.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(Result value) {
  switch (value) {
    case Result::Success:
      return "Success";

    case Result::TimeoutExpired:
      return "TimeoutExpired";

    case Result::SessionLossPending:
      return "SessionLossPending";

    case Result::EventUnavailable:
      return "EventUnavailable";

    case Result::SpaceBoundsUnavailable:
      return "SpaceBoundsUnavailable";

    case Result::SessionNotFocused:
      return "SessionNotFocused";

    case Result::FrameDiscarded:
      return "FrameDiscarded";

    case Result::ErrorValidationFailure:
      return "ErrorValidationFailure";

    case Result::ErrorRuntimeFailure:
      return "ErrorRuntimeFailure";

    case Result::ErrorOutOfMemory:
      return "ErrorOutOfMemory";

    case Result::ErrorAPIVersionUnsupported:
      return "ErrorAPIVersionUnsupported";

    case Result::ErrorInitializationFailed:
      return "ErrorInitializationFailed";

    case Result::ErrorFunctionUnsupported:
      return "ErrorFunctionUnsupported";

    case Result::ErrorFeatureUnsupported:
      return "ErrorFeatureUnsupported";

    case Result::ErrorExtensionNotPresent:
      return "ErrorExtensionNotPresent";

    case Result::ErrorLimitReached:
      return "ErrorLimitReached";

    case Result::ErrorSizeInsufficient:
      return "ErrorSizeInsufficient";

    case Result::ErrorHandleInvalid:
      return "ErrorHandleInvalid";

    case Result::ErrorInstanceLost:
      return "ErrorInstanceLost";

    case Result::ErrorSessionRunning:
      return "ErrorSessionRunning";

    case Result::ErrorSessionNotRunning:
      return "ErrorSessionNotRunning";

    case Result::ErrorSessionLost:
      return "ErrorSessionLost";

    case Result::ErrorSystemInvalid:
      return "ErrorSystemInvalid";

    case Result::ErrorPathInvalid:
      return "ErrorPathInvalid";

    case Result::ErrorPathCountExceeded:
      return "ErrorPathCountExceeded";

    case Result::ErrorPathFormatInvalid:
      return "ErrorPathFormatInvalid";

    case Result::ErrorPathUnsupported:
      return "ErrorPathUnsupported";

    case Result::ErrorLayerInvalid:
      return "ErrorLayerInvalid";

    case Result::ErrorLayerLimitExceeded:
      return "ErrorLayerLimitExceeded";

    case Result::ErrorSwapchainRectInvalid:
      return "ErrorSwapchainRectInvalid";

    case Result::ErrorSwapchainFormatUnsupported:
      return "ErrorSwapchainFormatUnsupported";

    case Result::ErrorActionTypeMismatch:
      return "ErrorActionTypeMismatch";

    case Result::ErrorSessionNotReady:
      return "ErrorSessionNotReady";

    case Result::ErrorSessionNotStopping:
      return "ErrorSessionNotStopping";

    case Result::ErrorTimeInvalid:
      return "ErrorTimeInvalid";

    case Result::ErrorReferenceSpaceUnsupported:
      return "ErrorReferenceSpaceUnsupported";

    case Result::ErrorFileAccessError:
      return "ErrorFileAccessError";

    case Result::ErrorFileContentsInvalid:
      return "ErrorFileContentsInvalid";

    case Result::ErrorFormFactorUnsupported:
      return "ErrorFormFactorUnsupported";

    case Result::ErrorFormFactorUnavailable:
      return "ErrorFormFactorUnavailable";

    case Result::ErrorAPILayerNotPresent:
      return "ErrorAPILayerNotPresent";

    case Result::ErrorCallOrderInvalid:
      return "ErrorCallOrderInvalid";

    case Result::ErrorGraphicsDeviceInvalid:
      return "ErrorGraphicsDeviceInvalid";

    case Result::ErrorPoseInvalid:
      return "ErrorPoseInvalid";

    case Result::ErrorIndexOutOfRange:
      return "ErrorIndexOutOfRange";

    case Result::ErrorViewConfigurationTypeUnsupported:
      return "ErrorViewConfigurationTypeUnsupported";

    case Result::ErrorEnvironmentBlendModeUnsupported:
      return "ErrorEnvironmentBlendModeUnsupported";

    case Result::ErrorNameDuplicated:
      return "ErrorNameDuplicated";

    case Result::ErrorNameInvalid:
      return "ErrorNameInvalid";

    case Result::ErrorActionsetNotAttached:
      return "ErrorActionsetNotAttached";

    case Result::ErrorActionsetsAlreadyAttached:
      return "ErrorActionsetsAlreadyAttached";

    case Result::ErrorLocalizedNameDuplicated:
      return "ErrorLocalizedNameDuplicated";

    case Result::ErrorLocalizedNameInvalid:
      return "ErrorLocalizedNameInvalid";

    case Result::ErrorGraphicsRequirementsCallMissing:
      return "ErrorGraphicsRequirementsCallMissing";

    case Result::ErrorRuntimeUnavailable:
      return "ErrorRuntimeUnavailable";

#ifdef XR_KHR_android_thread_settings
    case Result::ErrorAndroidThreadSettingsIdInvalidKHR:
      return "ErrorAndroidThreadSettingsIdInvalidKHR";
#endif  // XR_KHR_android_thread_settings
#ifdef XR_KHR_android_thread_settings
    case Result::ErrorAndroidThreadSettingsFailureKHR:
      return "ErrorAndroidThreadSettingsFailureKHR";
#endif  // XR_KHR_android_thread_settings
#ifdef XR_MSFT_spatial_anchor
    case Result::ErrorCreateSpatialAnchorFailedMSFT:
      return "ErrorCreateSpatialAnchorFailedMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_secondary_view_configuration
    case Result::ErrorSecondaryViewConfigurationTypeNotEnabledMSFT:
      return "ErrorSecondaryViewConfigurationTypeNotEnabledMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
    case Result::ErrorControllerModelKeyInvalidMSFT:
      return "ErrorControllerModelKeyInvalidMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_composition_layer_reprojection
    case Result::ErrorReprojectionModeUnsupportedMSFT:
      return "ErrorReprojectionModeUnsupportedMSFT";
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorComputeNewSceneNotCompletedMSFT:
      return "ErrorComputeNewSceneNotCompletedMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComponentIdInvalidMSFT:
      return "ErrorSceneComponentIdInvalidMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComponentTypeMismatchMSFT:
      return "ErrorSceneComponentTypeMismatchMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneMeshBufferIdInvalidMSFT:
      return "ErrorSceneMeshBufferIdInvalidMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComputeFeatureIncompatibleMSFT:
      return "ErrorSceneComputeFeatureIncompatibleMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComputeConsistencyMismatchMSFT:
      return "ErrorSceneComputeConsistencyMismatchMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_FB_display_refresh_rate
    case Result::ErrorDisplayRefreshRateUnsupportedFB:
      return "ErrorDisplayRefreshRateUnsupportedFB";
#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_color_space
    case Result::ErrorColorSpaceUnsupportedFB:
      return "ErrorColorSpaceUnsupportedFB";
#endif  // XR_FB_color_space
#ifdef XR_FB_passthrough
    case Result::ErrorUnexpectedStatePassthroughFB:
      return "ErrorUnexpectedStatePassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorFeatureAlreadyCreatedPassthroughFB:
      return "ErrorFeatureAlreadyCreatedPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorFeatureRequiredPassthroughFB:
      return "ErrorFeatureRequiredPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorNotPermittedPassthroughFB:
      return "ErrorNotPermittedPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorInsufficientResourcesPassthroughFB:
      return "ErrorInsufficientResourcesPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorUnknownPassthroughFB:
      return "ErrorUnknownPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
    case Result::ErrorRenderModelKeyInvalidFB:
      return "ErrorRenderModelKeyInvalidFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case Result::RenderModelUnavailableFB:
      return "RenderModelUnavailableFB";
#endif  // XR_FB_render_model
#ifdef XR_VARJO_marker_tracking
    case Result::ErrorMarkerNotTrackedVARJO:
      return "ErrorMarkerNotTrackedVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
    case Result::ErrorMarkerIdInvalidVARJO:
      return "ErrorMarkerIdInvalidVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_MSFT_spatial_anchor_persistence
    case Result::ErrorSpatialAnchorNameNotFoundMSFT:
      return "ErrorSpatialAnchorNameNotFoundMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
    case Result::ErrorSpatialAnchorNameInvalidMSFT:
      return "ErrorSpatialAnchorNameInvalidMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a Result value as a std::string.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(Result value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @defgroup result_helpers Result helper free functions
 * @brief C++ projections of the XrResult-checking function-style macros as constexpr functions.
 * @ingroup enums
 * @{
 */
/*!
 * @brief Return true if the Result is negative, indicating a failure.
 * Equivalent of XR_FAILED().
 * @found_by_adl
 * @see Result
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_FAILED>
 * @xrentity{XR_FAILED}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool failed(Result v) { return static_cast<int>(v) < 0; }

/*!
 * @brief Return true if the result is non-negative, indicating a success or non-error result.
 * Equivalent of XR_SUCCEEDED().
 * @found_by_adl
 * @see Result
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_SUCCEEDED>
 * @xrentity{XR_SUCCEEDED}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool succeeded(Result v) { return static_cast<int>(v) >= 0; }

/*!
 * @brief Return true if the result is exactly equal to Result::Success.
 * Equivalent of XR_UNQUALIFIED_SUCCESS().
 * @found_by_adl
 * @see Result
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_UNQUALIFIED_SUCCESS>
 * @xrentity{XR_UNQUALIFIED_SUCCESS}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool unqualifiedSuccess(Result v) {
  return v == Result::Success;
}
//! @}

/*!
 * @brief `<` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Result lhs, int rhs) {
  return get(lhs) < rhs;
}

/*!
 * @brief `<` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(int lhs, Result rhs) {
  return lhs < get(rhs);
}

/*!
 * @brief `>` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Result lhs, int rhs) {
  return get(lhs) > rhs;
}

/*!
 * @brief `>` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(int lhs, Result rhs) {
  return lhs > get(rhs);
}

/*!
 * @brief `<=` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Result lhs, int rhs) {
  return get(lhs) <= rhs;
}

/*!
 * @brief `<=` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(int lhs, Result rhs) {
  return lhs <= get(rhs);
}

/*!
 * @brief `>=` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Result lhs, int rhs) {
  return get(lhs) >= rhs;
}

/*!
 * @brief `>=` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(int lhs, Result rhs) {
  return lhs >= get(rhs);
}

/*!
 * @brief `==` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Result lhs, int rhs) {
  return get(lhs) == rhs;
}

/*!
 * @brief `==` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(int lhs, Result rhs) {
  return lhs == get(rhs);
}

/*!
 * @brief `!=` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Result lhs, int rhs) {
  return get(lhs) != rhs;
}

/*!
 * @brief `!=` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(int lhs, Result rhs) {
  return lhs != get(rhs);
}

/*!
 * @brief Enum class for XrStructureType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrStructureType>
 *
 * @xrentity{XrStructureType}
 */
enum class StructureType : int32_t {

  Unknown = XR_TYPE_UNKNOWN,

  APILayerProperties = XR_TYPE_API_LAYER_PROPERTIES,

  ExtensionProperties = XR_TYPE_EXTENSION_PROPERTIES,

  InstanceCreateInfo = XR_TYPE_INSTANCE_CREATE_INFO,

  SystemGetInfo = XR_TYPE_SYSTEM_GET_INFO,

  SystemProperties = XR_TYPE_SYSTEM_PROPERTIES,

  ViewLocateInfo = XR_TYPE_VIEW_LOCATE_INFO,

  View = XR_TYPE_VIEW,

  SessionCreateInfo = XR_TYPE_SESSION_CREATE_INFO,

  SwapchainCreateInfo = XR_TYPE_SWAPCHAIN_CREATE_INFO,

  SessionBeginInfo = XR_TYPE_SESSION_BEGIN_INFO,

  ViewState = XR_TYPE_VIEW_STATE,

  FrameEndInfo = XR_TYPE_FRAME_END_INFO,

  HapticVibration = XR_TYPE_HAPTIC_VIBRATION,

  EventDataBuffer = XR_TYPE_EVENT_DATA_BUFFER,

  EventDataInstanceLossPending = XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING,

  EventDataSessionStateChanged = XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED,

  ActionStateBoolean = XR_TYPE_ACTION_STATE_BOOLEAN,

  ActionStateFloat = XR_TYPE_ACTION_STATE_FLOAT,

  ActionStateVector2F = XR_TYPE_ACTION_STATE_VECTOR2F,

  ActionStatePose = XR_TYPE_ACTION_STATE_POSE,

  ActionSetCreateInfo = XR_TYPE_ACTION_SET_CREATE_INFO,

  ActionCreateInfo = XR_TYPE_ACTION_CREATE_INFO,

  InstanceProperties = XR_TYPE_INSTANCE_PROPERTIES,

  FrameWaitInfo = XR_TYPE_FRAME_WAIT_INFO,

  CompositionLayerProjection = XR_TYPE_COMPOSITION_LAYER_PROJECTION,

  CompositionLayerQuad = XR_TYPE_COMPOSITION_LAYER_QUAD,

  ReferenceSpaceCreateInfo = XR_TYPE_REFERENCE_SPACE_CREATE_INFO,

  ActionSpaceCreateInfo = XR_TYPE_ACTION_SPACE_CREATE_INFO,

  EventDataReferenceSpaceChangePending = XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING,

  ViewConfigurationView = XR_TYPE_VIEW_CONFIGURATION_VIEW,

  SpaceLocation = XR_TYPE_SPACE_LOCATION,

  SpaceVelocity = XR_TYPE_SPACE_VELOCITY,

  FrameState = XR_TYPE_FRAME_STATE,

  ViewConfigurationProperties = XR_TYPE_VIEW_CONFIGURATION_PROPERTIES,

  FrameBeginInfo = XR_TYPE_FRAME_BEGIN_INFO,

  CompositionLayerProjectionView = XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW,

  EventDataEventsLost = XR_TYPE_EVENT_DATA_EVENTS_LOST,

  InteractionProfileSuggestedBinding = XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING,

  EventDataInteractionProfileChanged = XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED,

  InteractionProfileState = XR_TYPE_INTERACTION_PROFILE_STATE,

  SwapchainImageAcquireInfo = XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO,

  SwapchainImageWaitInfo = XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO,

  SwapchainImageReleaseInfo = XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO,

  ActionStateGetInfo = XR_TYPE_ACTION_STATE_GET_INFO,

  HapticActionInfo = XR_TYPE_HAPTIC_ACTION_INFO,

  SessionActionSetsAttachInfo = XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO,

  ActionsSyncInfo = XR_TYPE_ACTIONS_SYNC_INFO,

  BoundSourcesForActionEnumerateInfo = XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO,

  InputSourceLocalizedNameGetInfo = XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO,

#ifdef XR_KHR_composition_layer_cube
  CompositionLayerCubeKHR = XR_TYPE_COMPOSITION_LAYER_CUBE_KHR,
#endif  // XR_KHR_composition_layer_cube
#ifdef XR_KHR_android_create_instance
  InstanceCreateInfoAndroidKHR = XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR,
#endif  // XR_KHR_android_create_instance
#ifdef XR_KHR_composition_layer_depth
  CompositionLayerDepthInfoKHR = XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR,
#endif  // XR_KHR_composition_layer_depth
#ifdef XR_KHR_vulkan_swapchain_format_list
  VulkanSwapchainFormatListCreateInfoKHR = XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR,
#endif  // XR_KHR_vulkan_swapchain_format_list
#ifdef XR_EXT_performance_settings
  EventDataPerfSettingsEXT = XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT,
#endif  // XR_EXT_performance_settings
#ifdef XR_KHR_composition_layer_cylinder
  CompositionLayerCylinderKHR = XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR,
#endif  // XR_KHR_composition_layer_cylinder
#ifdef XR_KHR_composition_layer_equirect
  CompositionLayerEquirectKHR = XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR,
#endif  // XR_KHR_composition_layer_equirect
#ifdef XR_EXT_debug_utils
  DebugUtilsObjectNameInfoEXT = XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
  DebugUtilsMessengerCallbackDataEXT = XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
  DebugUtilsMessengerCreateInfoEXT = XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
  DebugUtilsLabelEXT = XR_TYPE_DEBUG_UTILS_LABEL_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLWin32KHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLXlibKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLXcbKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLWaylandKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  SwapchainImageOpenGLKHR = XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsRequirementsOpenGLKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_es_enable
  GraphicsBindingOpenGLESAndroidKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR,
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
  SwapchainImageOpenGLESKHR = XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR,
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
  GraphicsRequirementsOpenGLESKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR,
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_vulkan_enable
  GraphicsBindingVulkanKHR = XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR,
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
  SwapchainImageVulkanKHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR,
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
  GraphicsRequirementsVulkanKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR,
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_D3D11_enable
  GraphicsBindingD3D11KHR = XR_TYPE_GRAPHICS_BINDING_D3D11_KHR,
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
  SwapchainImageD3D11KHR = XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR,
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
  GraphicsRequirementsD3D11KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR,
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D12_enable
  GraphicsBindingD3D12KHR = XR_TYPE_GRAPHICS_BINDING_D3D12_KHR,
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
  SwapchainImageD3D12KHR = XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR,
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
  GraphicsRequirementsD3D12KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR,
#endif  // XR_KHR_D3D12_enable
#ifdef XR_EXT_eye_gaze_interaction
  SystemEyeGazeInteractionPropertiesEXT = XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT,
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_EXT_eye_gaze_interaction
  EyeGazeSampleTimeEXT = XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT,
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_KHR_visibility_mask
  VisibilityMaskKHR = XR_TYPE_VISIBILITY_MASK_KHR,
#endif  // XR_KHR_visibility_mask
#ifdef XR_KHR_visibility_mask
  EventDataVisibilityMaskChangedKHR = XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR,
#endif  // XR_KHR_visibility_mask
#ifdef XR_EXTX_overlay
  SessionCreateInfoOverlayEXTX = XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX,
#endif  // XR_EXTX_overlay
#ifdef XR_EXTX_overlay
  EventDataMainSessionVisibilityChangedEXTX =
      XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX,
#endif  // XR_EXTX_overlay
#ifdef XR_KHR_composition_layer_color_scale_bias
  CompositionLayerColorScaleBiasKHR = XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR,
#endif  // XR_KHR_composition_layer_color_scale_bias
#ifdef XR_MSFT_spatial_anchor
  SpatialAnchorCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor
  SpatialAnchorSpaceCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_FB_composition_layer_image_layout
  CompositionLayerImageLayoutFB = XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB,
#endif  // XR_FB_composition_layer_image_layout
#ifdef XR_FB_composition_layer_alpha_blend
  CompositionLayerAlphaBlendFB = XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB,
#endif  // XR_FB_composition_layer_alpha_blend
#ifdef XR_EXT_view_configuration_depth_range
  ViewConfigurationDepthRangeEXT = XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT,
#endif  // XR_EXT_view_configuration_depth_range
#ifdef XR_MNDX_egl_enable
  GraphicsBindingEGLMNDX = XR_TYPE_GRAPHICS_BINDING_EGL_MNDX,
#endif  // XR_MNDX_egl_enable
#ifdef XR_MSFT_spatial_graph_bridge
  SpatialGraphNodeSpaceCreateInfoMSFT = XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
  SystemHandTrackingPropertiesEXT = XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandTrackerCreateInfoEXT = XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandJointsLocateInfoEXT = XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandJointLocationsEXT = XR_TYPE_HAND_JOINT_LOCATIONS_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandJointVelocitiesEXT = XR_TYPE_HAND_JOINT_VELOCITIES_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_hand_tracking_mesh
  SystemHandTrackingMeshPropertiesMSFT = XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandMeshSpaceCreateInfoMSFT = XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandMeshUpdateInfoMSFT = XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandMeshMSFT = XR_TYPE_HAND_MESH_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandPoseTypeInfoMSFT = XR_TYPE_HAND_POSE_TYPE_INFO_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationSessionBeginInfoMSFT =
      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationStateMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationFrameStateMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationFrameEndInfoMSFT =
      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationLayerInfoMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationSwapchainCreateInfoMSFT =
      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
  ControllerModelKeyStateMSFT = XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelNodePropertiesMSFT = XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelPropertiesMSFT = XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelNodeStateMSFT = XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelStateMSFT = XR_TYPE_CONTROLLER_MODEL_STATE_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_EPIC_view_configuration_fov
  ViewConfigurationViewFovEPIC = XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC,
#endif  // XR_EPIC_view_configuration_fov
#ifdef XR_MSFT_holographic_window_attachment
  HolographicWindowAttachmentMSFT = XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT,
#endif  // XR_MSFT_holographic_window_attachment
#ifdef XR_MSFT_composition_layer_reprojection
  CompositionLayerReprojectionInfoMSFT = XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT,
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_composition_layer_reprojection
  CompositionLayerReprojectionPlaneOverrideMSFT =
      XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT,
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_FB_android_surface_swapchain_create
  AndroidSurfaceSwapchainCreateInfoFB = XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB,
#endif  // XR_FB_android_surface_swapchain_create
#ifdef XR_FB_composition_layer_secure_content
  CompositionLayerSecureContentFB = XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB,
#endif  // XR_FB_composition_layer_secure_content
#ifdef XR_VALVE_analog_threshold
  InteractionProfileAnalogThresholdVALVE = XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE,
#endif  // XR_VALVE_analog_threshold
#ifdef XR_EXT_hand_joints_motion_range
  HandJointsMotionRangeInfoEXT = XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT,
#endif  // XR_EXT_hand_joints_motion_range
#ifdef XR_KHR_loader_init_android
  LoaderInitInfoAndroidKHR = XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR,
#endif  // XR_KHR_loader_init_android
#ifdef XR_KHR_vulkan_enable2
  VulkanInstanceCreateInfoKHR = XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  VulkanDeviceCreateInfoKHR = XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  VulkanGraphicsDeviceGetInfoKHR = XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  GraphicsBindingVulkan2KHR = XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  SwapchainImageVulkan2KHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN2_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  GraphicsRequirementsVulkan2KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN2_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_composition_layer_equirect2
  CompositionLayerEquirect2KHR = XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR,
#endif  // XR_KHR_composition_layer_equirect2
#ifdef XR_MSFT_scene_understanding
  SceneObserverCreateInfoMSFT = XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneCreateInfoMSFT = XR_TYPE_SCENE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  NewSceneComputeInfoMSFT = XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  VisualMeshComputeLodInfoMSFT = XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentsMSFT = XR_TYPE_SCENE_COMPONENTS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentsGetInfoMSFT = XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentLocationsMSFT = XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentsLocateInfoMSFT = XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneObjectsMSFT = XR_TYPE_SCENE_OBJECTS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentParentFilterInfoMSFT = XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneObjectTypesFilterInfoMSFT = XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ScenePlanesMSFT = XR_TYPE_SCENE_PLANES_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ScenePlaneAlignmentFilterInfoMSFT = XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshesMSFT = XR_TYPE_SCENE_MESHES_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshBuffersGetInfoMSFT = XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshBuffersMSFT = XR_TYPE_SCENE_MESH_BUFFERS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshVertexBufferMSFT = XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshIndicesUint32MSFT = XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshIndicesUint16MSFT = XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding_serialization
  SerializedSceneFragmentDataGetInfoMSFT = XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_understanding_serialization
  SceneDeserializeInfoMSFT = XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_FB_display_refresh_rate
  EventDataDisplayRefreshRateChangedFB = XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB,
#endif  // XR_FB_display_refresh_rate
#ifdef XR_HTCX_vive_tracker_interaction
  ViveTrackerPathsHTCX = XR_TYPE_VIVE_TRACKER_PATHS_HTCX,
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTCX_vive_tracker_interaction
  EventDataViveTrackerConnectedHTCX = XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX,
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTC_facial_tracking
  SystemFacialTrackingPropertiesHTC = XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
  FacialTrackerCreateInfoHTC = XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
  FacialExpressionsHTC = XR_TYPE_FACIAL_EXPRESSIONS_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_color_space
  SystemColorSpacePropertiesFB = XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB,
#endif  // XR_FB_color_space
#ifdef XR_FB_hand_tracking_mesh
  HandTrackingMeshFB = XR_TYPE_HAND_TRACKING_MESH_FB,
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_mesh
  HandTrackingScaleFB = XR_TYPE_HAND_TRACKING_SCALE_FB,
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_aim
  HandTrackingAimStateFB = XR_TYPE_HAND_TRACKING_AIM_STATE_FB,
#endif  // XR_FB_hand_tracking_aim
#ifdef XR_FB_hand_tracking_capsules
  HandTrackingCapsulesStateFB = XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB,
#endif  // XR_FB_hand_tracking_capsules
#ifdef XR_FB_foveation
  FoveationProfileCreateInfoFB = XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
  SwapchainCreateInfoFoveationFB = XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
  SwapchainStateFoveationFB = XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation_configuration
  FoveationLevelProfileCreateInfoFB = XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB,
#endif  // XR_FB_foveation_configuration
#ifdef XR_FB_keyboard_tracking
  KeyboardSpaceCreateInfoFB = XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB,
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
  KeyboardTrackingQueryFB = XR_TYPE_KEYBOARD_TRACKING_QUERY_FB,
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
  SystemKeyboardTrackingPropertiesFB = XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB,
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_triangle_mesh
  TriangleMeshCreateInfoFB = XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB,
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
  SystemPassthroughPropertiesFB = XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughCreateInfoFB = XR_TYPE_PASSTHROUGH_CREATE_INFO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughLayerCreateInfoFB = XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  CompositionLayerPassthroughFB = XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  GeometryInstanceCreateInfoFB = XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  GeometryInstanceTransformFB = XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughStyleFB = XR_TYPE_PASSTHROUGH_STYLE_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughColorMapMonoToRgbaFB = XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughColorMapMonoToMonoFB = XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  EventDataPassthroughStateChangedFB = XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
  RenderModelPathInfoFB = XR_TYPE_RENDER_MODEL_PATH_INFO_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelPropertiesFB = XR_TYPE_RENDER_MODEL_PROPERTIES_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelBufferFB = XR_TYPE_RENDER_MODEL_BUFFER_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelLoadInfoFB = XR_TYPE_RENDER_MODEL_LOAD_INFO_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  SystemRenderModelPropertiesFB = XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB,
#endif  // XR_FB_render_model
#ifdef XR_KHR_binding_modification
  BindingModificationsKHR = XR_TYPE_BINDING_MODIFICATIONS_KHR,
#endif  // XR_KHR_binding_modification
#ifdef XR_VARJO_foveated_rendering
  ViewLocateFoveatedRenderingVARJO = XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
  FoveatedViewConfigurationViewVARJO = XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
  SystemFoveatedRenderingPropertiesVARJO = XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_composition_layer_depth_test
  CompositionLayerDepthTestVARJO = XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO,
#endif  // XR_VARJO_composition_layer_depth_test
#ifdef XR_VARJO_marker_tracking
  SystemMarkerTrackingPropertiesVARJO = XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
  EventDataMarkerTrackingUpdateVARJO = XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
  MarkerSpaceCreateInfoVARJO = XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_MSFT_spatial_anchor_persistence
  SpatialAnchorPersistenceInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT =
      XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_FB_foveation_vulkan
  SwapchainImageFoveationVulkanFB = XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB,
#endif  // XR_FB_foveation_vulkan
#ifdef XR_FB_swapchain_update_state_android_surface
  SwapchainStateAndroidSurfaceDimensionsFB = XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB,
#endif  // XR_FB_swapchain_update_state_android_surface
#ifdef XR_FB_swapchain_update_state_opengl_es
  SwapchainStateSamplerOpenGLESFB = XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB,
#endif  // XR_FB_swapchain_update_state_opengl_es
#ifdef XR_FB_swapchain_update_state_vulkan
  SwapchainStateSamplerVulkanFB = XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB,
#endif  // XR_FB_swapchain_update_state_vulkan
#ifdef XR_FB_space_warp
  CompositionLayerSpaceWarpInfoFB = XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB,
#endif  // XR_FB_space_warp
#ifdef XR_FB_space_warp
  SystemSpaceWarpPropertiesFB = XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB,
#endif  // XR_FB_space_warp
#ifdef XR_ALMALENCE_digital_lens_control
  DigitalLensControlALMALENCE = XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE,
#endif  // XR_ALMALENCE_digital_lens_control
#ifdef XR_FB_passthrough_keyboard_hands
  PassthroughKeyboardHandsIntensityFB = XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB,
#endif  // XR_FB_passthrough_keyboard_hands
};
static_assert(sizeof(StructureType) == sizeof(XrStructureType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrStructureType value from a StructureType.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrStructureType get(StructureType const& v) {
  return static_cast<XrStructureType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a StructureType value as a const char *.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(StructureType value) {
  switch (value) {
    case StructureType::Unknown:
      return "Unknown";

    case StructureType::APILayerProperties:
      return "APILayerProperties";

    case StructureType::ExtensionProperties:
      return "ExtensionProperties";

    case StructureType::InstanceCreateInfo:
      return "InstanceCreateInfo";

    case StructureType::SystemGetInfo:
      return "SystemGetInfo";

    case StructureType::SystemProperties:
      return "SystemProperties";

    case StructureType::ViewLocateInfo:
      return "ViewLocateInfo";

    case StructureType::View:
      return "View";

    case StructureType::SessionCreateInfo:
      return "SessionCreateInfo";

    case StructureType::SwapchainCreateInfo:
      return "SwapchainCreateInfo";

    case StructureType::SessionBeginInfo:
      return "SessionBeginInfo";

    case StructureType::ViewState:
      return "ViewState";

    case StructureType::FrameEndInfo:
      return "FrameEndInfo";

    case StructureType::HapticVibration:
      return "HapticVibration";

    case StructureType::EventDataBuffer:
      return "EventDataBuffer";

    case StructureType::EventDataInstanceLossPending:
      return "EventDataInstanceLossPending";

    case StructureType::EventDataSessionStateChanged:
      return "EventDataSessionStateChanged";

    case StructureType::ActionStateBoolean:
      return "ActionStateBoolean";

    case StructureType::ActionStateFloat:
      return "ActionStateFloat";

    case StructureType::ActionStateVector2F:
      return "ActionStateVector2F";

    case StructureType::ActionStatePose:
      return "ActionStatePose";

    case StructureType::ActionSetCreateInfo:
      return "ActionSetCreateInfo";

    case StructureType::ActionCreateInfo:
      return "ActionCreateInfo";

    case StructureType::InstanceProperties:
      return "InstanceProperties";

    case StructureType::FrameWaitInfo:
      return "FrameWaitInfo";

    case StructureType::CompositionLayerProjection:
      return "CompositionLayerProjection";

    case StructureType::CompositionLayerQuad:
      return "CompositionLayerQuad";

    case StructureType::ReferenceSpaceCreateInfo:
      return "ReferenceSpaceCreateInfo";

    case StructureType::ActionSpaceCreateInfo:
      return "ActionSpaceCreateInfo";

    case StructureType::EventDataReferenceSpaceChangePending:
      return "EventDataReferenceSpaceChangePending";

    case StructureType::ViewConfigurationView:
      return "ViewConfigurationView";

    case StructureType::SpaceLocation:
      return "SpaceLocation";

    case StructureType::SpaceVelocity:
      return "SpaceVelocity";

    case StructureType::FrameState:
      return "FrameState";

    case StructureType::ViewConfigurationProperties:
      return "ViewConfigurationProperties";

    case StructureType::FrameBeginInfo:
      return "FrameBeginInfo";

    case StructureType::CompositionLayerProjectionView:
      return "CompositionLayerProjectionView";

    case StructureType::EventDataEventsLost:
      return "EventDataEventsLost";

    case StructureType::InteractionProfileSuggestedBinding:
      return "InteractionProfileSuggestedBinding";

    case StructureType::EventDataInteractionProfileChanged:
      return "EventDataInteractionProfileChanged";

    case StructureType::InteractionProfileState:
      return "InteractionProfileState";

    case StructureType::SwapchainImageAcquireInfo:
      return "SwapchainImageAcquireInfo";

    case StructureType::SwapchainImageWaitInfo:
      return "SwapchainImageWaitInfo";

    case StructureType::SwapchainImageReleaseInfo:
      return "SwapchainImageReleaseInfo";

    case StructureType::ActionStateGetInfo:
      return "ActionStateGetInfo";

    case StructureType::HapticActionInfo:
      return "HapticActionInfo";

    case StructureType::SessionActionSetsAttachInfo:
      return "SessionActionSetsAttachInfo";

    case StructureType::ActionsSyncInfo:
      return "ActionsSyncInfo";

    case StructureType::BoundSourcesForActionEnumerateInfo:
      return "BoundSourcesForActionEnumerateInfo";

    case StructureType::InputSourceLocalizedNameGetInfo:
      return "InputSourceLocalizedNameGetInfo";

#ifdef XR_KHR_composition_layer_cube
    case StructureType::CompositionLayerCubeKHR:
      return "CompositionLayerCubeKHR";
#endif  // XR_KHR_composition_layer_cube
#ifdef XR_KHR_android_create_instance
    case StructureType::InstanceCreateInfoAndroidKHR:
      return "InstanceCreateInfoAndroidKHR";
#endif  // XR_KHR_android_create_instance
#ifdef XR_KHR_composition_layer_depth
    case StructureType::CompositionLayerDepthInfoKHR:
      return "CompositionLayerDepthInfoKHR";
#endif  // XR_KHR_composition_layer_depth
#ifdef XR_KHR_vulkan_swapchain_format_list
    case StructureType::VulkanSwapchainFormatListCreateInfoKHR:
      return "VulkanSwapchainFormatListCreateInfoKHR";
#endif  // XR_KHR_vulkan_swapchain_format_list
#ifdef XR_EXT_performance_settings
    case StructureType::EventDataPerfSettingsEXT:
      return "EventDataPerfSettingsEXT";
#endif  // XR_EXT_performance_settings
#ifdef XR_KHR_composition_layer_cylinder
    case StructureType::CompositionLayerCylinderKHR:
      return "CompositionLayerCylinderKHR";
#endif  // XR_KHR_composition_layer_cylinder
#ifdef XR_KHR_composition_layer_equirect
    case StructureType::CompositionLayerEquirectKHR:
      return "CompositionLayerEquirectKHR";
#endif  // XR_KHR_composition_layer_equirect
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsObjectNameInfoEXT:
      return "DebugUtilsObjectNameInfoEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsMessengerCallbackDataEXT:
      return "DebugUtilsMessengerCallbackDataEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsMessengerCreateInfoEXT:
      return "DebugUtilsMessengerCreateInfoEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsLabelEXT:
      return "DebugUtilsLabelEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLWin32KHR:
      return "GraphicsBindingOpenGLWin32KHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLXlibKHR:
      return "GraphicsBindingOpenGLXlibKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLXcbKHR:
      return "GraphicsBindingOpenGLXcbKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLWaylandKHR:
      return "GraphicsBindingOpenGLWaylandKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::SwapchainImageOpenGLKHR:
      return "SwapchainImageOpenGLKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsRequirementsOpenGLKHR:
      return "GraphicsRequirementsOpenGLKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_es_enable
    case StructureType::GraphicsBindingOpenGLESAndroidKHR:
      return "GraphicsBindingOpenGLESAndroidKHR";
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
    case StructureType::SwapchainImageOpenGLESKHR:
      return "SwapchainImageOpenGLESKHR";
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
    case StructureType::GraphicsRequirementsOpenGLESKHR:
      return "GraphicsRequirementsOpenGLESKHR";
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_vulkan_enable
    case StructureType::GraphicsBindingVulkanKHR:
      return "GraphicsBindingVulkanKHR";
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
    case StructureType::SwapchainImageVulkanKHR:
      return "SwapchainImageVulkanKHR";
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
    case StructureType::GraphicsRequirementsVulkanKHR:
      return "GraphicsRequirementsVulkanKHR";
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_D3D11_enable
    case StructureType::GraphicsBindingD3D11KHR:
      return "GraphicsBindingD3D11KHR";
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
    case StructureType::SwapchainImageD3D11KHR:
      return "SwapchainImageD3D11KHR";
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
    case StructureType::GraphicsRequirementsD3D11KHR:
      return "GraphicsRequirementsD3D11KHR";
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D12_enable
    case StructureType::GraphicsBindingD3D12KHR:
      return "GraphicsBindingD3D12KHR";
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
    case StructureType::SwapchainImageD3D12KHR:
      return "SwapchainImageD3D12KHR";
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
    case StructureType::GraphicsRequirementsD3D12KHR:
      return "GraphicsRequirementsD3D12KHR";
#endif  // XR_KHR_D3D12_enable
#ifdef XR_EXT_eye_gaze_interaction
    case StructureType::SystemEyeGazeInteractionPropertiesEXT:
      return "SystemEyeGazeInteractionPropertiesEXT";
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_EXT_eye_gaze_interaction
    case StructureType::EyeGazeSampleTimeEXT:
      return "EyeGazeSampleTimeEXT";
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_KHR_visibility_mask
    case StructureType::VisibilityMaskKHR:
      return "VisibilityMaskKHR";
#endif  // XR_KHR_visibility_mask
#ifdef XR_KHR_visibility_mask
    case StructureType::EventDataVisibilityMaskChangedKHR:
      return "EventDataVisibilityMaskChangedKHR";
#endif  // XR_KHR_visibility_mask
#ifdef XR_EXTX_overlay
    case StructureType::SessionCreateInfoOverlayEXTX:
      return "SessionCreateInfoOverlayEXTX";
#endif  // XR_EXTX_overlay
#ifdef XR_EXTX_overlay
    case StructureType::EventDataMainSessionVisibilityChangedEXTX:
      return "EventDataMainSessionVisibilityChangedEXTX";
#endif  // XR_EXTX_overlay
#ifdef XR_KHR_composition_layer_color_scale_bias
    case StructureType::CompositionLayerColorScaleBiasKHR:
      return "CompositionLayerColorScaleBiasKHR";
#endif  // XR_KHR_composition_layer_color_scale_bias
#ifdef XR_MSFT_spatial_anchor
    case StructureType::SpatialAnchorCreateInfoMSFT:
      return "SpatialAnchorCreateInfoMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor
    case StructureType::SpatialAnchorSpaceCreateInfoMSFT:
      return "SpatialAnchorSpaceCreateInfoMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_FB_composition_layer_image_layout
    case StructureType::CompositionLayerImageLayoutFB:
      return "CompositionLayerImageLayoutFB";
#endif  // XR_FB_composition_layer_image_layout
#ifdef XR_FB_composition_layer_alpha_blend
    case StructureType::CompositionLayerAlphaBlendFB:
      return "CompositionLayerAlphaBlendFB";
#endif  // XR_FB_composition_layer_alpha_blend
#ifdef XR_EXT_view_configuration_depth_range
    case StructureType::ViewConfigurationDepthRangeEXT:
      return "ViewConfigurationDepthRangeEXT";
#endif  // XR_EXT_view_configuration_depth_range
#ifdef XR_MNDX_egl_enable
    case StructureType::GraphicsBindingEGLMNDX:
      return "GraphicsBindingEGLMNDX";
#endif  // XR_MNDX_egl_enable
#ifdef XR_MSFT_spatial_graph_bridge
    case StructureType::SpatialGraphNodeSpaceCreateInfoMSFT:
      return "SpatialGraphNodeSpaceCreateInfoMSFT";
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
    case StructureType::SystemHandTrackingPropertiesEXT:
      return "SystemHandTrackingPropertiesEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandTrackerCreateInfoEXT:
      return "HandTrackerCreateInfoEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandJointsLocateInfoEXT:
      return "HandJointsLocateInfoEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandJointLocationsEXT:
      return "HandJointLocationsEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandJointVelocitiesEXT:
      return "HandJointVelocitiesEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::SystemHandTrackingMeshPropertiesMSFT:
      return "SystemHandTrackingMeshPropertiesMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandMeshSpaceCreateInfoMSFT:
      return "HandMeshSpaceCreateInfoMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandMeshUpdateInfoMSFT:
      return "HandMeshUpdateInfoMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandMeshMSFT:
      return "HandMeshMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandPoseTypeInfoMSFT:
      return "HandPoseTypeInfoMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT:
      return "SecondaryViewConfigurationSessionBeginInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationStateMSFT:
      return "SecondaryViewConfigurationStateMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationFrameStateMSFT:
      return "SecondaryViewConfigurationFrameStateMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationFrameEndInfoMSFT:
      return "SecondaryViewConfigurationFrameEndInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationLayerInfoMSFT:
      return "SecondaryViewConfigurationLayerInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT:
      return "SecondaryViewConfigurationSwapchainCreateInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelKeyStateMSFT:
      return "ControllerModelKeyStateMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelNodePropertiesMSFT:
      return "ControllerModelNodePropertiesMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelPropertiesMSFT:
      return "ControllerModelPropertiesMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelNodeStateMSFT:
      return "ControllerModelNodeStateMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelStateMSFT:
      return "ControllerModelStateMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_EPIC_view_configuration_fov
    case StructureType::ViewConfigurationViewFovEPIC:
      return "ViewConfigurationViewFovEPIC";
#endif  // XR_EPIC_view_configuration_fov
#ifdef XR_MSFT_holographic_window_attachment
    case StructureType::HolographicWindowAttachmentMSFT:
      return "HolographicWindowAttachmentMSFT";
#endif  // XR_MSFT_holographic_window_attachment
#ifdef XR_MSFT_composition_layer_reprojection
    case StructureType::CompositionLayerReprojectionInfoMSFT:
      return "CompositionLayerReprojectionInfoMSFT";
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_composition_layer_reprojection
    case StructureType::CompositionLayerReprojectionPlaneOverrideMSFT:
      return "CompositionLayerReprojectionPlaneOverrideMSFT";
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_FB_android_surface_swapchain_create
    case StructureType::AndroidSurfaceSwapchainCreateInfoFB:
      return "AndroidSurfaceSwapchainCreateInfoFB";
#endif  // XR_FB_android_surface_swapchain_create
#ifdef XR_FB_composition_layer_secure_content
    case StructureType::CompositionLayerSecureContentFB:
      return "CompositionLayerSecureContentFB";
#endif  // XR_FB_composition_layer_secure_content
#ifdef XR_VALVE_analog_threshold
    case StructureType::InteractionProfileAnalogThresholdVALVE:
      return "InteractionProfileAnalogThresholdVALVE";
#endif  // XR_VALVE_analog_threshold
#ifdef XR_EXT_hand_joints_motion_range
    case StructureType::HandJointsMotionRangeInfoEXT:
      return "HandJointsMotionRangeInfoEXT";
#endif  // XR_EXT_hand_joints_motion_range
#ifdef XR_KHR_loader_init_android
    case StructureType::LoaderInitInfoAndroidKHR:
      return "LoaderInitInfoAndroidKHR";
#endif  // XR_KHR_loader_init_android
#ifdef XR_KHR_vulkan_enable2
    case StructureType::VulkanInstanceCreateInfoKHR:
      return "VulkanInstanceCreateInfoKHR";
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
    case StructureType::VulkanDeviceCreateInfoKHR:
      return "VulkanDeviceCreateInfoKHR";
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
    case StructureType::VulkanGraphicsDeviceGetInfoKHR:
      return "VulkanGraphicsDeviceGetInfoKHR";
#endif  // XR_KHR_vulkan_enable2
        // GraphicsBindingVulkan2KHR is an alias for GraphicsBindingVulkanKHR
        // SwapchainImageVulkan2KHR is an alias for SwapchainImageVulkanKHR
        // GraphicsRequirementsVulkan2KHR is an alias for GraphicsRequirementsVulkanKHR
#ifdef XR_KHR_composition_layer_equirect2
    case StructureType::CompositionLayerEquirect2KHR:
      return "CompositionLayerEquirect2KHR";
#endif  // XR_KHR_composition_layer_equirect2
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneObserverCreateInfoMSFT:
      return "SceneObserverCreateInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneCreateInfoMSFT:
      return "SceneCreateInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::NewSceneComputeInfoMSFT:
      return "NewSceneComputeInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::VisualMeshComputeLodInfoMSFT:
      return "VisualMeshComputeLodInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentsMSFT:
      return "SceneComponentsMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentsGetInfoMSFT:
      return "SceneComponentsGetInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentLocationsMSFT:
      return "SceneComponentLocationsMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentsLocateInfoMSFT:
      return "SceneComponentsLocateInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneObjectsMSFT:
      return "SceneObjectsMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentParentFilterInfoMSFT:
      return "SceneComponentParentFilterInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneObjectTypesFilterInfoMSFT:
      return "SceneObjectTypesFilterInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::ScenePlanesMSFT:
      return "ScenePlanesMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::ScenePlaneAlignmentFilterInfoMSFT:
      return "ScenePlaneAlignmentFilterInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshesMSFT:
      return "SceneMeshesMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshBuffersGetInfoMSFT:
      return "SceneMeshBuffersGetInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshBuffersMSFT:
      return "SceneMeshBuffersMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshVertexBufferMSFT:
      return "SceneMeshVertexBufferMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshIndicesUint32MSFT:
      return "SceneMeshIndicesUint32MSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshIndicesUint16MSFT:
      return "SceneMeshIndicesUint16MSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding_serialization
    case StructureType::SerializedSceneFragmentDataGetInfoMSFT:
      return "SerializedSceneFragmentDataGetInfoMSFT";
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_understanding_serialization
    case StructureType::SceneDeserializeInfoMSFT:
      return "SceneDeserializeInfoMSFT";
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_FB_display_refresh_rate
    case StructureType::EventDataDisplayRefreshRateChangedFB:
      return "EventDataDisplayRefreshRateChangedFB";
#endif  // XR_FB_display_refresh_rate
#ifdef XR_HTCX_vive_tracker_interaction
    case StructureType::ViveTrackerPathsHTCX:
      return "ViveTrackerPathsHTCX";
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTCX_vive_tracker_interaction
    case StructureType::EventDataViveTrackerConnectedHTCX:
      return "EventDataViveTrackerConnectedHTCX";
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTC_facial_tracking
    case StructureType::SystemFacialTrackingPropertiesHTC:
      return "SystemFacialTrackingPropertiesHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
    case StructureType::FacialTrackerCreateInfoHTC:
      return "FacialTrackerCreateInfoHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
    case StructureType::FacialExpressionsHTC:
      return "FacialExpressionsHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_color_space
    case StructureType::SystemColorSpacePropertiesFB:
      return "SystemColorSpacePropertiesFB";
#endif  // XR_FB_color_space
#ifdef XR_FB_hand_tracking_mesh
    case StructureType::HandTrackingMeshFB:
      return "HandTrackingMeshFB";
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_mesh
    case StructureType::HandTrackingScaleFB:
      return "HandTrackingScaleFB";
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_aim
    case StructureType::HandTrackingAimStateFB:
      return "HandTrackingAimStateFB";
#endif  // XR_FB_hand_tracking_aim
#ifdef XR_FB_hand_tracking_capsules
    case StructureType::HandTrackingCapsulesStateFB:
      return "HandTrackingCapsulesStateFB";
#endif  // XR_FB_hand_tracking_capsules
#ifdef XR_FB_foveation
    case StructureType::FoveationProfileCreateInfoFB:
      return "FoveationProfileCreateInfoFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
    case StructureType::SwapchainCreateInfoFoveationFB:
      return "SwapchainCreateInfoFoveationFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
    case StructureType::SwapchainStateFoveationFB:
      return "SwapchainStateFoveationFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation_configuration
    case StructureType::FoveationLevelProfileCreateInfoFB:
      return "FoveationLevelProfileCreateInfoFB";
#endif  // XR_FB_foveation_configuration
#ifdef XR_FB_keyboard_tracking
    case StructureType::KeyboardSpaceCreateInfoFB:
      return "KeyboardSpaceCreateInfoFB";
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
    case StructureType::KeyboardTrackingQueryFB:
      return "KeyboardTrackingQueryFB";
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
    case StructureType::SystemKeyboardTrackingPropertiesFB:
      return "SystemKeyboardTrackingPropertiesFB";
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_triangle_mesh
    case StructureType::TriangleMeshCreateInfoFB:
      return "TriangleMeshCreateInfoFB";
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
    case StructureType::SystemPassthroughPropertiesFB:
      return "SystemPassthroughPropertiesFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughCreateInfoFB:
      return "PassthroughCreateInfoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughLayerCreateInfoFB:
      return "PassthroughLayerCreateInfoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::CompositionLayerPassthroughFB:
      return "CompositionLayerPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::GeometryInstanceCreateInfoFB:
      return "GeometryInstanceCreateInfoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::GeometryInstanceTransformFB:
      return "GeometryInstanceTransformFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughStyleFB:
      return "PassthroughStyleFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughColorMapMonoToRgbaFB:
      return "PassthroughColorMapMonoToRgbaFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughColorMapMonoToMonoFB:
      return "PassthroughColorMapMonoToMonoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::EventDataPassthroughStateChangedFB:
      return "EventDataPassthroughStateChangedFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
    case StructureType::RenderModelPathInfoFB:
      return "RenderModelPathInfoFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelPropertiesFB:
      return "RenderModelPropertiesFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelBufferFB:
      return "RenderModelBufferFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelLoadInfoFB:
      return "RenderModelLoadInfoFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::SystemRenderModelPropertiesFB:
      return "SystemRenderModelPropertiesFB";
#endif  // XR_FB_render_model
#ifdef XR_KHR_binding_modification
    case StructureType::BindingModificationsKHR:
      return "BindingModificationsKHR";
#endif  // XR_KHR_binding_modification
#ifdef XR_VARJO_foveated_rendering
    case StructureType::ViewLocateFoveatedRenderingVARJO:
      return "ViewLocateFoveatedRenderingVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
    case StructureType::FoveatedViewConfigurationViewVARJO:
      return "FoveatedViewConfigurationViewVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
    case StructureType::SystemFoveatedRenderingPropertiesVARJO:
      return "SystemFoveatedRenderingPropertiesVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_composition_layer_depth_test
    case StructureType::CompositionLayerDepthTestVARJO:
      return "CompositionLayerDepthTestVARJO";
#endif  // XR_VARJO_composition_layer_depth_test
#ifdef XR_VARJO_marker_tracking
    case StructureType::SystemMarkerTrackingPropertiesVARJO:
      return "SystemMarkerTrackingPropertiesVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
    case StructureType::EventDataMarkerTrackingUpdateVARJO:
      return "EventDataMarkerTrackingUpdateVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
    case StructureType::MarkerSpaceCreateInfoVARJO:
      return "MarkerSpaceCreateInfoVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_MSFT_spatial_anchor_persistence
    case StructureType::SpatialAnchorPersistenceInfoMSFT:
      return "SpatialAnchorPersistenceInfoMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
    case StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT:
      return "SpatialAnchorFromPersistedAnchorCreateInfoMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_FB_foveation_vulkan
    case StructureType::SwapchainImageFoveationVulkanFB:
      return "SwapchainImageFoveationVulkanFB";
#endif  // XR_FB_foveation_vulkan
#ifdef XR_FB_swapchain_update_state_android_surface
    case StructureType::SwapchainStateAndroidSurfaceDimensionsFB:
      return "SwapchainStateAndroidSurfaceDimensionsFB";
#endif  // XR_FB_swapchain_update_state_android_surface
#ifdef XR_FB_swapchain_update_state_opengl_es
    case StructureType::SwapchainStateSamplerOpenGLESFB:
      return "SwapchainStateSamplerOpenGLESFB";
#endif  // XR_FB_swapchain_update_state_opengl_es
#ifdef XR_FB_swapchain_update_state_vulkan
    case StructureType::SwapchainStateSamplerVulkanFB:
      return "SwapchainStateSamplerVulkanFB";
#endif  // XR_FB_swapchain_update_state_vulkan
#ifdef XR_FB_space_warp
    case StructureType::CompositionLayerSpaceWarpInfoFB:
      return "CompositionLayerSpaceWarpInfoFB";
#endif  // XR_FB_space_warp
#ifdef XR_FB_space_warp
    case StructureType::SystemSpaceWarpPropertiesFB:
      return "SystemSpaceWarpPropertiesFB";
#endif  // XR_FB_space_warp
#ifdef XR_ALMALENCE_digital_lens_control
    case StructureType::DigitalLensControlALMALENCE:
      return "DigitalLensControlALMALENCE";
#endif  // XR_ALMALENCE_digital_lens_control
#ifdef XR_FB_passthrough_keyboard_hands
    case StructureType::PassthroughKeyboardHandsIntensityFB:
      return "PassthroughKeyboardHandsIntensityFB";
#endif  // XR_FB_passthrough_keyboard_hands
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a StructureType value as a std::string.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(StructureType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrFormFactor
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFormFactor>
 *
 * @xrentity{XrFormFactor}
 */
enum class FormFactor : int32_t {

  HeadMountedDisplay = XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY,

  HandheldDisplay = XR_FORM_FACTOR_HANDHELD_DISPLAY,

};
static_assert(sizeof(FormFactor) == sizeof(XrFormFactor),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFormFactor value from a FormFactor.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFormFactor get(FormFactor const& v) {
  return static_cast<XrFormFactor>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FormFactor value as a const char *.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FormFactor value) {
  switch (value) {
    case FormFactor::HeadMountedDisplay:
      return "HeadMountedDisplay";

    case FormFactor::HandheldDisplay:
      return "HandheldDisplay";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FormFactor value as a std::string.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FormFactor value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrViewConfigurationType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationType>
 *
 * @xrentity{XrViewConfigurationType}
 */
enum class ViewConfigurationType : int32_t {

  PrimaryMono = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO,

  PrimaryStereo = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,

#ifdef XR_VARJO_quad_views
  PrimaryQuadVARJO = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO,
#endif  // XR_VARJO_quad_views
#ifdef XR_MSFT_first_person_observer
  SecondaryMonoFirstPersonObserverMSFT =
      XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT,
#endif  // XR_MSFT_first_person_observer
};
static_assert(sizeof(ViewConfigurationType) == sizeof(XrViewConfigurationType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrViewConfigurationType value from a
 * ViewConfigurationType.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrViewConfigurationType get(ViewConfigurationType const& v) {
  return static_cast<XrViewConfigurationType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ViewConfigurationType value as a const
 * char *.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ViewConfigurationType value) {
  switch (value) {
    case ViewConfigurationType::PrimaryMono:
      return "PrimaryMono";

    case ViewConfigurationType::PrimaryStereo:
      return "PrimaryStereo";

#ifdef XR_VARJO_quad_views
    case ViewConfigurationType::PrimaryQuadVARJO:
      return "PrimaryQuadVARJO";
#endif  // XR_VARJO_quad_views
#ifdef XR_MSFT_first_person_observer
    case ViewConfigurationType::SecondaryMonoFirstPersonObserverMSFT:
      return "SecondaryMonoFirstPersonObserverMSFT";
#endif  // XR_MSFT_first_person_observer
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ViewConfigurationType value as a
 * std::string.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ViewConfigurationType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrEnvironmentBlendMode
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentBlendMode>
 *
 * @xrentity{XrEnvironmentBlendMode}
 */
enum class EnvironmentBlendMode : int32_t {

  Opaque = XR_ENVIRONMENT_BLEND_MODE_OPAQUE,

  Additive = XR_ENVIRONMENT_BLEND_MODE_ADDITIVE,

  AlphaBlend = XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND,

};
static_assert(sizeof(EnvironmentBlendMode) == sizeof(XrEnvironmentBlendMode),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEnvironmentBlendMode value from a
 * EnvironmentBlendMode.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEnvironmentBlendMode get(EnvironmentBlendMode const& v) {
  return static_cast<XrEnvironmentBlendMode>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EnvironmentBlendMode value as a const
 * char *.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    EnvironmentBlendMode value) {
  switch (value) {
    case EnvironmentBlendMode::Opaque:
      return "Opaque";

    case EnvironmentBlendMode::Additive:
      return "Additive";

    case EnvironmentBlendMode::AlphaBlend:
      return "AlphaBlend";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EnvironmentBlendMode value as a
 * std::string.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EnvironmentBlendMode value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrReferenceSpaceType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceType>
 *
 * @xrentity{XrReferenceSpaceType}
 */
enum class ReferenceSpaceType : int32_t {

  View = XR_REFERENCE_SPACE_TYPE_VIEW,

  Local = XR_REFERENCE_SPACE_TYPE_LOCAL,

  Stage = XR_REFERENCE_SPACE_TYPE_STAGE,

#ifdef XR_MSFT_unbounded_reference_space
  UnboundedMSFT = XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT,
#endif  // XR_MSFT_unbounded_reference_space
#ifdef XR_VARJO_foveated_rendering
  CombinedEyeVARJO = XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO,
#endif  // XR_VARJO_foveated_rendering
};
static_assert(sizeof(ReferenceSpaceType) == sizeof(XrReferenceSpaceType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReferenceSpaceType value from a ReferenceSpaceType.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrReferenceSpaceType get(ReferenceSpaceType const& v) {
  return static_cast<XrReferenceSpaceType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ReferenceSpaceType value as a const char
 * *.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ReferenceSpaceType value) {
  switch (value) {
    case ReferenceSpaceType::View:
      return "View";

    case ReferenceSpaceType::Local:
      return "Local";

    case ReferenceSpaceType::Stage:
      return "Stage";

#ifdef XR_MSFT_unbounded_reference_space
    case ReferenceSpaceType::UnboundedMSFT:
      return "UnboundedMSFT";
#endif  // XR_MSFT_unbounded_reference_space
#ifdef XR_VARJO_foveated_rendering
    case ReferenceSpaceType::CombinedEyeVARJO:
      return "CombinedEyeVARJO";
#endif  // XR_VARJO_foveated_rendering
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ReferenceSpaceType value as a
 * std::string.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ReferenceSpaceType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrActionType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionType>
 *
 * @xrentity{XrActionType}
 */
enum class ActionType : int32_t {

  BooleanInput = XR_ACTION_TYPE_BOOLEAN_INPUT,

  FloatInput = XR_ACTION_TYPE_FLOAT_INPUT,

  Vector2FInput = XR_ACTION_TYPE_VECTOR2F_INPUT,

  PoseInput = XR_ACTION_TYPE_POSE_INPUT,

  VibrationOutput = XR_ACTION_TYPE_VIBRATION_OUTPUT,

};
static_assert(sizeof(ActionType) == sizeof(XrActionType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrActionType value from a ActionType.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrActionType get(ActionType const& v) {
  return static_cast<XrActionType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ActionType value as a const char *.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ActionType value) {
  switch (value) {
    case ActionType::BooleanInput:
      return "BooleanInput";

    case ActionType::FloatInput:
      return "FloatInput";

    case ActionType::Vector2FInput:
      return "Vector2FInput";

    case ActionType::PoseInput:
      return "PoseInput";

    case ActionType::VibrationOutput:
      return "VibrationOutput";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ActionType value as a std::string.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ActionType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrEyeVisibility
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeVisibility>
 *
 * @xrentity{XrEyeVisibility}
 */
enum class EyeVisibility : int32_t {

  Both = XR_EYE_VISIBILITY_BOTH,

  Left = XR_EYE_VISIBILITY_LEFT,

  Right = XR_EYE_VISIBILITY_RIGHT,

};
static_assert(sizeof(EyeVisibility) == sizeof(XrEyeVisibility),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeVisibility value from a EyeVisibility.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeVisibility get(EyeVisibility const& v) {
  return static_cast<XrEyeVisibility>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeVisibility value as a const char *.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyeVisibility value) {
  switch (value) {
    case EyeVisibility::Both:
      return "Both";

    case EyeVisibility::Left:
      return "Left";

    case EyeVisibility::Right:
      return "Right";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EyeVisibility value as a std::string.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeVisibility value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrSessionState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionState>
 *
 * @xrentity{XrSessionState}
 */
enum class SessionState : int32_t {

  Unknown = XR_SESSION_STATE_UNKNOWN,

  Idle = XR_SESSION_STATE_IDLE,

  Ready = XR_SESSION_STATE_READY,

  Synchronized = XR_SESSION_STATE_SYNCHRONIZED,

  Visible = XR_SESSION_STATE_VISIBLE,

  Focused = XR_SESSION_STATE_FOCUSED,

  Stopping = XR_SESSION_STATE_STOPPING,

  LossPending = XR_SESSION_STATE_LOSS_PENDING,

  Exiting = XR_SESSION_STATE_EXITING,

};
static_assert(sizeof(SessionState) == sizeof(XrSessionState),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSessionState value from a SessionState.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSessionState get(SessionState const& v) {
  return static_cast<XrSessionState>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SessionState value as a const char *.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SessionState value) {
  switch (value) {
    case SessionState::Unknown:
      return "Unknown";

    case SessionState::Idle:
      return "Idle";

    case SessionState::Ready:
      return "Ready";

    case SessionState::Synchronized:
      return "Synchronized";

    case SessionState::Visible:
      return "Visible";

    case SessionState::Focused:
      return "Focused";

    case SessionState::Stopping:
      return "Stopping";

    case SessionState::LossPending:
      return "LossPending";

    case SessionState::Exiting:
      return "Exiting";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SessionState value as a std::string.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SessionState value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrObjectType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrObjectType>
 *
 * @xrentity{XrObjectType}
 */
enum class ObjectType : int32_t {

  Unknown = XR_OBJECT_TYPE_UNKNOWN,

  Instance = XR_OBJECT_TYPE_INSTANCE,

  Session = XR_OBJECT_TYPE_SESSION,

  Swapchain = XR_OBJECT_TYPE_SWAPCHAIN,

  Space = XR_OBJECT_TYPE_SPACE,

  ActionSet = XR_OBJECT_TYPE_ACTION_SET,

  Action = XR_OBJECT_TYPE_ACTION,

#ifdef XR_EXT_debug_utils
  DebugUtilsMessengerEXT = XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor
  SpatialAnchorMSFT = XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_EXT_hand_tracking
  HandTrackerEXT = XR_OBJECT_TYPE_HAND_TRACKER_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_scene_understanding
  SceneObserverMSFT = XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMSFT = XR_OBJECT_TYPE_SCENE_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_HTC_facial_tracking
  FacialTrackerHTC = XR_OBJECT_TYPE_FACIAL_TRACKER_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_foveation
  FoveationProfileFB = XR_OBJECT_TYPE_FOVEATION_PROFILE_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_triangle_mesh
  TriangleMeshFB = XR_OBJECT_TYPE_TRIANGLE_MESH_FB,
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
  PassthroughFB = XR_OBJECT_TYPE_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughLayerFB = XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  GeometryInstanceFB = XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB,
#endif  // XR_FB_passthrough
#ifdef XR_MSFT_spatial_anchor_persistence
  SpatialAnchorStoreConnectionMSFT = XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
};
static_assert(sizeof(ObjectType) == sizeof(XrObjectType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrObjectType value from a ObjectType.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrObjectType get(ObjectType const& v) {
  return static_cast<XrObjectType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ObjectType value as a const char *.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ObjectType value) {
  switch (value) {
    case ObjectType::Unknown:
      return "Unknown";

    case ObjectType::Instance:
      return "Instance";

    case ObjectType::Session:
      return "Session";

    case ObjectType::Swapchain:
      return "Swapchain";

    case ObjectType::Space:
      return "Space";

    case ObjectType::ActionSet:
      return "ActionSet";

    case ObjectType::Action:
      return "Action";

#ifdef XR_EXT_debug_utils
    case ObjectType::DebugUtilsMessengerEXT:
      return "DebugUtilsMessengerEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor
    case ObjectType::SpatialAnchorMSFT:
      return "SpatialAnchorMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_EXT_hand_tracking
    case ObjectType::HandTrackerEXT:
      return "HandTrackerEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_scene_understanding
    case ObjectType::SceneObserverMSFT:
      return "SceneObserverMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case ObjectType::SceneMSFT:
      return "SceneMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_HTC_facial_tracking
    case ObjectType::FacialTrackerHTC:
      return "FacialTrackerHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_foveation
    case ObjectType::FoveationProfileFB:
      return "FoveationProfileFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_triangle_mesh
    case ObjectType::TriangleMeshFB:
      return "TriangleMeshFB";
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
    case ObjectType::PassthroughFB:
      return "PassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case ObjectType::PassthroughLayerFB:
      return "PassthroughLayerFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case ObjectType::GeometryInstanceFB:
      return "GeometryInstanceFB";
#endif  // XR_FB_passthrough
#ifdef XR_MSFT_spatial_anchor_persistence
    case ObjectType::SpatialAnchorStoreConnectionMSFT:
      return "SpatialAnchorStoreConnectionMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ObjectType value as a std::string.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ObjectType value) {
  return {to_string_literal(value)};
}
//! @}

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * @brief Enum class for XrAndroidThreadTypeKHR
 *
 * Provided by the `XR_KHR_android_thread_settings` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAndroidThreadTypeKHR>
 *
 * @xrentity{XrAndroidThreadTypeKHR}
 */
enum class AndroidThreadTypeKHR : int32_t {

  ApplicationMain = XR_ANDROID_THREAD_TYPE_APPLICATION_MAIN_KHR,

  ApplicationWorker = XR_ANDROID_THREAD_TYPE_APPLICATION_WORKER_KHR,

  RendererMain = XR_ANDROID_THREAD_TYPE_RENDERER_MAIN_KHR,

  RendererWorker = XR_ANDROID_THREAD_TYPE_RENDERER_WORKER_KHR,

};
static_assert(sizeof(AndroidThreadTypeKHR) == sizeof(XrAndroidThreadTypeKHR),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrAndroidThreadTypeKHR value from a
 * AndroidThreadTypeKHR.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrAndroidThreadTypeKHR get(AndroidThreadTypeKHR const& v) {
  return static_cast<XrAndroidThreadTypeKHR>(v);
}

/*!
 * @brief Free function for retrieving the string name of a AndroidThreadTypeKHR value as a const
 * char *.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    AndroidThreadTypeKHR value) {
  switch (value) {
    case AndroidThreadTypeKHR::ApplicationMain:
      return "ApplicationMain";

    case AndroidThreadTypeKHR::ApplicationWorker:
      return "ApplicationWorker";

    case AndroidThreadTypeKHR::RendererMain:
      return "RendererMain";

    case AndroidThreadTypeKHR::RendererWorker:
      return "RendererWorker";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a AndroidThreadTypeKHR value as a
 * std::string.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(AndroidThreadTypeKHR value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

#ifdef XR_KHR_visibility_mask
/*!
 * @brief Enum class for XrVisibilityMaskTypeKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskTypeKHR>
 *
 * @xrentity{XrVisibilityMaskTypeKHR}
 */
enum class VisibilityMaskTypeKHR : int32_t {

  HiddenTriangleMesh = XR_VISIBILITY_MASK_TYPE_HIDDEN_TRIANGLE_MESH_KHR,

  VisibleTriangleMesh = XR_VISIBILITY_MASK_TYPE_VISIBLE_TRIANGLE_MESH_KHR,

  LineLoop = XR_VISIBILITY_MASK_TYPE_LINE_LOOP_KHR,

};
static_assert(sizeof(VisibilityMaskTypeKHR) == sizeof(XrVisibilityMaskTypeKHR),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVisibilityMaskTypeKHR value from a
 * VisibilityMaskTypeKHR.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVisibilityMaskTypeKHR get(VisibilityMaskTypeKHR const& v) {
  return static_cast<XrVisibilityMaskTypeKHR>(v);
}

/*!
 * @brief Free function for retrieving the string name of a VisibilityMaskTypeKHR value as a const
 * char *.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    VisibilityMaskTypeKHR value) {
  switch (value) {
    case VisibilityMaskTypeKHR::HiddenTriangleMesh:
      return "HiddenTriangleMesh";

    case VisibilityMaskTypeKHR::VisibleTriangleMesh:
      return "VisibleTriangleMesh";

    case VisibilityMaskTypeKHR::LineLoop:
      return "LineLoop";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a VisibilityMaskTypeKHR value as a
 * std::string.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(VisibilityMaskTypeKHR value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_KHR_visibility_mask

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsDomainEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsDomainEXT>
 *
 * @xrentity{XrPerfSettingsDomainEXT}
 */
enum class PerfSettingsDomainEXT : int32_t {

  Cpu = XR_PERF_SETTINGS_DOMAIN_CPU_EXT,

  Gpu = XR_PERF_SETTINGS_DOMAIN_GPU_EXT,

};
static_assert(sizeof(PerfSettingsDomainEXT) == sizeof(XrPerfSettingsDomainEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsDomainEXT value from a
 * PerfSettingsDomainEXT.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsDomainEXT get(PerfSettingsDomainEXT const& v) {
  return static_cast<XrPerfSettingsDomainEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsDomainEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsDomainEXT value) {
  switch (value) {
    case PerfSettingsDomainEXT::Cpu:
      return "Cpu";

    case PerfSettingsDomainEXT::Gpu:
      return "Gpu";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsDomainEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsDomainEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsSubDomainEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsSubDomainEXT>
 *
 * @xrentity{XrPerfSettingsSubDomainEXT}
 */
enum class PerfSettingsSubDomainEXT : int32_t {

  Compositing = XR_PERF_SETTINGS_SUB_DOMAIN_COMPOSITING_EXT,

  Rendering = XR_PERF_SETTINGS_SUB_DOMAIN_RENDERING_EXT,

  Thermal = XR_PERF_SETTINGS_SUB_DOMAIN_THERMAL_EXT,

};
static_assert(sizeof(PerfSettingsSubDomainEXT) == sizeof(XrPerfSettingsSubDomainEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsSubDomainEXT value from a
 * PerfSettingsSubDomainEXT.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsSubDomainEXT
get(PerfSettingsSubDomainEXT const& v) {
  return static_cast<XrPerfSettingsSubDomainEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsSubDomainEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsSubDomainEXT value) {
  switch (value) {
    case PerfSettingsSubDomainEXT::Compositing:
      return "Compositing";

    case PerfSettingsSubDomainEXT::Rendering:
      return "Rendering";

    case PerfSettingsSubDomainEXT::Thermal:
      return "Thermal";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsSubDomainEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PerfSettingsSubDomainEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsLevelEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsLevelEXT>
 *
 * @xrentity{XrPerfSettingsLevelEXT}
 */
enum class PerfSettingsLevelEXT : int32_t {

  PowerSavings = XR_PERF_SETTINGS_LEVEL_POWER_SAVINGS_EXT,

  SustainedLow = XR_PERF_SETTINGS_LEVEL_SUSTAINED_LOW_EXT,

  SustainedHigh = XR_PERF_SETTINGS_LEVEL_SUSTAINED_HIGH_EXT,

  Boost = XR_PERF_SETTINGS_LEVEL_BOOST_EXT,

};
static_assert(sizeof(PerfSettingsLevelEXT) == sizeof(XrPerfSettingsLevelEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsLevelEXT value from a
 * PerfSettingsLevelEXT.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsLevelEXT get(PerfSettingsLevelEXT const& v) {
  return static_cast<XrPerfSettingsLevelEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsLevelEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsLevelEXT value) {
  switch (value) {
    case PerfSettingsLevelEXT::PowerSavings:
      return "PowerSavings";

    case PerfSettingsLevelEXT::SustainedLow:
      return "SustainedLow";

    case PerfSettingsLevelEXT::SustainedHigh:
      return "SustainedHigh";

    case PerfSettingsLevelEXT::Boost:
      return "Boost";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsLevelEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsLevelEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsNotificationLevelEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsNotificationLevelEXT>
 *
 * @xrentity{XrPerfSettingsNotificationLevelEXT}
 */
enum class PerfSettingsNotificationLevelEXT : int32_t {

  Normal = XR_PERF_SETTINGS_NOTIF_LEVEL_NORMAL_EXT,

  Warning = XR_PERF_SETTINGS_NOTIF_LEVEL_WARNING_EXT,

  Impaired = XR_PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED_EXT,

};
static_assert(sizeof(PerfSettingsNotificationLevelEXT) ==
                  sizeof(XrPerfSettingsNotificationLevelEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsNotificationLevelEXT value from a
 * PerfSettingsNotificationLevelEXT.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsNotificationLevelEXT
get(PerfSettingsNotificationLevelEXT const& v) {
  return static_cast<XrPerfSettingsNotificationLevelEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsNotificationLevelEXT value
 * as a const char *.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsNotificationLevelEXT value) {
  switch (value) {
    case PerfSettingsNotificationLevelEXT::Normal:
      return "Normal";

    case PerfSettingsNotificationLevelEXT::Warning:
      return "Warning";

    case PerfSettingsNotificationLevelEXT::Impaired:
      return "Impaired";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsNotificationLevelEXT value
 * as a std::string.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PerfSettingsNotificationLevelEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_FB_composition_layer_alpha_blend
/*!
 * @brief Enum class for XrBlendFactorFB
 *
 * Provided by the `XR_FB_composition_layer_alpha_blend` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBlendFactorFB>
 *
 * @xrentity{XrBlendFactorFB}
 */
enum class BlendFactorFB : int32_t {

  Zero = XR_BLEND_FACTOR_ZERO_FB,

  One = XR_BLEND_FACTOR_ONE_FB,

  SrcAlpha = XR_BLEND_FACTOR_SRC_ALPHA_FB,

  OneMinusSrcAlpha = XR_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA_FB,

  DstAlpha = XR_BLEND_FACTOR_DST_ALPHA_FB,

  OneMinusDstAlpha = XR_BLEND_FACTOR_ONE_MINUS_DST_ALPHA_FB,

};
static_assert(sizeof(BlendFactorFB) == sizeof(XrBlendFactorFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBlendFactorFB value from a BlendFactorFB.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBlendFactorFB get(BlendFactorFB const& v) {
  return static_cast<XrBlendFactorFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a BlendFactorFB value as a const char *.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BlendFactorFB value) {
  switch (value) {
    case BlendFactorFB::Zero:
      return "Zero";

    case BlendFactorFB::One:
      return "One";

    case BlendFactorFB::SrcAlpha:
      return "SrcAlpha";

    case BlendFactorFB::OneMinusSrcAlpha:
      return "OneMinusSrcAlpha";

    case BlendFactorFB::DstAlpha:
      return "DstAlpha";

    case BlendFactorFB::OneMinusDstAlpha:
      return "OneMinusDstAlpha";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BlendFactorFB value as a std::string.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BlendFactorFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_composition_layer_alpha_blend

#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandEXT>
 *
 * @xrentity{XrHandEXT}
 */
enum class HandEXT : int32_t {

  Left = XR_HAND_LEFT_EXT,

  Right = XR_HAND_RIGHT_EXT,

};
static_assert(sizeof(HandEXT) == sizeof(XrHandEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandEXT value from a HandEXT.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandEXT get(HandEXT const& v) {
  return static_cast<XrHandEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandEXT value as a const char *.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandEXT value) {
  switch (value) {
    case HandEXT::Left:
      return "Left";

    case HandEXT::Right:
      return "Right";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandEXT value as a std::string.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandJointEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointEXT>
 *
 * @xrentity{XrHandJointEXT}
 */
enum class HandJointEXT : int32_t {

  Palm = XR_HAND_JOINT_PALM_EXT,

  Wrist = XR_HAND_JOINT_WRIST_EXT,

  ThumbMetacarpal = XR_HAND_JOINT_THUMB_METACARPAL_EXT,

  ThumbProximal = XR_HAND_JOINT_THUMB_PROXIMAL_EXT,

  ThumbDistal = XR_HAND_JOINT_THUMB_DISTAL_EXT,

  ThumbTip = XR_HAND_JOINT_THUMB_TIP_EXT,

  IndexMetacarpal = XR_HAND_JOINT_INDEX_METACARPAL_EXT,

  IndexProximal = XR_HAND_JOINT_INDEX_PROXIMAL_EXT,

  IndexIntermediate = XR_HAND_JOINT_INDEX_INTERMEDIATE_EXT,

  IndexDistal = XR_HAND_JOINT_INDEX_DISTAL_EXT,

  IndexTip = XR_HAND_JOINT_INDEX_TIP_EXT,

  MiddleMetacarpal = XR_HAND_JOINT_MIDDLE_METACARPAL_EXT,

  MiddleProximal = XR_HAND_JOINT_MIDDLE_PROXIMAL_EXT,

  MiddleIntermediate = XR_HAND_JOINT_MIDDLE_INTERMEDIATE_EXT,

  MiddleDistal = XR_HAND_JOINT_MIDDLE_DISTAL_EXT,

  MiddleTip = XR_HAND_JOINT_MIDDLE_TIP_EXT,

  RingMetacarpal = XR_HAND_JOINT_RING_METACARPAL_EXT,

  RingProximal = XR_HAND_JOINT_RING_PROXIMAL_EXT,

  RingIntermediate = XR_HAND_JOINT_RING_INTERMEDIATE_EXT,

  RingDistal = XR_HAND_JOINT_RING_DISTAL_EXT,

  RingTip = XR_HAND_JOINT_RING_TIP_EXT,

  LittleMetacarpal = XR_HAND_JOINT_LITTLE_METACARPAL_EXT,

  LittleProximal = XR_HAND_JOINT_LITTLE_PROXIMAL_EXT,

  LittleIntermediate = XR_HAND_JOINT_LITTLE_INTERMEDIATE_EXT,

  LittleDistal = XR_HAND_JOINT_LITTLE_DISTAL_EXT,

  LittleTip = XR_HAND_JOINT_LITTLE_TIP_EXT,

};
static_assert(sizeof(HandJointEXT) == sizeof(XrHandJointEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointEXT value from a HandJointEXT.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointEXT get(HandJointEXT const& v) {
  return static_cast<XrHandJointEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointEXT value as a const char *.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointEXT value) {
  switch (value) {
    case HandJointEXT::Palm:
      return "Palm";

    case HandJointEXT::Wrist:
      return "Wrist";

    case HandJointEXT::ThumbMetacarpal:
      return "ThumbMetacarpal";

    case HandJointEXT::ThumbProximal:
      return "ThumbProximal";

    case HandJointEXT::ThumbDistal:
      return "ThumbDistal";

    case HandJointEXT::ThumbTip:
      return "ThumbTip";

    case HandJointEXT::IndexMetacarpal:
      return "IndexMetacarpal";

    case HandJointEXT::IndexProximal:
      return "IndexProximal";

    case HandJointEXT::IndexIntermediate:
      return "IndexIntermediate";

    case HandJointEXT::IndexDistal:
      return "IndexDistal";

    case HandJointEXT::IndexTip:
      return "IndexTip";

    case HandJointEXT::MiddleMetacarpal:
      return "MiddleMetacarpal";

    case HandJointEXT::MiddleProximal:
      return "MiddleProximal";

    case HandJointEXT::MiddleIntermediate:
      return "MiddleIntermediate";

    case HandJointEXT::MiddleDistal:
      return "MiddleDistal";

    case HandJointEXT::MiddleTip:
      return "MiddleTip";

    case HandJointEXT::RingMetacarpal:
      return "RingMetacarpal";

    case HandJointEXT::RingProximal:
      return "RingProximal";

    case HandJointEXT::RingIntermediate:
      return "RingIntermediate";

    case HandJointEXT::RingDistal:
      return "RingDistal";

    case HandJointEXT::RingTip:
      return "RingTip";

    case HandJointEXT::LittleMetacarpal:
      return "LittleMetacarpal";

    case HandJointEXT::LittleProximal:
      return "LittleProximal";

    case HandJointEXT::LittleIntermediate:
      return "LittleIntermediate";

    case HandJointEXT::LittleDistal:
      return "LittleDistal";

    case HandJointEXT::LittleTip:
      return "LittleTip";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointEXT value as a std::string.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandJointSetEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointSetEXT>
 *
 * @xrentity{XrHandJointSetEXT}
 */
enum class HandJointSetEXT : int32_t {

  Default = XR_HAND_JOINT_SET_DEFAULT_EXT,

};
static_assert(sizeof(HandJointSetEXT) == sizeof(XrHandJointSetEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointSetEXT value from a HandJointSetEXT.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointSetEXT get(HandJointSetEXT const& v) {
  return static_cast<XrHandJointSetEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointSetEXT value as a const char *.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointSetEXT value) {
  switch (value) {
    case HandJointSetEXT::Default:
      return "Default";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointSetEXT value as a std::string.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointSetEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * @brief Enum class for XrHandPoseTypeMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeMSFT>
 *
 * @xrentity{XrHandPoseTypeMSFT}
 */
enum class HandPoseTypeMSFT : int32_t {

  Tracked = XR_HAND_POSE_TYPE_TRACKED_MSFT,

  ReferenceOpenPalm = XR_HAND_POSE_TYPE_REFERENCE_OPEN_PALM_MSFT,

};
static_assert(sizeof(HandPoseTypeMSFT) == sizeof(XrHandPoseTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandPoseTypeMSFT value from a HandPoseTypeMSFT.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandPoseTypeMSFT get(HandPoseTypeMSFT const& v) {
  return static_cast<XrHandPoseTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandPoseTypeMSFT value as a const char
 * *.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HandPoseTypeMSFT value) {
  switch (value) {
    case HandPoseTypeMSFT::Tracked:
      return "Tracked";

    case HandPoseTypeMSFT::ReferenceOpenPalm:
      return "ReferenceOpenPalm";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandPoseTypeMSFT value as a std::string.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandPoseTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * @brief Enum class for XrReprojectionModeMSFT
 *
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReprojectionModeMSFT>
 *
 * @xrentity{XrReprojectionModeMSFT}
 */
enum class ReprojectionModeMSFT : int32_t {

  Depth = XR_REPROJECTION_MODE_DEPTH_MSFT,

  PlanarFromDepth = XR_REPROJECTION_MODE_PLANAR_FROM_DEPTH_MSFT,

  PlanarManual = XR_REPROJECTION_MODE_PLANAR_MANUAL_MSFT,

  OrientationOnly = XR_REPROJECTION_MODE_ORIENTATION_ONLY_MSFT,

};
static_assert(sizeof(ReprojectionModeMSFT) == sizeof(XrReprojectionModeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReprojectionModeMSFT value from a
 * ReprojectionModeMSFT.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrReprojectionModeMSFT get(ReprojectionModeMSFT const& v) {
  return static_cast<XrReprojectionModeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ReprojectionModeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ReprojectionModeMSFT value) {
  switch (value) {
    case ReprojectionModeMSFT::Depth:
      return "Depth";

    case ReprojectionModeMSFT::PlanarFromDepth:
      return "PlanarFromDepth";

    case ReprojectionModeMSFT::PlanarManual:
      return "PlanarManual";

    case ReprojectionModeMSFT::OrientationOnly:
      return "OrientationOnly";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ReprojectionModeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ReprojectionModeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_EXT_hand_joints_motion_range
/*!
 * @brief Enum class for XrHandJointsMotionRangeEXT
 *
 * Provided by the `XR_EXT_hand_joints_motion_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsMotionRangeEXT>
 *
 * @xrentity{XrHandJointsMotionRangeEXT}
 */
enum class HandJointsMotionRangeEXT : int32_t {

  Unobstructed = XR_HAND_JOINTS_MOTION_RANGE_UNOBSTRUCTED_EXT,

  ConformingToController = XR_HAND_JOINTS_MOTION_RANGE_CONFORMING_TO_CONTROLLER_EXT,

};
static_assert(sizeof(HandJointsMotionRangeEXT) == sizeof(XrHandJointsMotionRangeEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointsMotionRangeEXT value from a
 * HandJointsMotionRangeEXT.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointsMotionRangeEXT
get(HandJointsMotionRangeEXT const& v) {
  return static_cast<XrHandJointsMotionRangeEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointsMotionRangeEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HandJointsMotionRangeEXT value) {
  switch (value) {
    case HandJointsMotionRangeEXT::Unobstructed:
      return "Unobstructed";

    case HandJointsMotionRangeEXT::ConformingToController:
      return "ConformingToController";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointsMotionRangeEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    HandJointsMotionRangeEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_joints_motion_range

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComputeFeatureMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComputeFeatureMSFT>
 *
 * @xrentity{XrSceneComputeFeatureMSFT}
 */
enum class SceneComputeFeatureMSFT : int32_t {

  Plane = XR_SCENE_COMPUTE_FEATURE_PLANE_MSFT,

  PlaneMesh = XR_SCENE_COMPUTE_FEATURE_PLANE_MESH_MSFT,

  VisualMesh = XR_SCENE_COMPUTE_FEATURE_VISUAL_MESH_MSFT,

  ColliderMesh = XR_SCENE_COMPUTE_FEATURE_COLLIDER_MESH_MSFT,

#ifdef XR_MSFT_scene_understanding_serialization
  SerializeScene = XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
};
static_assert(sizeof(SceneComputeFeatureMSFT) == sizeof(XrSceneComputeFeatureMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeFeatureMSFT value from a
 * SceneComputeFeatureMSFT.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComputeFeatureMSFT
get(SceneComputeFeatureMSFT const& v) {
  return static_cast<XrSceneComputeFeatureMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeFeatureMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComputeFeatureMSFT value) {
  switch (value) {
    case SceneComputeFeatureMSFT::Plane:
      return "Plane";

    case SceneComputeFeatureMSFT::PlaneMesh:
      return "PlaneMesh";

    case SceneComputeFeatureMSFT::VisualMesh:
      return "VisualMesh";

    case SceneComputeFeatureMSFT::ColliderMesh:
      return "ColliderMesh";

#ifdef XR_MSFT_scene_understanding_serialization
    case SceneComputeFeatureMSFT::SerializeScene:
      return "SerializeScene";
#endif  // XR_MSFT_scene_understanding_serialization
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeFeatureMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneComputeFeatureMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComputeConsistencyMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComputeConsistencyMSFT>
 *
 * @xrentity{XrSceneComputeConsistencyMSFT}
 */
enum class SceneComputeConsistencyMSFT : int32_t {

  SnapshotComplete = XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_COMPLETE_MSFT,

  SnapshotIncompleteFast = XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_INCOMPLETE_FAST_MSFT,

  OcclusionOptimized = XR_SCENE_COMPUTE_CONSISTENCY_OCCLUSION_OPTIMIZED_MSFT,

};
static_assert(sizeof(SceneComputeConsistencyMSFT) == sizeof(XrSceneComputeConsistencyMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeConsistencyMSFT value from a
 * SceneComputeConsistencyMSFT.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComputeConsistencyMSFT
get(SceneComputeConsistencyMSFT const& v) {
  return static_cast<XrSceneComputeConsistencyMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeConsistencyMSFT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComputeConsistencyMSFT value) {
  switch (value) {
    case SceneComputeConsistencyMSFT::SnapshotComplete:
      return "SnapshotComplete";

    case SceneComputeConsistencyMSFT::SnapshotIncompleteFast:
      return "SnapshotIncompleteFast";

    case SceneComputeConsistencyMSFT::OcclusionOptimized:
      return "OcclusionOptimized";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeConsistencyMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SceneComputeConsistencyMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrMeshComputeLodMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMeshComputeLodMSFT>
 *
 * @xrentity{XrMeshComputeLodMSFT}
 */
enum class MeshComputeLodMSFT : int32_t {

  Coarse = XR_MESH_COMPUTE_LOD_COARSE_MSFT,

  Medium = XR_MESH_COMPUTE_LOD_MEDIUM_MSFT,

  Fine = XR_MESH_COMPUTE_LOD_FINE_MSFT,

  Unlimited = XR_MESH_COMPUTE_LOD_UNLIMITED_MSFT,

};
static_assert(sizeof(MeshComputeLodMSFT) == sizeof(XrMeshComputeLodMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMeshComputeLodMSFT value from a MeshComputeLodMSFT.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMeshComputeLodMSFT get(MeshComputeLodMSFT const& v) {
  return static_cast<XrMeshComputeLodMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a MeshComputeLodMSFT value as a const char
 * *.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MeshComputeLodMSFT value) {
  switch (value) {
    case MeshComputeLodMSFT::Coarse:
      return "Coarse";

    case MeshComputeLodMSFT::Medium:
      return "Medium";

    case MeshComputeLodMSFT::Fine:
      return "Fine";

    case MeshComputeLodMSFT::Unlimited:
      return "Unlimited";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MeshComputeLodMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MeshComputeLodMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComponentTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentTypeMSFT>
 *
 * @xrentity{XrSceneComponentTypeMSFT}
 */
enum class SceneComponentTypeMSFT : int32_t {

  Invalid = XR_SCENE_COMPONENT_TYPE_INVALID_MSFT,

  Object = XR_SCENE_COMPONENT_TYPE_OBJECT_MSFT,

  Plane = XR_SCENE_COMPONENT_TYPE_PLANE_MSFT,

  VisualMesh = XR_SCENE_COMPONENT_TYPE_VISUAL_MESH_MSFT,

  ColliderMesh = XR_SCENE_COMPONENT_TYPE_COLLIDER_MESH_MSFT,

#ifdef XR_MSFT_scene_understanding_serialization
  SerializedSceneFragment = XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
};
static_assert(sizeof(SceneComponentTypeMSFT) == sizeof(XrSceneComponentTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComponentTypeMSFT value from a
 * SceneComponentTypeMSFT.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComponentTypeMSFT
get(SceneComponentTypeMSFT const& v) {
  return static_cast<XrSceneComponentTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComponentTypeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComponentTypeMSFT value) {
  switch (value) {
    case SceneComponentTypeMSFT::Invalid:
      return "Invalid";

    case SceneComponentTypeMSFT::Object:
      return "Object";

    case SceneComponentTypeMSFT::Plane:
      return "Plane";

    case SceneComponentTypeMSFT::VisualMesh:
      return "VisualMesh";

    case SceneComponentTypeMSFT::ColliderMesh:
      return "ColliderMesh";

#ifdef XR_MSFT_scene_understanding_serialization
    case SceneComponentTypeMSFT::SerializedSceneFragment:
      return "SerializedSceneFragment";
#endif  // XR_MSFT_scene_understanding_serialization
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComponentTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneComponentTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneObjectTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectTypeMSFT>
 *
 * @xrentity{XrSceneObjectTypeMSFT}
 */
enum class SceneObjectTypeMSFT : int32_t {

  Uncategorized = XR_SCENE_OBJECT_TYPE_UNCATEGORIZED_MSFT,

  Background = XR_SCENE_OBJECT_TYPE_BACKGROUND_MSFT,

  Wall = XR_SCENE_OBJECT_TYPE_WALL_MSFT,

  Floor = XR_SCENE_OBJECT_TYPE_FLOOR_MSFT,

  Ceiling = XR_SCENE_OBJECT_TYPE_CEILING_MSFT,

  Platform = XR_SCENE_OBJECT_TYPE_PLATFORM_MSFT,

  Inferred = XR_SCENE_OBJECT_TYPE_INFERRED_MSFT,

};
static_assert(sizeof(SceneObjectTypeMSFT) == sizeof(XrSceneObjectTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneObjectTypeMSFT value from a
 * SceneObjectTypeMSFT.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneObjectTypeMSFT get(SceneObjectTypeMSFT const& v) {
  return static_cast<XrSceneObjectTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneObjectTypeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneObjectTypeMSFT value) {
  switch (value) {
    case SceneObjectTypeMSFT::Uncategorized:
      return "Uncategorized";

    case SceneObjectTypeMSFT::Background:
      return "Background";

    case SceneObjectTypeMSFT::Wall:
      return "Wall";

    case SceneObjectTypeMSFT::Floor:
      return "Floor";

    case SceneObjectTypeMSFT::Ceiling:
      return "Ceiling";

    case SceneObjectTypeMSFT::Platform:
      return "Platform";

    case SceneObjectTypeMSFT::Inferred:
      return "Inferred";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneObjectTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneObjectTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrScenePlaneAlignmentTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlaneAlignmentTypeMSFT>
 *
 * @xrentity{XrScenePlaneAlignmentTypeMSFT}
 */
enum class ScenePlaneAlignmentTypeMSFT : int32_t {

  NonOrthogonal = XR_SCENE_PLANE_ALIGNMENT_TYPE_NON_ORTHOGONAL_MSFT,

  Horizontal = XR_SCENE_PLANE_ALIGNMENT_TYPE_HORIZONTAL_MSFT,

  Vertical = XR_SCENE_PLANE_ALIGNMENT_TYPE_VERTICAL_MSFT,

};
static_assert(sizeof(ScenePlaneAlignmentTypeMSFT) == sizeof(XrScenePlaneAlignmentTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrScenePlaneAlignmentTypeMSFT value from a
 * ScenePlaneAlignmentTypeMSFT.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrScenePlaneAlignmentTypeMSFT
get(ScenePlaneAlignmentTypeMSFT const& v) {
  return static_cast<XrScenePlaneAlignmentTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ScenePlaneAlignmentTypeMSFT value as a
 * const char *.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ScenePlaneAlignmentTypeMSFT value) {
  switch (value) {
    case ScenePlaneAlignmentTypeMSFT::NonOrthogonal:
      return "NonOrthogonal";

    case ScenePlaneAlignmentTypeMSFT::Horizontal:
      return "Horizontal";

    case ScenePlaneAlignmentTypeMSFT::Vertical:
      return "Vertical";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ScenePlaneAlignmentTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    ScenePlaneAlignmentTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComputeStateMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComputeStateMSFT>
 *
 * @xrentity{XrSceneComputeStateMSFT}
 */
enum class SceneComputeStateMSFT : int32_t {

  None = XR_SCENE_COMPUTE_STATE_NONE_MSFT,

  Updating = XR_SCENE_COMPUTE_STATE_UPDATING_MSFT,

  Completed = XR_SCENE_COMPUTE_STATE_COMPLETED_MSFT,

  CompletedWithError = XR_SCENE_COMPUTE_STATE_COMPLETED_WITH_ERROR_MSFT,

};
static_assert(sizeof(SceneComputeStateMSFT) == sizeof(XrSceneComputeStateMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeStateMSFT value from a
 * SceneComputeStateMSFT.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComputeStateMSFT get(SceneComputeStateMSFT const& v) {
  return static_cast<XrSceneComputeStateMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeStateMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComputeStateMSFT value) {
  switch (value) {
    case SceneComputeStateMSFT::None:
      return "None";

    case SceneComputeStateMSFT::Updating:
      return "Updating";

    case SceneComputeStateMSFT::Completed:
      return "Completed";

    case SceneComputeStateMSFT::CompletedWithError:
      return "CompletedWithError";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeStateMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneComputeStateMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrEyeExpressionHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeExpressionHTC>
 *
 * @xrentity{XrEyeExpressionHTC}
 */
enum class EyeExpressionHTC : int32_t {

  LeftBlink = XR_EYE_EXPRESSION_LEFT_BLINK_HTC,

  LeftWide = XR_EYE_EXPRESSION_LEFT_WIDE_HTC,

  RightBlink = XR_EYE_EXPRESSION_RIGHT_BLINK_HTC,

  RightWide = XR_EYE_EXPRESSION_RIGHT_WIDE_HTC,

  LeftSqueeze = XR_EYE_EXPRESSION_LEFT_SQUEEZE_HTC,

  RightSqueeze = XR_EYE_EXPRESSION_RIGHT_SQUEEZE_HTC,

  LeftDown = XR_EYE_EXPRESSION_LEFT_DOWN_HTC,

  RightDown = XR_EYE_EXPRESSION_RIGHT_DOWN_HTC,

  LeftOut = XR_EYE_EXPRESSION_LEFT_OUT_HTC,

  RightIn = XR_EYE_EXPRESSION_RIGHT_IN_HTC,

  LeftIn = XR_EYE_EXPRESSION_LEFT_IN_HTC,

  RightOut = XR_EYE_EXPRESSION_RIGHT_OUT_HTC,

  LeftUp = XR_EYE_EXPRESSION_LEFT_UP_HTC,

  RightUp = XR_EYE_EXPRESSION_RIGHT_UP_HTC,

};
static_assert(sizeof(EyeExpressionHTC) == sizeof(XrEyeExpressionHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeExpressionHTC value from a EyeExpressionHTC.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeExpressionHTC get(EyeExpressionHTC const& v) {
  return static_cast<XrEyeExpressionHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeExpressionHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    EyeExpressionHTC value) {
  switch (value) {
    case EyeExpressionHTC::LeftBlink:
      return "LeftBlink";

    case EyeExpressionHTC::LeftWide:
      return "LeftWide";

    case EyeExpressionHTC::RightBlink:
      return "RightBlink";

    case EyeExpressionHTC::RightWide:
      return "RightWide";

    case EyeExpressionHTC::LeftSqueeze:
      return "LeftSqueeze";

    case EyeExpressionHTC::RightSqueeze:
      return "RightSqueeze";

    case EyeExpressionHTC::LeftDown:
      return "LeftDown";

    case EyeExpressionHTC::RightDown:
      return "RightDown";

    case EyeExpressionHTC::LeftOut:
      return "LeftOut";

    case EyeExpressionHTC::RightIn:
      return "RightIn";

    case EyeExpressionHTC::LeftIn:
      return "LeftIn";

    case EyeExpressionHTC::RightOut:
      return "RightOut";

    case EyeExpressionHTC::LeftUp:
      return "LeftUp";

    case EyeExpressionHTC::RightUp:
      return "RightUp";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EyeExpressionHTC value as a std::string.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeExpressionHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrLipExpressionHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLipExpressionHTC>
 *
 * @xrentity{XrLipExpressionHTC}
 */
enum class LipExpressionHTC : int32_t {

  JawRight = XR_LIP_EXPRESSION_JAW_RIGHT_HTC,

  JawLeft = XR_LIP_EXPRESSION_JAW_LEFT_HTC,

  JawForward = XR_LIP_EXPRESSION_JAW_FORWARD_HTC,

  JawOpen = XR_LIP_EXPRESSION_JAW_OPEN_HTC,

  MouthApeShape = XR_LIP_EXPRESSION_MOUTH_APE_SHAPE_HTC,

  MouthUpperRight = XR_LIP_EXPRESSION_MOUTH_UPPER_RIGHT_HTC,

  MouthUpperLeft = XR_LIP_EXPRESSION_MOUTH_UPPER_LEFT_HTC,

  MouthLowerRight = XR_LIP_EXPRESSION_MOUTH_LOWER_RIGHT_HTC,

  MouthLowerLeft = XR_LIP_EXPRESSION_MOUTH_LOWER_LEFT_HTC,

  MouthUpperOverturn = XR_LIP_EXPRESSION_MOUTH_UPPER_OVERTURN_HTC,

  MouthLowerOverturn = XR_LIP_EXPRESSION_MOUTH_LOWER_OVERTURN_HTC,

  MouthPout = XR_LIP_EXPRESSION_MOUTH_POUT_HTC,

  MouthSmileRight = XR_LIP_EXPRESSION_MOUTH_SMILE_RIGHT_HTC,

  MouthSmileLeft = XR_LIP_EXPRESSION_MOUTH_SMILE_LEFT_HTC,

  MouthSadRight = XR_LIP_EXPRESSION_MOUTH_SAD_RIGHT_HTC,

  MouthSadLeft = XR_LIP_EXPRESSION_MOUTH_SAD_LEFT_HTC,

  CheekPuffRight = XR_LIP_EXPRESSION_CHEEK_PUFF_RIGHT_HTC,

  CheekPuffLeft = XR_LIP_EXPRESSION_CHEEK_PUFF_LEFT_HTC,

  CheekSuck = XR_LIP_EXPRESSION_CHEEK_SUCK_HTC,

  MouthUpperUpright = XR_LIP_EXPRESSION_MOUTH_UPPER_UPRIGHT_HTC,

  MouthUpperUpleft = XR_LIP_EXPRESSION_MOUTH_UPPER_UPLEFT_HTC,

  MouthLowerDownright = XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNRIGHT_HTC,

  MouthLowerDownleft = XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNLEFT_HTC,

  MouthUpperInside = XR_LIP_EXPRESSION_MOUTH_UPPER_INSIDE_HTC,

  MouthLowerInside = XR_LIP_EXPRESSION_MOUTH_LOWER_INSIDE_HTC,

  MouthLowerOverlay = XR_LIP_EXPRESSION_MOUTH_LOWER_OVERLAY_HTC,

  TongueLongstep1 = XR_LIP_EXPRESSION_TONGUE_LONGSTEP1_HTC,

  TongueLeft = XR_LIP_EXPRESSION_TONGUE_LEFT_HTC,

  TongueRight = XR_LIP_EXPRESSION_TONGUE_RIGHT_HTC,

  TongueUp = XR_LIP_EXPRESSION_TONGUE_UP_HTC,

  TongueDown = XR_LIP_EXPRESSION_TONGUE_DOWN_HTC,

  TongueRoll = XR_LIP_EXPRESSION_TONGUE_ROLL_HTC,

  TongueLongstep2 = XR_LIP_EXPRESSION_TONGUE_LONGSTEP2_HTC,

  TongueUprightMorph = XR_LIP_EXPRESSION_TONGUE_UPRIGHT_MORPH_HTC,

  TongueUpleftMorph = XR_LIP_EXPRESSION_TONGUE_UPLEFT_MORPH_HTC,

  TongueDownrightMorph = XR_LIP_EXPRESSION_TONGUE_DOWNRIGHT_MORPH_HTC,

  TongueDownleftMorph = XR_LIP_EXPRESSION_TONGUE_DOWNLEFT_MORPH_HTC,

};
static_assert(sizeof(LipExpressionHTC) == sizeof(XrLipExpressionHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLipExpressionHTC value from a LipExpressionHTC.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLipExpressionHTC get(LipExpressionHTC const& v) {
  return static_cast<XrLipExpressionHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a LipExpressionHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LipExpressionHTC value) {
  switch (value) {
    case LipExpressionHTC::JawRight:
      return "JawRight";

    case LipExpressionHTC::JawLeft:
      return "JawLeft";

    case LipExpressionHTC::JawForward:
      return "JawForward";

    case LipExpressionHTC::JawOpen:
      return "JawOpen";

    case LipExpressionHTC::MouthApeShape:
      return "MouthApeShape";

    case LipExpressionHTC::MouthUpperRight:
      return "MouthUpperRight";

    case LipExpressionHTC::MouthUpperLeft:
      return "MouthUpperLeft";

    case LipExpressionHTC::MouthLowerRight:
      return "MouthLowerRight";

    case LipExpressionHTC::MouthLowerLeft:
      return "MouthLowerLeft";

    case LipExpressionHTC::MouthUpperOverturn:
      return "MouthUpperOverturn";

    case LipExpressionHTC::MouthLowerOverturn:
      return "MouthLowerOverturn";

    case LipExpressionHTC::MouthPout:
      return "MouthPout";

    case LipExpressionHTC::MouthSmileRight:
      return "MouthSmileRight";

    case LipExpressionHTC::MouthSmileLeft:
      return "MouthSmileLeft";

    case LipExpressionHTC::MouthSadRight:
      return "MouthSadRight";

    case LipExpressionHTC::MouthSadLeft:
      return "MouthSadLeft";

    case LipExpressionHTC::CheekPuffRight:
      return "CheekPuffRight";

    case LipExpressionHTC::CheekPuffLeft:
      return "CheekPuffLeft";

    case LipExpressionHTC::CheekSuck:
      return "CheekSuck";

    case LipExpressionHTC::MouthUpperUpright:
      return "MouthUpperUpright";

    case LipExpressionHTC::MouthUpperUpleft:
      return "MouthUpperUpleft";

    case LipExpressionHTC::MouthLowerDownright:
      return "MouthLowerDownright";

    case LipExpressionHTC::MouthLowerDownleft:
      return "MouthLowerDownleft";

    case LipExpressionHTC::MouthUpperInside:
      return "MouthUpperInside";

    case LipExpressionHTC::MouthLowerInside:
      return "MouthLowerInside";

    case LipExpressionHTC::MouthLowerOverlay:
      return "MouthLowerOverlay";

    case LipExpressionHTC::TongueLongstep1:
      return "TongueLongstep1";

    case LipExpressionHTC::TongueLeft:
      return "TongueLeft";

    case LipExpressionHTC::TongueRight:
      return "TongueRight";

    case LipExpressionHTC::TongueUp:
      return "TongueUp";

    case LipExpressionHTC::TongueDown:
      return "TongueDown";

    case LipExpressionHTC::TongueRoll:
      return "TongueRoll";

    case LipExpressionHTC::TongueLongstep2:
      return "TongueLongstep2";

    case LipExpressionHTC::TongueUprightMorph:
      return "TongueUprightMorph";

    case LipExpressionHTC::TongueUpleftMorph:
      return "TongueUpleftMorph";

    case LipExpressionHTC::TongueDownrightMorph:
      return "TongueDownrightMorph";

    case LipExpressionHTC::TongueDownleftMorph:
      return "TongueDownleftMorph";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LipExpressionHTC value as a std::string.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LipExpressionHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrFacialTrackingTypeHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackingTypeHTC>
 *
 * @xrentity{XrFacialTrackingTypeHTC}
 */
enum class FacialTrackingTypeHTC : int32_t {

  EyeDefault = XR_FACIAL_TRACKING_TYPE_EYE_DEFAULT_HTC,

  LipDefault = XR_FACIAL_TRACKING_TYPE_LIP_DEFAULT_HTC,

};
static_assert(sizeof(FacialTrackingTypeHTC) == sizeof(XrFacialTrackingTypeHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFacialTrackingTypeHTC value from a
 * FacialTrackingTypeHTC.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFacialTrackingTypeHTC get(FacialTrackingTypeHTC const& v) {
  return static_cast<XrFacialTrackingTypeHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FacialTrackingTypeHTC value as a const
 * char *.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FacialTrackingTypeHTC value) {
  switch (value) {
    case FacialTrackingTypeHTC::EyeDefault:
      return "EyeDefault";

    case FacialTrackingTypeHTC::LipDefault:
      return "LipDefault";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FacialTrackingTypeHTC value as a
 * std::string.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FacialTrackingTypeHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space
/*!
 * @brief Enum class for XrColorSpaceFB
 *
 * Provided by the `XR_FB_color_space` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColorSpaceFB>
 *
 * @xrentity{XrColorSpaceFB}
 */
enum class ColorSpaceFB : int32_t {

  Unmanaged = XR_COLOR_SPACE_UNMANAGED_FB,

  Rec2020 = XR_COLOR_SPACE_REC2020_FB,

  Rec709 = XR_COLOR_SPACE_REC709_FB,

  RiftCV1 = XR_COLOR_SPACE_RIFT_CV1_FB,

  RiftS = XR_COLOR_SPACE_RIFT_S_FB,

  Quest = XR_COLOR_SPACE_QUEST_FB,

  P3 = XR_COLOR_SPACE_P3_FB,

  AdobeRGB = XR_COLOR_SPACE_ADOBE_RGB_FB,

};
static_assert(sizeof(ColorSpaceFB) == sizeof(XrColorSpaceFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrColorSpaceFB value from a ColorSpaceFB.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrColorSpaceFB get(ColorSpaceFB const& v) {
  return static_cast<XrColorSpaceFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ColorSpaceFB value as a const char *.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ColorSpaceFB value) {
  switch (value) {
    case ColorSpaceFB::Unmanaged:
      return "Unmanaged";

    case ColorSpaceFB::Rec2020:
      return "Rec2020";

    case ColorSpaceFB::Rec709:
      return "Rec709";

    case ColorSpaceFB::RiftCV1:
      return "RiftCV1";

    case ColorSpaceFB::RiftS:
      return "RiftS";

    case ColorSpaceFB::Quest:
      return "Quest";

    case ColorSpaceFB::P3:
      return "P3";

    case ColorSpaceFB::AdobeRGB:
      return "AdobeRGB";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ColorSpaceFB value as a std::string.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ColorSpaceFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_color_space

#ifdef XR_FB_foveation_configuration
/*!
 * @brief Enum class for XrFoveationLevelFB
 *
 * Provided by the `XR_FB_foveation_configuration` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelFB>
 *
 * @xrentity{XrFoveationLevelFB}
 */
enum class FoveationLevelFB : int32_t {

  None = XR_FOVEATION_LEVEL_NONE_FB,

  Low = XR_FOVEATION_LEVEL_LOW_FB,

  Medium = XR_FOVEATION_LEVEL_MEDIUM_FB,

  High = XR_FOVEATION_LEVEL_HIGH_FB,

};
static_assert(sizeof(FoveationLevelFB) == sizeof(XrFoveationLevelFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelFB value from a FoveationLevelFB.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationLevelFB get(FoveationLevelFB const& v) {
  return static_cast<XrFoveationLevelFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FoveationLevelFB value) {
  switch (value) {
    case FoveationLevelFB::None:
      return "None";

    case FoveationLevelFB::Low:
      return "Low";

    case FoveationLevelFB::Medium:
      return "Medium";

    case FoveationLevelFB::High:
      return "High";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelFB value as a std::string.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationLevelFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_foveation_configuration

#ifdef XR_FB_foveation_configuration
/*!
 * @brief Enum class for XrFoveationDynamicFB
 *
 * Provided by the `XR_FB_foveation_configuration` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationDynamicFB>
 *
 * @xrentity{XrFoveationDynamicFB}
 */
enum class FoveationDynamicFB : int32_t {

  Disabled = XR_FOVEATION_DYNAMIC_DISABLED_FB,

  LevelEnabled = XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_FB,

};
static_assert(sizeof(FoveationDynamicFB) == sizeof(XrFoveationDynamicFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationDynamicFB value from a FoveationDynamicFB.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationDynamicFB get(FoveationDynamicFB const& v) {
  return static_cast<XrFoveationDynamicFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationDynamicFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FoveationDynamicFB value) {
  switch (value) {
    case FoveationDynamicFB::Disabled:
      return "Disabled";

    case FoveationDynamicFB::LevelEnabled:
      return "LevelEnabled";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationDynamicFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationDynamicFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_foveation_configuration

#ifdef XR_FB_triangle_mesh
/*!
 * @brief Enum class for XrWindingOrderFB
 *
 * Provided by the `XR_FB_triangle_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWindingOrderFB>
 *
 * @xrentity{XrWindingOrderFB}
 */
enum class WindingOrderFB : int32_t {

  Unknown = XR_WINDING_ORDER_UNKNOWN_FB,

  CW = XR_WINDING_ORDER_CW_FB,

  CCW = XR_WINDING_ORDER_CCW_FB,

};
static_assert(sizeof(WindingOrderFB) == sizeof(XrWindingOrderFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWindingOrderFB value from a WindingOrderFB.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrWindingOrderFB get(WindingOrderFB const& v) {
  return static_cast<XrWindingOrderFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a WindingOrderFB value as a const char *.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(WindingOrderFB value) {
  switch (value) {
    case WindingOrderFB::Unknown:
      return "Unknown";

    case WindingOrderFB::CW:
      return "CW";

    case WindingOrderFB::CCW:
      return "CCW";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a WindingOrderFB value as a std::string.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(WindingOrderFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough
/*!
 * @brief Enum class for XrPassthroughLayerPurposeFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerPurposeFB>
 *
 * @xrentity{XrPassthroughLayerPurposeFB}
 */
enum class PassthroughLayerPurposeFB : int32_t {

  Reconstruction = XR_PASSTHROUGH_LAYER_PURPOSE_RECONSTRUCTION_FB,

  Projected = XR_PASSTHROUGH_LAYER_PURPOSE_PROJECTED_FB,

#ifdef XR_FB_passthrough_keyboard_hands
  TrackedKeyboardHands = XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB,
#endif  // XR_FB_passthrough_keyboard_hands
};
static_assert(sizeof(PassthroughLayerPurposeFB) == sizeof(XrPassthroughLayerPurposeFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughLayerPurposeFB value from a
 * PassthroughLayerPurposeFB.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughLayerPurposeFB
get(PassthroughLayerPurposeFB const& v) {
  return static_cast<XrPassthroughLayerPurposeFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughLayerPurposeFB value as a
 * const char *.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PassthroughLayerPurposeFB value) {
  switch (value) {
    case PassthroughLayerPurposeFB::Reconstruction:
      return "Reconstruction";

    case PassthroughLayerPurposeFB::Projected:
      return "Projected";

#ifdef XR_FB_passthrough_keyboard_hands
    case PassthroughLayerPurposeFB::TrackedKeyboardHands:
      return "TrackedKeyboardHands";
#endif  // XR_FB_passthrough_keyboard_hands
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughLayerPurposeFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PassthroughLayerPurposeFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_passthrough
//! @}

}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_ENUMS_HPP_
